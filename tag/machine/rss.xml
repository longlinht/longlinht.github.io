<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it.</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Intall Emacs on Ubuntu</title>
	  <link>//install-emacs-on-ubuntu</link>
	  <author>Tao He</author>
	  <pubDate>2017-07-16T02:30:12+08:00</pubDate>
	  <guid>//install-emacs-on-ubuntu</guid>
	  <description><![CDATA[
	     <p>Install Emacs 25 on Ubuntu from source is very easy, follow these steps below could achieve it.</p>

<ul>
  <li>Open terminal (Ctrl+Alt+T) and run command to install build tools:</li>
</ul>

<p><code>
sudo apt install build-essential checkinstall
</code></p>

<ul>
  <li>Then install the build dependencies via command:</li>
</ul>

<p><code>
sudo apt-get build-dep emacs24
</code></p>

<ul>
  <li>
    <p>Now download the source at ftp.gnu.org/gnu/emacs/, then extract:</p>
  </li>
  <li>
    <p>Open terminal and navigate to the “emacs-25.1” folder via command (or select “Open in terminal” from its context menu):</p>
  </li>
</ul>

<p><code>
cd ~/Downloads/emacs-25.1
</code></p>

<ul>
  <li>In the same terminal window, once you’re in the source folder, run the commands below one by one:</li>
</ul>

<p><code>
./configure
make
</code></p>

<ul>
  <li>Finally use checkinstall command to create .deb and install Emacs 25.1:</li>
</ul>

<p>```
sudo checkinstall</p>

<p>```</p>

<p>While running the command, answer on screen questions, e.g., install docs, type package description, change package name, version, etc.</p>

<p>Once done, Emacs is installed on your system and you can remove it anytime by running the command in the prompt with sudo privilege:</p>

<p>In my case it’s:</p>

<p>```
sudo dpkg -r emacs-25</p>

<p>```
And the last command create a .deb package in the source folder, and it can be used in another Ubuntu machine to install Emacs(need to manually install dependencies via step 2).</p>

<p>Finally, run command emacs to launch the text editor, or launch it from Unity Dash (App Launcher) at next login (or next boot).</p>


	  ]]></description>
	</item>

	<item>
	  <title>在Android上实现无限翻页轮播动画效果</title>
	  <link>//implement-page-up-down-animation-on-android</link>
	  <author>Tao He</author>
	  <pubDate>2017-07-13T02:30:12+08:00</pubDate>
	  <guid>//implement-page-up-down-animation-on-android</guid>
	  <description><![CDATA[
	     <p>最近在工作中遇到一个需求，要求在一个Dialog的标题上显示两行字，但是这行字如果同时出现的话会非常难看，设计出了套方案，类似无限翻页轮播这两行字，要有翻书的效果。
刚开始实现的时候，动画的效果也出来了，但是拿去给设计验收的时候设计总感觉怪怪的，始终达不到设计最终想要的结果。后来通过好多次的调试和验证，发现问题出现在两个
View的动画播放时序和旋转轴的问题上，解决了这两个问题后再拿去给设计看的时候，一切都完美了。 现在这个比较好的设计也已上线， 也因为这个调试和验证的过程感觉对
Android动画的一些细节碰触的较多，所以写下此文记录下这个过程。</p>

<h4 id="section">基本原理</h4>

<p>通过<code>ObjectAnimation</code>操作<code>View</code>的<code>RotationY</code>属性，再利用动态改变<code>PivotY</code>的值和动画播放时序的不同来模拟出无限翻页轮播的动画效果</p>

<h4 id="objectanimation">ObjectAnimation</h4>

<p>```</p>

<p>// 上面的View翻下去的动画</p>

<p>private static ObjectAnimator aboveViewPageDownAnim;</p>

<p>// 下面的View翻上去的动画</p>

<p>private static ObjectAnimator belowViewPageUpAnim;</p>

<p>// 上面的View翻上去的动画</p>

<p>private static ObjectAnimator aboveViewPageUpAnim;</p>

<p>// 下面的View翻下去的动画</p>

<p>private static ObjectAnimator belowViewPageDownAnim;</p>

<p>```</p>

<h4 id="section-1">关键的常量</h4>

<p>```
// 翻页动画的播放时长</p>

<p>private static int pageUpDownDurition = 500;</p>

<p>// 翻下播放结束前100翻上就开始播放</p>

<p>private static int pageUpBeforeDownEnd = 400;</p>

<p>// 翻上播放完后停留时间</p>

<p>private static int belowViewStayInterval = 800;</p>

<p>// 在Y轴底部翻转</p>

<p>private static int pageUpPivotY = 100;</p>

<p>// 在Y近顶部的位置翻转</p>

<p>private static int pageDownPivotY = 70;</p>

<p>```</p>

<h4 id="section-2">具体实现</h4>

<p>```</p>

<p>public static void startPageUpDownAnimation(final View aboveView, final View belowView) {</p>

<pre><code>aboveViewPageDownAnim = ObjectAnimator.ofPropertyValuesHolder(aboveView,
        PropertyValuesHolder.ofFloat(View.ROTATION_X, 0, 90));

aboveViewPageDownAnim.setDuration(pageUpDownDurition);
aboveViewPageDownAnim.setInterpolator(new LinearInterpolator());
aboveViewPageDownAnim.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animator) {
        aboveView.setPivotY(pageDownPivotY);
        belowView.setVisibility(View.GONE);
        belowView.postDelayed(new Runnable() {
            @Override
            public void run() {
                belowViewPageUpAnim.start();
            }
        }, pageUpBeforeDownEnd);
    }

    @Override
    public void onAnimationEnd(Animator animator) {

    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});

belowViewPageUpAnim = ObjectAnimator.ofPropertyValuesHolder(belowView,
PropertyValuesHolder.ofFloat(View.ROTATION_X, -90, 0));
belowViewPageUpAnim.setDuration(pageUpDownDurition);
belowViewPageUpAnim.setInterpolator(new LinearInterpolator());
belowViewPageUpAnim.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animator) {
        belowView.setVisibility(View.VISIBLE);
        belowView.setPivotY(pageUpPivotY);
    }

    @Override
    public void onAnimationEnd(Animator animator) {
        belowView.postDelayed(new Runnable() {
            @Override
            public void run() {
                belowViewPageDownAnim.start();
            }
        }, belowViewStayInterval);
    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});

belowViewPageDownAnim = ObjectAnimator.ofPropertyValuesHolder(belowView,
        PropertyValuesHolder.ofFloat(View.ROTATION_X, 0, 90));

belowViewPageDownAnim.setDuration(pageUpDownDurition);
belowViewPageDownAnim.setInterpolator(new LinearInterpolator());
belowViewPageDownAnim.addListener(new Animator.AnimatorListener() {

    @Override
    public void onAnimationStart(Animator animator) {
        belowView.setPivotY(pageDownPivotY);
        aboveView.setVisibility(View.GONE);
        aboveView.postDelayed(new Runnable() {
            @Override
            public void run() {
                aboveViewPageUpAnim.start();
            }
        }, pageUpBeforeDownEnd);
    }

    @Override
    public void onAnimationEnd(Animator animator) {

    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});

aboveViewPageUpAnim = ObjectAnimator.ofPropertyValuesHolder(aboveView,
        PropertyValuesHolder.ofFloat(View.ROTATION_X, -90, 0));
aboveViewPageUpAnim.setDuration(pageUpDownDurition);
aboveViewPageUpAnim.setInterpolator(new LinearInterpolator());
aboveViewPageUpAnim.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animator) {
        aboveView.setVisibility(View.VISIBLE);
        aboveView.setPivotY(pageUpPivotY);
    }

    @Override
    public void onAnimationEnd(Animator animator) {
        aboveView.postDelayed(new Runnable() {
            @Override
            public void run() {
                aboveViewPageDownAnim.start();
            }
        }, belowViewStayInterval);
    }

    @Override
    public void onAnimationCancel(Animator animator) {

    }

    @Override
    public void onAnimationRepeat(Animator animator) {

    }
});

aboveViewPageDownAnim.start(); } ```
</code></pre>

<p>其实这个实现已经是一个基本比较通用的翻页动画了，不仅可以用于TextView，ImageView应该也没有问题。</p>

	  ]]></description>
	</item>

	<item>
	  <title>对AI的一些臆想</title>
	  <link>//think-about-AI</link>
	  <author>Tao He</author>
	  <pubDate>2017-07-10T02:30:12+08:00</pubDate>
	  <guid>//think-about-AI</guid>
	  <description><![CDATA[
	     <p>作为一个码农，长期从事应用研发的工作，于当下热门的人工智能其实一点都没有交集，既不了解机器学习，也没有接触过计算机神经网络，甚至没有使用过Hadoop这种技术，可谓对AI相关的领域所知甚少，但这并不阻碍我对AI产生一些思考和想法，而这些思考和想法的缘起竟然都是这一两年上映的几部AI相关的电影和相关的几本畅销书，其中所涉及的技术和思想也都相对易懂，和机器学习类的书籍形成鲜明对比。</p>

<p>但是通俗易懂并不代表其中的想法和思考无足轻重，相反，我认为如下的一些想法新颖具有启发性：</p>

<p>意识永生，简单的说就是人类的肉体可以死亡，但是把意识转移到了AI中，没有输入人类意识的AI可以通过学习获得人类的智能和意识，输入了人类意识的AI和真正的人类无异，结果就是人类的存在有了另外一种形式，人类的存在摆脱了肉体，智能的载体既可以是碳也可以是硅，这种想法其实很自然，人类要想在宇宙间获得更大的自由和实现更多的可能，肉体凡胎也许始终是一个阻碍和限制，尤其在面对宇宙近于无限的空间和时间时，人类更加渴望脱离这幅躯壳。</p>

<p>当然也有一些电影和书籍对技术的演进速度没有那么乐观，认为意识永生的概念太过理想化，太遥远，而他们所持的态度显得更加保守和务实，认为短期内达到人类智能水平的AI不会出现，AI的智能水平会越来越强，但是还是作为人类社会的一种技术形式存在，对人的能力的极大延伸，既不会超越人类，更不会取代人类。作为对人类的延伸，有可能在未来出现半人半机器的存在。</p>

<p>另一种大胆的想法认为，人类的未来之路就是被AI取代，人类打开了这个潘多拉魔盒，造成了无法逆转的灾难，人类彻底被取代，或被消灭，这种设想和猜测在时下非常流行，甚至有一些AI和计算机方面的专家都发出警告，要人类警惕AI的进一步发展。</p>

<p>以上就是一些我截取的一些有意思的观点和想法，可以看出近几年的一些电影和书籍多半不会深入艰深的技术细节，而多是通过对AI未来的畅想和猜测，以及带入AI这个特殊角色后对人类自身的一种反省和思考，我因受这些想法和思考的影响，也时而会在脑中闪出一下奇怪的想法，我甚至也不明白我为什么会产生这些奇思异想。</p>

<p>我竟想到人类的起源和AI的未来可能有某种相似性，怎么说呢？因为我之前看到过一些文章分析人类可能并不是地球上的土著生物，可能真的是被一种神一样的存在所创造的，无中生有的，而这种神一样的存在现在却只留在了人类的神话中，我突然就想到，这种神一样的存在创造了我们，而后被我们所取代，他们存在过的痕迹也就只留在了我们的神话中，也许我们现在之于AI，就是那个神一样的存在，但我们最终会被AI取代，只留在AI的神话中，就跟没存在过一样……</p>

<p>也许人类的真正归宿还真就是以硅为载体，以此长存于世，胡说八道了这么多，可以止笔了，再有臆想，再来码字</p>


	  ]]></description>
	</item>

	<item>
	  <title>Dimension Units in Android</title>
	  <link>//dimension-units-in-android</link>
	  <author>Tao He</author>
	  <pubDate>2017-04-07T20:30:12+08:00</pubDate>
	  <guid>//dimension-units-in-android</guid>
	  <description><![CDATA[
	     <p>When I start develop application for Android, I am confused about the dimension units many times. So I decide to figure out it clearly through this article.</p>

<p>Android is a mobile operating system that compatible many devices, because of its compatibility, we must think about vary size, density, shape of device’s screen. The <strong>density independence</strong> is a important conception here. Later, I will explain detail about it. Now, we need give the defination of the dimension units and explain the relation of them.</p>

<h3 id="dimension-unit">Dimension Unit</h3>

<h4 id="defination">Defination</h4>

<ul>
  <li>
    <p><strong>px</strong> - An actual pixel on the screen.</p>
  </li>
  <li>
    <p><strong>in</strong> - A physical inch on the screen.</p>
  </li>
  <li>
    <p><strong>mm</strong> - A physical millimeter on the screen.</p>
  </li>
  <li>
    <p><strong>pt</strong> - A point, a common font size unit, on the screen. </p>
  </li>
  <li>
    <p><strong>dp</strong> - An abstract unit that is based on the physical density of the screen. These units are relative to a 160 dpi (dots per inch) screen, on which 1dp is roughly equal to 1px. </p>
  </li>
  <li>
    <p><strong>sp</strong> - A scale independent pixel, specially designated for text sizes. </p>
  </li>
</ul>

<h4 id="relation">Relation</h4>

<p>```
+—————-+—————-+—————+——————————-+
| Density Bucket | Screen Density | Physical Size | Pixel Size                    | 
+—————-+—————-+—————+——————————-+
| ldpi           | 120 dpi        | 0.5 x 0.5 in  | 0.5 in * 120 dpi = 60x60 px   | 
+—————-+—————-+—————+——————————-+
| mdpi           | 160 dpi        | 0.5 x 0.5 in  | 0.5 in * 160 dpi = 80x80 px   | 
+—————-+—————-+—————+——————————-+
| hdpi           | 240 dpi        | 0.5 x 0.5 in  | 0.5 in * 240 dpi = 120x120 px | 
+—————-+—————-+—————+——————————-+
| xhdpi          | 320 dpi        | 0.5 x 0.5 in  | 0.5 in * 320 dpi = 160x160 px | 
+—————-+—————-+—————+——————————-+
| xxhdpi         | 480 dpi        | 0.5 x 0.5 in  | 0.5 in * 480 dpi = 240x240 px | 
+—————-+—————-+—————+——————————-+
| xxxhdpi        | 640 dpi        | 0.5 x 0.5 in  | 0.5 in * 640 dpi = 320x320 px | 
+—————-+—————-+—————+——————————-+</p>

<p>+———+————-+—————+————-+——————–+
| Unit    | Description | Units Per     | Density     | Same Physical Size | 
|         |             | Physical Inch | Independent | On Every Screen    | 
+———+————-+—————+————-+——————–+
| px      | Pixels      | Varies        | No          | No                 | 
+———+————-+—————+————-+——————–+
| in      | Inches      | 1             | Yes         | Yes                | 
+———+————-+—————+————-+——————–+
| mm      | Millimeters | 25.4          | Yes         | Yes                | 
+———+————-+—————+————-+——————–+
| pt      | Points      | 72            | Yes         | Yes                | 
+———+————-+—————+————-+——————–+
| dp      | Density     | ~160          | Yes         | No                 | 
|         | Independent |               |             |                    | 
|         | Pixels      |               |             |                    | 
+———+————-+—————+————-+——————–+
| sp      | Scale       | ~160          | Yes         | No                 | 
|         | Independent |               |             |                    | 
|         | Pixels      |               |             |                    | 
+———+————-+—————+————-+——————–+
```</p>

<h3 id="density-independence">Density Independence</h3>

<p><strong>Screen Density</strong></p>

<p>Screen density is a ratio of resolution and display size, which can be quantified as dots per inch, or <strong>dpi</strong>. The higher the dpi, the smaller each individual pixel is, and the greater clarity.</p>

<p><strong>Density Independence</strong> means the physical size of a dimension unit is only approximately the same on every screen density. The <strong>dp, sp, pt, mm, in</strong> are all density independence. The number of pixels these translate to varies depending on screen density and the <strong>density bucket</strong> the device falls into.</p>

<p><strong>Density Bucket</strong></p>

<blockquote>
  <p>There is a myriad of Android devices with varying screen densities, which can range from 100 dpi to over 480 dpi. In order to optimize images for all these screen densities, images need to be created at different resolutions. However, trying to optimize every image resource for every possible density would be incredibly tedious, cause app sizes to be enormous, and simply is not a feasible solution. As a compromise, Android uses density “buckets” that are used to group devices together within certain screen density ranges. This way, apps are only required to optimize images for each density bucket, instead of every possible density. This keeps the workload reasonable for designers and developer, and also prevents the application size from ballooning. Of course, there is a tradeoff, leading to variance in the physical rendered size of images depending on device density.</p>
</blockquote>

<h3 id="using-tips">Using Tips:</h3>

<ul>
  <li>
    <p>Try to use dp in xml file as much as possiable.</p>
  </li>
  <li>
    <p>Use sp for font size.</p>
  </li>
  <li>
    <p>Don’t use px as much as possiable.</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Building My Own Mac Working Environment</title>
	  <link>//building-my-own-mac-working-environment</link>
	  <author>Tao He</author>
	  <pubDate>2017-04-02T06:30:12+08:00</pubDate>
	  <guid>//building-my-own-mac-working-environment</guid>
	  <description><![CDATA[
	     <p>In recent 2 years, I have switched my own working environment from Windows to Ubuntu and Mac. For the reason that I switched C/C++ development for Windows to Java development for Android. But I still prefer C++, so I won’t give up C/C++ programming. In this article I will write down detail steps that how I build working environment. This working environment on Mac is a general working environment, not just for Android development but also C/C++ development. Let’s start!</p>

<p>First, I would install some universal tools.</p>

<h3 id="universal-tools">Universal Tools</h3>

<h4 id="install-and-configure-oh-my-zsh">Install and configure Oh my zsh</h4>

<ul>
  <li>Install via curl or wget</li>
</ul>

<p><strong>via curl</strong></p>

<p><code>
sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
</code>
<strong>via wget</strong></p>

<p><code>
sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"
</code> </p>

<ul>
  <li>Configure my prefer feature via edit .zshrc file</li>
</ul>

<p>Add this line to .zshrc file
<code>
plugins=(git vi-mode adb)
</code>
#### Install and configure iTerm</p>

<ul>
  <li>
    <p>Install lastest release dmg</p>
  </li>
  <li>Clone solarized git project from github and import color scheme for iTerm2
<code>
git clone https://github.com/altercation/solarized.git
cd iterm2-colors-solarized
./Solarized Dark.itermcolors
</code>
#### Install userful command line tools</li>
  <li>
    <p>Install brew - <code>ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code></p>
  </li>
  <li>
    <p>Install ctags - <code>brew install ctags</code></p>
  </li>
  <li>
    <p>Install cscope - <code>brew install cscope</code></p>
  </li>
  <li>
    <p>Install ag - <code>brew install ag</code></p>
  </li>
  <li>Install grip - <code>brew install grip</code></li>
</ul>

<h4 id="install-and-configure-vim">Install and configure Vim</h4>

<ul>
  <li>Install vim via source
<code>
git clone https://github.com/vim/vim.git
cd vim 
./configure --with-features=huge --enable-gui=gnome2 --enable-pythoninterp=yes --enable-cscope --enable-gui=auto \ --enable-gtk2-check --enable-gnome-check \ --enable-fail-if-missing --enable-multibyte --enable-fontset \ --with-x --with-compiledby="Tao He"
make
sudo make install
</code></li>
  <li>
    <p>Configure vim
<code>
cd ~
git clone https://github.com/longlinht/vimrc.git ~/.vim_runtime
sh ~/.vim_runtime/install_awesome_vimrc.sh
</code>
### Utilities</p>
  </li>
  <li>
    <p>Install Alfred</p>
  </li>
  <li>
    <p>Install Dropbox</p>
  </li>
  <li>Install NutsCloud</li>
</ul>

<h3 id="install-ide">Install IDE</h3>

<h4 id="install-and-configure-android-studio">Install and configure Android Studio</h4>

<ul>
  <li>
    <p>Install Android Studio via dmg</p>
  </li>
  <li>
    <p>Install and configure ideavim plugin 
<code>
Install ideavim in Android Studio
git clone https://github.com/longlinht/VimForIDEs.git
In Android Studio -&gt; File -&gt;Import Settings -&gt; Choose VimForIDEs/ideavim/monokai/settings.jar
</code></p>
  </li>
</ul>

<p>There are some userful application I have installed, but I don’t want to list them becasue their easy installation. Until now, I work comfortably in this woking environment. Maybe I will develop a script to automate this process in the future. If I make it done, I would update this article and supply this script.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Java References</title>
	  <link>//java-references</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-10T00:00:00+08:00</pubDate>
	  <guid>//java-references</guid>
	  <description><![CDATA[
	     <p>Before JDK 1.2, if a object isn’t referenced by any variable, it can’t be used any more.Since JDK 1.2, Java has four reference types.In order from strongest to weakest these references are: Strong, Soft, Weak, Phantom. </p>

<h4 id="strong-reference">Strong reference</h4>

<p>Below code is regular object reference:</p>

<p><code>java
Sample sample = new Sample();
</code></p>

<p>The variable <code>sample</code> holds a strong reference to a Sample object. Before you stop reading there is a point to this: objects that are reachable through any chain of strong references are not eligible for garbage collection. Even JVM throw <code>OutOfMemoryError</code> to terminate the program, it will not to reclaim the memory that strong reference hold.</p>

<h4 id="soft-reference">Soft reference</h4>

<p>Soft references are cleared at the discretion of the garbage collector in response to memory demand. The virtual machine guarantees that all soft references to softly-reachable objects will have been cleared before it would ever throw an <code>OutOfMemoryError</code>.</p>

<h4 id="weak-reference">Weak reference</h4>

<p>This code snippets is regular weak reference:</p>

<p><code>java
WeakReference&lt;Cacheable&gt; weakData = new WeakReference&lt;Cacheable&gt;(data);
</code>
To access data call weakData.get(). This call to get may return <code>null</code> if the weak reference was garbage collected: you must check the returned value to avoid <code>NullPointerException</code>s.</p>

<p>An object that is identified as only weakly reachable will be collected at the next GC cycle.</p>

<p>If you pass a <code>ReferenceQueue</code> into the constructor for a weak reference then the garbage collector will append that weak reference to the <code>ReferenceQueue</code> when it is no longer needed. You can periodically process this queue and deal with dead references.</p>

<p>The difference between <code>SoftReference</code> and <code>WeakReference</code> is:</p>

<ul>
  <li>
    <p>A soft reference is exactly like a weak reference, except that it is less eager to throw away the object to which it refers. </p>
  </li>
  <li>
    <p>An object which is only weakly reachable (the strongest references to it are WeakReferences) will be discarded at the next garbage collection cycle, but an object which is softly reachable will generally stick around for a while.</p>
  </li>
  <li>
    <p><code>SoftReferences</code> aren’t required to behave any differently than <code>WeakReferences</code>, but in practice softly reachable objects are generally retained as long as memory is in plentiful supply. This makes them an excellent foundation for a cache, such as the image cache described above, since you can let the garbage collector worry about both how reachable the objects are (a strongly reachable object will never be removed from the cache) and how badly it needs the memory they are consuming.</p>
  </li>
  <li>
    <p>Garbage collector uses algorithms to decide whether or not to reclaim a softly reachable object, but always reclaims a weakly reachable object.</p>
  </li>
</ul>

<h4 id="phantom-reference">Phantom reference</h4>

<p>Phantom references are the most tenuous of all reference types: calling get will always return null.
When you construct a phantom reference you must always pass in a <code>ReferenceQueue</code>. </p>

<p><code>java
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
</code></p>

<p>This indicates that you can use a phantom reference to see when your object is GC’d. The phantom reference is enqueued after it has been physically removed from memory — as opposed to weak references which are enqueued before they’re finalized or GC’d.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Android Thread Related Stuff</title>
	  <link>//thread-looper-handler-in-android</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-06T03:00:00+08:00</pubDate>
	  <guid>//thread-looper-handler-in-android</guid>
	  <description><![CDATA[
	     <p>It’s widely known that it’s illegal to update UI components directly from threads other than main thread in android. This a rule in Android world, we can’t violate it. But, so many situations we need 
update UI when we finish something in separated thread. This is a basic problem, it will refer more important concepts related thread.</p>

<h4 id="looper"><code>Looper</code></h4>

<ul>
  <li>
    <p>Class used to run a message loop for a thread.</p>
  </li>
  <li>
    <p>The <code>Looper</code> class maintains a synchronized <code>MessageQueue</code>, which contains a list messages.It reads and processes items from a <code>MessageQueue</code>.</p>
  </li>
  <li>
    <p>Threads by default do not have a message loop associated with them, to create one, call <code>prepare()</code> in the thread that is to run the loop, and then <code>loop()</code> to have it process messages until the loop is stopped.</p>
  </li>
  <li>
    <p>It’s associated with the thread within which the <code>Looper</code> is created. This association is kept forever and can’t be broken nor changed. Also note that a thread can’t be associated with more than one Looper. </p>
  </li>
  <li>
    <p>The <code>Looper</code> class is usually used in conjunction with a <code>HandlerThread</code> (a subclass of Thread).</p>
  </li>
  <li>
    <p>There are 2 methods to terminate a Looper:</p>

    <ul>
      <li>
        <p>Looper.quit()</p>
      </li>
      <li>
        <p>Looper.quitSafely() </p>
      </li>
    </ul>
  </li>
  <li>
    <p>Most interaction with a message loop is through the <code>Handler</code> class.</p>
  </li>
</ul>

<h4 id="handler"><code>Handler</code></h4>

<ul>
  <li>
    <p>Allow you send and process <code>Message</code> and <code>Runnable</code> objects associated with a thread’s <code>MessageQueue</code>. </p>
  </li>
  <li>
    <p>Each <code>Handler</code> instance is associated with a single thread and that thread’s message queue. Multiple Handler instances can be bound to the same thread.</p>
  </li>
  <li>
    <p>It is bound to the thread / message queue of the thread that is creating it.</p>
  </li>
  <li>
    <p>There are two main uses for a Handler: </p>

    <ul>
      <li>
        <p>To schedule messages and runnables to be executed as some point in the future. </p>
      </li>
      <li>
        <p>To enqueue an action to be performed on a different thread than your own.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="message"><code>Message</code></h4>

<ul>
  <li>
    <p>Defines a message containing a description and arbitrary data object that can be sent to a Handler. This object contains two extra int fields and an extra object field that allow you to not do allocations in many cases.</p>
  </li>
  <li>
    <p>While the constructor of Message is public, the best way to get one of these is to call <code>Message.obtain()</code> or one of the <code>Handler.obtainMessage()</code> methods, which will pull them from a pool of recycled objects.</p>
  </li>
</ul>

<h4 id="handlerthread"><code>HandlerThread</code></h4>

<ul>
  <li>
    <p><code>HandlerThread</code> is a handy class for starting a new thread that has a Looper.prepare(), Looper. </p>
  </li>
  <li>
    <p>You generally need a thread attached with a Looper when you want sequential execution of tasks without race conditions and keep a thread alive even after a particular task is completed so that it can be reused so that you don’t have to create new thread instances.</p>
  </li>
</ul>

<p>Once a HandlerThread is started, it sets up queuing through a Looper and MessageQueue and waits for incoming messages to process:</p>

<p>```java</p>

<p>HandlerThread handlerThread = new HandlerThread(“HandlerThread”);
handlerThread.start();</p>

<p>// Create a handler attached to the HandlerThread’s Looper
mHandler = new Handler(handlerThread.getLooper()) {
    @Override
    public void handleMessage(Message msg) {
        // Process messages here
    }
};
 
// Now send messages using mHandler.sendMessage()</p>

<p>```</p>

	  ]]></description>
	</item>

	<item>
	  <title>Understanding Java Garbage Collection</title>
	  <link>//java-garbage-collection</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-05T00:00:00+08:00</pubDate>
	  <guid>//java-garbage-collection</guid>
	  <description><![CDATA[
	     <p><strong>stop-the-world</strong> Stop-the-world means that the JVM is stopping the application from running to execute a GC. When stop-the-world occurs, every thread except for the threads needed for the GC will stop their tasks. The interrupted tasks will resume only after the GC task has completed. GC tuning often means reducing this stop-the-world time.</p>

<h4 id="generational-garbage-collection">Generational Garbage Collection</h4>

<p>Java does not explicitly specify a memory and remove it in the program code.Maybe there is to way to remove the memory explicitly :</p>

<ul>
  <li>
    <p>Sets the relevant object to null</p>
  </li>
  <li>
    <p>Use System.gc() method to remove the memory - will affect the system performance drastically</p>
  </li>
</ul>

<p>But nobody do that. GC responsible to finds the unnecessary objects to remove them. GC created based on the following two preconditions:</p>

<ul>
  <li>
    <p>Most objects soon become unreachable.</p>
  </li>
  <li>
    <p>References from old objects to young objects only exist in small numbers.</p>
  </li>
</ul>

<h5 id="young-generation">Young generation</h5>

<p>Most of the newly created objects are located here. Since most objects soon become unreachable, many objects are created in the young generation, then disappear. When objects disappear from this area, we say a “minor GC” has occurred.</p>

<h5 id="old-generation">Old generation</h5>

<p>The objects that did not become unreachable and survived from the young generation are copied here. It is generally larger than the young generation. As it is bigger in size, the GC occurs less frequently than in the young generation. When objects disappear from the old generation, we say a “major GC” (or a “full GC”) has occurred.</p>

<h5 id="permanent-generation">Permanent generation</h5>

<p>It stores classes or interned character strings. So, this area is definitely not for objects that survived from the old generation to stay permanently. A GC may occur in this area. The GC that took place here is still counted as a major GC.</p>

<h4 id="composition-of-the-young-generation">Composition of the Young Generation</h4>
<p>The young generation is divided into 3 spaces. </p>

<ul>
  <li>
    <p>One Eden space</p>
  </li>
  <li>
    <p>Two Survivor spaces</p>
  </li>
</ul>

<p>There are 3 spaces in total, two of which are Survivor spaces. The order of execution process of each space is as below:</p>

<ul>
  <li>
    <p>The majority of newly created objects are located in the Eden space.</p>
  </li>
  <li>
    <p>After one GC in the Eden space, the surviving objects are moved to one of the Survivor spaces. </p>
  </li>
  <li>
    <p>After a GC in the Eden space, the objects are piled up into the Survivor space, where other surviving objects already exist.</p>
  </li>
  <li>
    <p>Once a Survivor space is full, surviving objects are moved to the other Survivor space. Then, the Survivor space that is full will be changed to a state where there is no data at all.</p>
  </li>
  <li>
    <p>The objects that survived these steps that have been repeated a number of times are moved to the old generation.</p>
  </li>
</ul>

<h5 id="gc-for-the-old-generation">GC for the Old Generation</h5>

<p>The old generation basically performs a GC when the data is full. The execution procedure varies by the GC type, so it would be easier to understand if you know different types of GC.
According to JDK 7, there are 5 GC types.</p>

<ul>
  <li>
    <p>Serial GC</p>
  </li>
  <li>
    <p>Parallel GC</p>
  </li>
  <li>
    <p>Parallel Old GC (Parallel Compacting GC)</p>
  </li>
  <li>
    <p>Concurrent Mark &amp; Sweep GC (or “CMS”)</p>
  </li>
  <li>
    <p>Garbage First (G1) GC</p>
  </li>
</ul>

<p>This article will not introduce 5 GCs, if you interested in, please google it.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Android Binder Mechanism</title>
	  <link>//android-binder-mechanism</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-03T03:00:00+08:00</pubDate>
	  <guid>//android-binder-mechanism</guid>
	  <description><![CDATA[
	     <h4 id="what-is-binder">What is Binder</h4>

<ul>
  <li>The Binder mechanism has started from a simple idea. </li>
</ul>

<blockquote>
  <p>“Let requests and responses be written in an area where all processes can share and let each process refer to the memory address.” </p>
</blockquote>

<ul>
  <li>
    <p>Binder is a IPC mechanism.</p>
  </li>
  <li>
    <p>Binder implementation is based on <strong>OpenBinder</strong>.</p>
  </li>
  <li>
    <p>Binder refers to a kernel memory which is shared between all processes to minimize the overhead caused by memory copy. </p>
  </li>
  <li>
    <p>It provides the Remote Procedure Call (RPC) framework written in C++ for high productivity.</p>
  </li>
</ul>

<h4 id="why-need-binder">Why need Binder</h4>

<ul>
  <li>
    <p>Android need IPC mechanism because of its loosely coupled component design. Every application in Android is comprised of some components ,like Activity or Service, they maybe in same process or not. If they are in different process, they need communicate each other.</p>
  </li>
  <li>
    <p>All of the default system functions of Android are provided as the <strong>server process</strong> type. In other words, to use the functions such as <code>SurfaceFlinger</code> or <code>AudioFlinger</code>, a request should be made as a separate process that runs on the user mode. As all system services are provided as a <strong>server process</strong>, a mechanism to send requests and responses to other processes is necessary. In Android it is called the Binder. Android uses functions provided by other processes through Binder.</p>
  </li>
  <li>
    <p>Android is based on Linux, Linux has a lot of IPC mechanism. But, Android didn’t adopted it. Maybe because of performance and low memory of Android device.</p>
  </li>
</ul>

<h4 id="the-benefits-of-using-binder-mechanism">The Benefits of Using Binder Mechanism</h4>

<ul>
  <li>
    <p>Easy to expand or remove functions: It is easy to add a new system service or remove an existing function.</p>
  </li>
  <li>
    <p>Easy to port: Porting to a new processor requires few changes. A toolchain for porting is provided.</p>
  </li>
  <li>
    <p>Easy to test: Tests are limited by the component unit, so it is not necessary to test the entire services, and more strict tests are available.</p>
  </li>
  <li>
    <p>Support for distribution system: Process communication is based on the Binder, so it guarantees transparency in location between components.</p>
  </li>
</ul>

<h4 id="binder-driver">Binder Driver</h4>

<p>A Binder Driver is implemented to use the kernel space. The role of the Binder driver is to convert the memory address that each process has mapped with the memory address of the kernel space for reference.</p>

<h4 id="understanding-binder-mechanism-through-media-service">Understanding Binder Mechanism through Media Service</h4>

<h5 id="servicemanager"><code>ServiceManager</code></h5>

<p>ServiceManager is a system manager which manages all services in Android.</p>

<h5 id="what-is-media-service">What is Media Service</h5>

<ul>
  <li>
    <p>Media Service is a general C++ application, is core of android media.</p>
  </li>
  <li>
    <p>Media Service is a general service Android supplied.</p>
  </li>
  <li>
    <p>Source code location: <em>frameworks/base/media/mediaserver/main_mediaserver.cpp</em></p>
  </li>
  <li>
    <p>Entry point:</p>
  </li>
</ul>

<p>```c++
int main(int argc, char** argv)
{
    // Require a ServiceManager proxy
    sp<processstate> proc(ProcessState::self());
    sp<iservicemanager> sm = defaultServiceManager();
    LOGI("ServiceManager: %p", sm.get());
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();
    CameraService::instantiate();
    AudioPolicyService::instantiate();</iservicemanager></processstate></p>

<pre><code>// Forever process messages sent from Binder.
ProcessState::self()-&gt;startThreadPool();
IPCThreadState::self()-&gt;joinThreadPool(); } ``` * Media server service has four sub-module.
</code></pre>

<ul>
  <li>
    <p><code>AudioFlinger</code></p>
  </li>
  <li>
    <p><code>MediaPlayerService</code></p>
  </li>
  <li>
    <p><code>CameraService</code></p>
  </li>
  <li>
    <p><code>AudioPolicyService</code></p>
  </li>
</ul>

<h5 id="processstate"><code>ProcessState</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/libs/binder/ProcessState.cpp</em></p>
  </li>
  <li>
    <p>Media Service first call <code>ProcessState::self()</code></p>
  </li>
</ul>

<p>```c++
sp<processstate> ProcessState::self()
{
    if (gProcess != NULL) return gProcess;</processstate></p>

<pre><code>AutoMutex _l(gProcessMutex);
if (gProcess == NULL) gProcess = new ProcessState;
return gProcess; } ```
</code></pre>

<ul>
  <li>Then <code>ProcessState::self()</code> call ProcessState constructor</li>
</ul>

<p><code>c++
ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED) // Map the memory start address
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &gt;= 0) {
        // XXX Ideally, there should be a specific define for whether we
        // have mmap (or whether we could possibly have the kernel module
        // availabla).
#if !defined(HAVE_WIN32_IPC)
        // mmap the binder, providing a chunk of virtual address space to receive transactions.
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            LOGE("Using /dev/binder failed: unable to mmap transaction memory.\n");
            close(mDriverFD);
            mDriverFD = -1;
        }
#else
        mDriverFD = -1;
#endif
    }
    if (mDriverFD &lt; 0) {
        // Need to run without the driver, starting our own thread pool.
    }
}
</code></p>

<ul>
  <li>
    <p><code>open_driver()</code> function</p>

    <ul>
      <li>
        <p>Very important function call to open a virtual device for communication.</p>
      </li>
      <li>
        <p>This functon will open this device <strong>/dev/binder</strong>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>When <code>ProcessState::self()</code> complete, it had do two important jobs:</p>

    <ul>
      <li>Open the virtual device <strong>/dev/binder</strong>, so there has been a channel to communicate with kernel.</li>
      <li>Map <strong>/dev/binder</strong> device’s fd to memory.  </li>
    </ul>
  </li>
</ul>

<h5 id="defaultservicemanager"><code>defaultServiceManager()</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/libs/binder/IServiceManager.cpp</em></p>
  </li>
  <li>
    <p>Trace the source code call path, finally find that this call <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> equals <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code>.</p>
  </li>
  <li>
    <p>BpBinder</p>

    <ul>
      <li>
        <p>Source code location: <em>frameworks/base/libs/binder/BpBinder.cpp</em></p>
      </li>
      <li>
        <p>BpBinder constructor:</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    LOGV(“Creating BpBinder %p handle %d\n”, this, mHandle);</p>

<pre><code>extendObjectLifetime(OBJECT_LIFETIME_WEAK);
IPCThreadState::self()-&gt;incWeakHandle(handle); } ```
</code></pre>

<ul>
  <li>
    <p>What did <code>interface_cast</code> do?</p>

    <ul>
      <li>
        <p><code>interface_cast</code> defined in <em>/home/tao/android_source/frameworks/base/include/binder/IInterface.h</em></p>
      </li>
      <li>
        <p><code>interface_cast</code> defination</p>
      </li>
    </ul>
  </li>
</ul>

<p><code>c++
template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}
</code>
   * So <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement call <code>interface_cast</code> will equals:</p>

<p><code>c++
inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return IServiceManager::asInterface(obj);
}
</code></p>

<ul>
  <li>
    <p>We need find clue in <code>IServiceManager</code></p>

    <ul>
      <li>
        <p>Source code location: <em>frameworks/base/include/binder/IInterface.h</em></p>
      </li>
      <li>
        <p><code>IServiceManager</code> defination</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);</p>

<pre><code>/**
 * Retrieve an existing service, blocking for a few seconds
 * if it doesn't yet exist.
 */
virtual sp&lt;IBinder&gt;         getService( const String16&amp; name) const = 0;

/**
 * Retrieve an existing service, non-blocking.
 */
virtual sp&lt;IBinder&gt;         checkService( const String16&amp; name) const = 0;

/**
 * Register a service.
 */
virtual status_t            addService( const String16&amp; name,
                                        const sp&lt;IBinder&gt;&amp; service) = 0;

/**
 * Return list of all existing services.
 */
virtual Vector&lt;String16&gt;    listServices() = 0;

enum {
    GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
    CHECK_SERVICE_TRANSACTION,
    ADD_SERVICE_TRANSACTION,
    LIST_SERVICES_TRANSACTION,
}; }; ```     
* We need trace this macro `DECLARE_META_INTERFACE(ServiceManager)` 
</code></pre>

<p>```c++
#define DECLARE_META_INTERFACE(INTERFACE)                           <br />
    static const String16 descriptor;                               <br />
    static sp&lt;I##INTERFACE&gt; asInterface(const sp<ibinder>&amp; obj);      
    virtual const String16&amp; getInterfaceDescriptor() const;           
    I##INTERFACE();                                                   
    virtual ~I##INTERFACE();                                          </ibinder></p>

<h1 id="define-implementmetainterfaceinterface-name">define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)</h1>
<pre><code>const String16 I##INTERFACE::descriptor(NAME);                    
const String16&amp; I##INTERFACE::getInterfaceDescriptor() const {    
    return I##INTERFACE::descriptor;                              
}                                                                 
sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(const sp&lt;IBinder&gt;&amp; obj)
{                                                                 
    sp&lt;I##INTERFACE&gt; intr;                                        
    if (obj != NULL) {                                            
        intr = static_cast&lt;I##INTERFACE*&gt;(                        
            obj-&gt;queryLocalInterface(                             
                    I##INTERFACE::descriptor).get());             
        if (intr == NULL) {                                       
            intr = new Bp##INTERFACE(obj);                        
        }                                                         
    }                                                             
    return intr;                                                  
}                                                                 
I##INTERFACE::I##INTERFACE() { }                                  
I##INTERFACE::~I##INTERFACE() { }                                  ```
</code></pre>

<ul>
  <li>Finally, we find that <code>interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement actually return a <code>BpServiceManager</code> object. It means <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> acquired a <code>BpServiceManager</code> object.</li>
</ul>

<h5 id="bpservicemanager"><code>BpServiceManager</code></h5>

<ul>
  <li>Bp stands for Binder proxy, it means <code>BpServiceManager</code> is <code>ServiceManager</code>’s proxy to Binder.</li>
</ul>

<h5 id="mediaplayerservice"><code>MediaPlayerService</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/media/libmediaplayerservice/MediaPlayerService.cpp</em></p>
  </li>
  <li>
    <p>Defination and instantiation </p>
  </li>
</ul>

<p>```c++
void MediaPlayerService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16(“media.player”), new MediaPlayerService());
}</p>

<p>MediaPlayerService::MediaPlayerService()
{
    LOGV(“MediaPlayerService created”);
    mNextConnId = 1;
}</p>

<p>MediaPlayerService::~MediaPlayerService()
{
    LOGV(“MediaPlayerService destroyed”);
}
```</p>

<ul>
  <li>
    <p><code>MediaPlayerService</code> derivatived from <code>BnMediaPlayerService</code></p>
  </li>
  <li>
    <p>Bn stands for Binder native.</p>
  </li>
  <li>
    <p>Add <code>MediaPlayerService</code> to <code>ServiceManager</code></p>
  </li>
</ul>

<p><code>c++
virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)
{
    Parcel data, reply;
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
    data.writeString16(name);
    data.writeStrongBinder(service);
    // remote() return BpBinder object
    status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);
    return err == NO_ERROR ? reply.readInt32() : err;
}
</code>
* <code>remote()</code> return BpBinder</p>

<p>```c++
status_t BpBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }</p>

<pre><code>return DEAD_OBJECT; } ```
</code></pre>

<ul>
  <li>
    <p><code>IPCThreadState</code> do with transaction, write add service command and wait for response.</p>
  </li>
  <li>
    <p><code>BpServiceManager</code> had sent a add service message, but who receive and process it?</p>
  </li>
  <li>
    <p><code>BnServiceManager</code>? unfortunately it doesn’t exist. service do same job.</p>
  </li>
  <li>
    <p>service</p>
    <ul>
      <li>
        <p>service is a general c++ applcation.</p>
      </li>
      <li>
        <p>Source code location: <em>frameworks/base/cmds/servicemanager/service_manager.c</em></p>
      </li>
      <li>
        <p>Entry point:</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
int main(int argc, char **argv)
{
    struct binder_state *bs;
    //  BINDER_SERVICE_MANAGER is NULL, is a magic number
    void *svcmgr = BINDER_SERVICE_MANAGER;</p>

<pre><code>bs = binder_open(128*1024);

if (binder_become_context_manager(bs)) {
    LOGE("cannot become context manager (%s)\n", strerror(errno));
    return -1;
}

svcmgr_handle = svcmgr;
binder_loop(bs, svcmgr_handler);
return 0; } ```
</code></pre>

<h4 id="conclusion">Conclusion</h4>

<p>Through tracing so many codes, the MediaPlayerService example maybe reveal the Binder’s mysterious veil. We need write down some important conclusions:</p>

<ul>
  <li>
    <p>If two processes need communicate each other, one as Client, the other is Server, Server need registered to <code>ServiceManager</code>, if Client want request to Server, it need query Server’s info from <code>ServiceManager</code>, based the qureid info, Client and Server can communicate each other. </p>
  </li>
  <li>
    <p>Client, Server, <code>ServiceManager</code> are implemented in use space, Binder is implemented in kernel space.</p>
  </li>
  <li>
    <p><code>ServiceManager</code> and Binder is implemented by Android, developers need implemente their Client and Server.</p>
  </li>
  <li>
    <p>Binder supplied device file <strong>/dev/binder</strong> communicate to user space. Client, Server and <code>ServiceManager</code> communicated to Binder through <code>open</code> and <code>ioctl</code> file operation function.</p>
  </li>
  <li>
    <p>Client and Server communicate each other immediately through Binder.</p>
  </li>
  <li>
    <p><code>ServiceManager</code> is a daemon process, it manages Server, supply interface to qurey Server function.</p>
  </li>
</ul>

<p>If want to learn Android IPC mechanism deeply, a lot of Android source code need be read. Linus said:</p>

<blockquote>
  <p>Read The Fucking Source Code.</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Memory Leak in Android Development</title>
	  <link>//memory-leak-in-android-development</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-01T22:00:00+08:00</pubDate>
	  <guid>//memory-leak-in-android-development</guid>
	  <description><![CDATA[
	     <p>When programming Android, although java has GC mechanism, some our wrong code way and personal habits still cause memory leak, GC also can’t fix it.</p>

<h4 id="senario-1-when-programming-a-single-instance">Senario 1: When programming a single instance</h4>

<ul>
  <li>Error way:</li>
</ul>

<p><code>java
public class Sample{      
    private static Sample sample;
    private Context mContext; 
    private Sample(Context mContext){
         this.mContext = mContext;
    }
    public static Sample getInstance(Context mContext){
         if(sample == null)
              sample = new Sample(mContext);
         return sample;
    }
    public void otherAction(){
         mContext.act();
    }
}
</code></p>

<ul>
  <li>Error reason:</li>
</ul>

<p>If we use <code>Sample.getInstance()</code> in Acitivity A, pass <code>this</code> to Sample’s <code>getInstatnce</code> static method, because Sample is static single instance, it exists untill application exit. But Sample’s member variable still hold reference to Activity A, it causes Activity A can’t be destroied. If we pass applicationContext, it doesn’t cause this problem.</p>

<ul>
  <li>Right way:</li>
</ul>

<p><code>java
public class Sample{
     private static Sample sample;
     private Context mContext;
     private Sample(Context mContext){
          this.mContext = mContext;
     }
     public static Sample getInstance(Context mContext){
          if(sample == null)
               sample = new Sample(mContext.getApplicationContext());
          return sample;
     }
     public void otherAction(){
          mContext.act();
     }
}
</code>
     
#### Senario 2: When use anonymous inner class</p>

<ul>
  <li>Error way:
```java
public class SampleActivity extends Activity{
     private TextView textView;          
     private Handler handler = new Handler(){
          @override
          public void handlerMessage(Message msg){</li>
</ul>

<p>          }
     };</p>

<p>     @override
     public void onCreate(Bundle bundle){
          super.onCreate(bundle);
          setContextView(R.layout.activity_sample_layout);
          textView = (TextView)findViewById(R.id.textView);
          handler.postDelayed(new Runnable(){</p>

<p>               @override
               public void run(){
                    textView.setText(“ok”);
               };</p>

<p>          },1000 * 60 * 10);
     }
}
```</p>

<ul>
  <li>Error reason:</li>
</ul>

<p>When execute the <code>SampleAcitvity</code>’s <code>finish</code> method, the delayed messages will exist in main thread for 10 minutes before be processed, while this message contains reference to Handler, Handler is a anonymous inner class, it hold reference to external SampleAcivity, so cause SampleAcivity can’t be recycled. Above <code>Runnable</code> also is a anonymous inner class, it also prevent SampleActivity to be recycled.</p>

<ul>
  <li>Right way:</li>
</ul>

<p><strong>A static anonymous inner class instance will not hold reference to external class.</strong></p>

<p>```java
public class SampleActivity extends Activity{
     private TextView textView;
     private static class MyHandler extends Handler {</p>

<p>     private final WeakReference<sampleactivity> mActivity;
     public MyHandler(SampleActivity activity) {
          mActivity = new WeakReference<sampleactivity>(activity);
     }</sampleactivity></sampleactivity></p>

<p>     @Override
     public void handleMessage(Message msg) {
          SampleActivity activity = mActivity.get();
               if (activity != null) {</p>

<p>               }
          }
     }</p>

<p>     private final MyHandler handler = new MyHandler(this);</p>

<p>     @override
     public void onCreate(Bundle bundle){
          super.onCreate(bundle);
          setContextView(R.layout.activity_sample_layout);
          textView = (TextView)findViewById(R.id.textView);
          handler.postDelayed(new MyRunnable(textView),1000 * 60 * 10);
     }</p>

<p>     private static class MyRunnable implements Runnable{</p>

<pre><code>    // use WeakReference to hold external class's member variables.         private WeakReference&lt;TextView&gt; textViewWeakReference;         public MyRunnable(TextView textView){              textViewWeakReference = new WeakReference&lt;TextView&gt;(textView);         }
</code></pre>

<p>        @override
        public void run(){
              final TextView textView = textViewWeakReference.get();
              if(textView != null){
                   textView.setText(“OK”);
              }</p>

<p>        };
     }
}
```</p>

<h4 id="senario-3-forgot-call-removecallbacksandmessages-after-use-handler">Senario 3: Forgot call removeCallbacksAndMessages after use handler</h4>

<ul>
  <li>Right way:</li>
</ul>

<p>In onDestroy call this method:</p>

<p><code>java
     handler.removeCallbacksAndMessages(null);
</code></p>

<p>This call passed null will destroy all Runnable and Message related to handler.</p>

<h4 id="conclude">Conclude</h4>

<ul>
  <li>
    <p>Don’t let object whose lifecycle longer then Acivity hold reference to Acivity.</p>
  </li>
  <li>
    <p>Prefer to use Application’s Context rather than Activity’s Context.</p>
  </li>
  <li>
    <p>Prefer to use static anonymous inner class rather than non-static.</p>
  </li>
  <li>
    <p>Use weak reference to hold external class’s member variables.</p>
  </li>
  <li>
    <p>GC can’t fix memory leak.</p>
  </li>
</ul>

<h4 id="reference">Reference</h4>

<blockquote>
  <p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p>
</blockquote>

<blockquote>
  <p>When an Android application first starts, the framework creates a Looper object for the application’s main thread. A Looper implements a simple message queue, processing Message objects in a loop one after another. All major application framework events (such as Activity lifecycle method calls, button clicks, etc.) are contained inside Message objects, which are added to the Looper’s message queue and are processed one-by-one. The main thread’s Looper exists throughout the application’s lifecycle.</p>
</blockquote>

<blockquote>
  <p>When a Handler is instantiated on the main thread, it is associated with the Looper’s message queue. Messages posted to the message queue will hold a reference to the Handler so that the framework can call Handler#handleMessage(Message) when the Looper eventually processes the message.</p>
</blockquote>

<blockquote>
  <p>In Java, non-static inner and anonymous classes hold an implicit reference to their outer class. Static inner classes, on the other hand, do not.</p>
</blockquote>


	  ]]></description>
	</item>


</channel>
</rss>
