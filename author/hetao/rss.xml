<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>读《未来简史》</title>
	  <link>//read-homo-deus</link>
	  <author>Tao He</author>
	  <pubDate>2020-10-25T04:54:12+08:00</pubDate>
	  <guid>//read-homo-deus</guid>
	  <description><![CDATA[
	     <p>读《未来简史》一直都在我的读书计划中，最近终于可以安排上了，本来的计划是先把《人类简史》的英文版先读一遍，再接着读三部曲中的第二部，这样可以像看电影似的接上，因为赫拉利的书观点性很强，《人类简史》的中文版我已经读过一遍，所以不太想再把那些观点再嚼一遍，于是直接在Kindle上开始看《未来简史》，通勤中，飞机上，睡觉前，半个月时间，不知不觉看完了。如同《人类简史》一样，是一本让人手不释卷的好书。看完后，总有一种不吐不快的感觉，因此有了此文。
英文版的封面与中文版不同，醒目的红色大字&quot;Homo Deus&quot;是主标题，而中文版的主标题却是英文版的副标题&quot;A Brief History of Tomorrow&quot;,正好主副标题颠倒，对&quot;Homo Deus&quot;的翻译是&quot;从智人到智神&quot;, 看完全书，感觉还是翻译为&quot;从智人到智神&quot;更为贴切，&quot;未来简史&quot;感觉是病句，当然认为前者更贴切的原因不仅仅是咬文嚼字，而是这个标题才是整本书的主旨——未来会有一个新的脱胎于智人的种族（Homo Deus）诞生，或取代智人的地位，或导致智人灭绝。Homo Deus延续了《人来简史》的风格，或者说延续了赫拉利的写史风格, 宏大的叙事，精炼的语句，几乎是我读过的所有历史类，社会类书籍里面独有的一种，开篇就有惊人之语，至少在我读过的书里面没有遇到类似的论调:</p>

<blockquote>
<p>For thousands of years the answer to this question remained unchanged. The same three problems preoccupied the people of twentieth-century China, of medieval India and of ancient Egypt. Famine, plague and war were always at the top of the list. For generation after generation humans have prayed to every god, angel and saint, and have invented countless tools, institutions and social systems – but they continued to die in their millions from starvation, epidemics and violence. Many thinkers and prophets concluded that famine, plague and war must be an integral part of God’s cosmic plan or of our imperfect nature, and nothing short of the end of time would free us from them.</p>

<p>Yet at the dawn of the third millennium, humanity wakes up to an amazing realisation. Most people rarely think about it, but in the last few decades we have managed to rein in famine, plague and war. Of course, these problems have not been completely solved, but they have been transformed from incomprehensible and uncontrollable forces of nature into manageable challenges.</p>

<p>Forthe first time in history, more people die today from eating too much than from eating too little; more people die from old age than from infectious diseases; and more people commit suicide than are killed by soldiers, terrorists and criminals combined. In the early twenty-first century, the average human is far more likely to die from bingeing at McDonald’s than from drought, Ebola or an al-Qaeda attack.</p>
</blockquote>

<p>翻译提炼下截取的这三个段落:</p>

<p><strong>饥荒，瘟疫和战争一直是世代困扰智人的三大难题，智人在第三个千年第一次战胜了饥荒，瘟疫和战争，或者说基本控制了这三大难题.</strong></p>

<p>的确是新颖的观点，第一次发现可以从这个视角来看人类的历史，开篇的这些惊人之语，只是开胃菜，也是论述智神诞生的铺垫，因为当智人战胜了这三大难题后，智人的使命或者说智人未来的福祉会是什么，追求永生还是获取极乐？这个问题明显是一个无限开放，无限发散的问题，整本书就是沿着这条主线展开的，而从智人脱颖而出的智神的诞生也是探寻这个问题过程中导致的结果之一，书中在探寻这个问题的过程中逐步展开更多的命题，抛出振聋发聩，令人耳目一新的论点，让人震惊，叹息，恐惧，并引起深思。</p>

<p>因为我是差不多半个月的时间陆续读完全书，对书中内容的印象是碎片化的，写下此文时也不是正襟危坐，思绪连贯的行文，而是在手机或电脑上迅速记下一些思绪的片段，着重对一些触动我的部分展开讨论，现遴如下：</p>

<p><strong>人类有灵魂而动物没有灵魂是错的， 灵魂是不存在的</strong></p>

<p>这个论点既不是无神论，也不是唯物主义，而是经过大量的心理学实验的论断，智人从动物中脱颖而出并最终统治这个世界当然不是因为独有的灵魂，而仅仅是因为智人可以想象并编造出这个世界上没有的东西，并因此而为之达成规模无限扩大的合作，这才是智人胜出的关键，之所以这里说到的是智人，而不是人类，是因为一些与智人同源的一些人类分支已经灭绝了，而可怕的事实是灭绝的原因可能与智人直接相关。 乍一看，这个观点仅仅是对上一部《人类简史》中观点的呼应，但书中讨论了很多心理学实验，进一步佐证和加强了这个观点。并且这个观点也将智人拉下了神坛，顺便给人文主义一击。</p>

<p><strong>人文主义(Humanism)不过是另一种宗教而已，数据(Dataism)主义也是</strong></p>

<p>这个不仅对人文主义是沉重一击，也击到了我，人文主义不是人类曙光吗？引领人类摆脱宗教，战胜愚昧。作者有很多理由，多个维度告诉你它仅仅是另一种宗教，这是一个激怒无数人的论调，因为人文主义不单单是一种主义，在当下语境，它是和自由主义，民主，市场化，法律等等的观念产物紧密相连，是目前人类社会的基石。而往往认为它是和宗教完全不同的。看到这个论调的时候我猛然想到汤因比的《历史研究》里曾把社会主义和基督教作类比，但仍旧无法立刻接受把人文主义与基督教作类比。而这个论调更要命的是否定智人的自由意志，而自由意志是所有人类法律，市场，良知，道德的基石。很多抛弃人文主义的人开始倒向数据主义，而数据主义得益于日益飞速发展的计算机互联网技术，凭借惊人的算力，AI的逐步演进，生物技术的突破，俨然成为了另一种宗教。人有丰富的情绪，在人文主义者看来这是人的价值所在，独特之处，而在数据主义者看来不过是一些人体的生化反应而。孰对孰错，孰优孰劣，交给时间吧！</p>

<p><strong>智神会导致智人的消亡，如同智人导致了非智人人类的消亡一样</strong></p>

<p>智神如何导致智人消亡我们没看到过，但是智人导致其他人类的消亡却有考古和历史证据，而智神们是脱胎于现在的人类，也许通过基因技术，数据特权，悄无声息的崛起。所谓的超人诞生，智人消亡，这不禁让人联想到纳粹主义，想到尼采，但都不能与之同日而语，也许这个过程是和平演进，底层的民众如大梦初醒时一切都已经晚了，因为智神已经出现，无论从智力，体力，智神都完全碾压智人，智人比任何一个时代都绝望，“富不过三代，穷不过三代”，这个规律不再适用，智人厄运不止，最终消亡。这种图景也许是很多普通人无法接受的，但是果真如赫拉利所言，智人又能怎样呢？你只能期盼赫拉利错了。</p>

<p>当然整本书绝不仅仅是以上的这些观点，只是以上的这些观点最触动我，也能呼应很多以前看过的书，是一次很好的对思维方式和观念结构的SPA，至于书中的一些观点的对错其实并不重要，启发和击中我才是最重要的，其中所提供的一些视角和思考方法也是独一份，独特到我很快要被它安利了，但是我又要保持警惕，不至于陷入&quot;赫拉利主义&quot;。放眼全球，貌似赫拉利在中国最火，似乎我们又狂热的认为如获至宝，就跟很多年前马克思主义被引进时，而事实上赫拉利如美国很多畅销书作家一样，只是提出了一种新的观点和研究成果，既不是真理，也不是终极预言，却引来很多国内互联网大佬和学者的热烈讨论，实属奇观，如果仅是讨论学术，那真是太好了，说明国内思想学术之活跃，如果因为其他，那也是奇观！</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin synthetic binding view is null in Fragment</title>
	  <link>//kotlin-synthetic-view-binding-view-is-null-in-fragment</link>
	  <author>Tao He</author>
	  <pubDate>2020-09-09T02:20:12+08:00</pubDate>
	  <guid>//kotlin-synthetic-view-binding-view-is-null-in-fragment</guid>
	  <description><![CDATA[
	     <p>Kotlin provide a handy and concise way to access views in xml layout from code, it works well, but When I create a subclass of <code>DialogFragment</code>, in its method <code>onCreateView</code>, I access synthetic binding view, it seems all is fine, but when run these code, app crash. In logcat, I got this <code>NullPointerException</code>:</p>

<blockquote>
<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &#39;android.view.View android.view.View.findViewById(int)&#39; on a null object reference</p>
</blockquote>

<p>I&#39;m sure synthetic statement is imported and view id is right, it confused me a bit. So I Google Kotlin synthetic binding view related web pages, finally I found a solution:</p>

<p>Just move accessing syntheic binding view statement from <code>onCreateView</code> to <code>onViewCreated</code>.</p>

<p>The problem is that I am accessing it too soon, When I delay the chance to access view, all works well. Magic! But it’s nothing magical, if you decompile the bytecode (By going toTools -&gt; Kotlin -&gt; Show Kotlin Bytecode and then selecting Decompile in the pane) and take a look at the generated java class, you’ll see that all it does is call findViewById() for us. Although this is a simple problem, but it is useful to record it.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin中的"静态" 方法和域</title>
	  <link>//static-method-in-kotlin</link>
	  <author>Tao He</author>
	  <pubDate>2020-09-03T04:54:12+08:00</pubDate>
	  <guid>//static-method-in-kotlin</guid>
	  <description><![CDATA[
	     <p>最近开始尝试在现有的工程中使用Kotlin，刚开始使用时感觉语法简洁，代码量也少了很多，语法层面的防空，可以直接访问布局控件这些特性，都让人耳目一新，但是当我要定义静态方法和静态类时，不爽的体验一下子就上来了，所以通过此文来一探Kotlin&quot;静态&quot; 的究竟。
  先来看静态方法， 很遗憾，Kotlin中没有<code>static</code>关键字，需要将静态方法放在<code>companion object</code>中的代码块中，因此：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  public static int a() { return 1; }
}
</code></pre></div>
<p>就变成了这样:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
     fun a() : Int = 1
  }
}
</code></pre></div>
<p>可以在Kotlin代码中这样使用该类:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.a();
</code></pre></div>
<p>在Java代码中:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.Companion.a();
</code></pre></div>
<p>如果你不喜欢使用<code>Companion</code>, 你可以对该静态方法添加<code>@JvmStatic</code>注解:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
    @JvmStatic
    fun a() : Int = 1;
  }
}
</code></pre></div>
<p>也可以命名你的<code>companion</code>类:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object Blah {
    fun a() : Int = 1;
  }
}
</code></pre></div>
<p>然后可以这样调用:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.Blah.a() 
</code></pre></div>
<p>然后来看静态域， 比起静态方法，静态域的情况有所不同，虽然也可以这样定义:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
    val MY_CONSTANT = &quot;MY_CONSTANT&quot;
  }
}
</code></pre></div>
<p>但是会自动为<code>MY_CONSTANT</code>生成getter和setter方法，相当于实例域访问，开销会比静态方法大，不推荐此种定义方法。可以这样定义:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">object Foo {
    const val MY_CONSTANT = &quot;MY_CONSTANT&quot;
}
</code></pre></div>
<p>上面定义的object Foo可以全局访问:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.MY_CONSTANT
</code></pre></div>
<p>而companion object中定义的<code>const var MY_CONSTANT</code>是不可以全局访问的。 当然了，静态域为了避免访问时的Companion，也可以在定义时添加<code>@StaticField</code>.</p>

<p>到此Kotlin中<code>静态</code>相关的部分基本已经覆盖到了，个人觉得这个companion object不是什么好的设计，远没有Java的static关键字来的简洁和表达力。</p>

	  ]]></description>
	</item>

	<item>
	  <title>基于DrawerLayout实现直播抽屉</title>
	  <link>//implement-live-drawer</link>
	  <author>Tao He</author>
	  <pubDate>2020-07-29T04:54:12+08:00</pubDate>
	  <guid>//implement-live-drawer</guid>
	  <description><![CDATA[
	     <p>直播间里右侧的滑出抽屉现在几乎成了主流直播的标配，无论是映客还是Bigo，都很早就上线了抽屉。我所在的这个产品最近也要上同样的功能，因此需要简单实现一个。
  要实现一个简单的侧滑抽屉，最先想到的就是直接使用<code>DrawerLayout</code>，但是无法满足产品的一个手势要求: 在屏幕任何位置都可以调出和收起抽屉。<code>DrawerLayout</code> 的默认行为是只能从屏幕边缘调出。因此需要改变DrawerLayout的默认行为，使期能够从屏幕任何位置调出，这就需要通过反射修改drawerlayout的edgesize属性，因为drawerlayout还可以通过长按调出，我们的产品需求并不需要这个行为，因此也需要屏蔽掉，通过一个静态方法来统一实现：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static void setDrawerLeftEdgeSize(DrawerLayout drawerLayout,
                                             float percent) {
    if (drawerLayout == null)
        return;
    try {
        //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小
        Field rightDraggerField = drawerLayout.getClass().getSuperclass().getDeclaredField(&quot;mRightDragger&quot;);
        rightDraggerField.setAccessible(true);
        ViewDragHelper rightDragger = (ViewDragHelper) rightDraggerField.get(drawerLayout);

        Field edgeSizeField = rightDragger.getClass().getDeclaredField(&quot;mEdgeSize&quot;);
        edgeSizeField.setAccessible(true);
        int edgeSize = edgeSizeField.getInt(rightDragger);

        edgeSizeField.setInt(rightDragger, Math.max(edgeSize, (int)(UIUtils.getScreenWidth() * percent)));

        //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”
        //更改其属性 mPeekRunnable
        Field rightCallbackField = drawerLayout.getClass().getSuperclass().getDeclaredField(&quot;mRightCallback&quot;);
        rightCallbackField.setAccessible(true);

        //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例
        ViewDragHelper.Callback leftCallback = (ViewDragHelper.Callback) rightCallbackField.get(drawerLayout);

        Field peekRunnableField = leftCallback.getClass().getDeclaredField(&quot;mPeekRunnable&quot;);
        peekRunnableField.setAccessible(true);
        Runnable nullRunnable = new Runnable() {
            @Override
            public void run() {

            }
        };
        peekRunnableField.set(leftCallback, nullRunnable);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre></div>
<p>解决了edgsize和长按的问题后，马上又面临一个净屏页和抽屉的手势滑动冲突问题，并且还要注意两个UI元素的层级，基本的解决思路是根据滑动的方向和净屏页的状态在<code>DrawerLayout</code>子类的onInterceptTouchEvent里来处理事件拦截，改变<code>DrawerLayout</code>的默认行为，净屏页的逻辑不变，只向<code>DrawerLayout</code>提供状态的get方法，具体实现如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public boolean onInterceptTouchEvent(MotionEvent ev){
    Log.d(&quot;drawerLayout&quot;, &quot;onInterceptTouchEvent, action: &quot;
            + ev.getAction() + &quot; x= &quot; + ev.getX() + &quot; y=&quot; + ev.getY());

    boolean drawerOpen = this.isDrawerOpen(Gravity.RIGHT);
    boolean pureMode = contentView.isPureMode();

    switch(ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mLastX = ev.getX();
            mLastY = ev.getY();

            /*
            final View touchedView = findTopChildUnder((int) mLastX, (int) mLastY);
            boolean isContent = isContentView(touchedView);


            if (!drawerOpen &amp;&amp; isContent) {
                return false;
            }
              */

            break;
        case MotionEvent.ACTION_MOVE:
            float dx = ev.getX() - mLastX;
            float dy = ev.getY() - mLastY;

            boolean horizontal = Math.abs(dx) &gt; Math.abs(dy);

            if (!pureMode &amp;&amp; dx &lt; 0 &amp;&amp; horizontal) {

            } else if(!pureMode &amp;&amp; dx &gt; 0 &amp;&amp; drawerOpen &amp;&amp; horizontal){

            } else {
                return false;
            }

            break;
        default:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre></div>
<p>这样用最小的开发成本完成了产品的需求，实现了主流直播产品的抽屉功能。唯一的小瑕疵是直播间上下滑动时不能自动收起抽屉，这个因为并不是产品很在意的点，再加上产品需求紧急，就没有深究。当然了，这个抽屉功能其实可以抽取出来做成一个通用的抽屉，提供不同的接口来满足定制要求。</p>

<p>tips：<code>DrawerLayout</code>显示区域穿透的问题可以这样解决：
将显示区域的clickable属性设置为true。</p>

	  ]]></description>
	</item>

	<item>
	  <title>为什么学习设计模式</title>
	  <link>//why-learn-design-pattern</link>
	  <author>Tao He</author>
	  <pubDate>2020-05-08T04:54:12+08:00</pubDate>
	  <guid>//why-learn-design-pattern</guid>
	  <description><![CDATA[
	     <p>设计模式，可能是每一个程序员都绕不过去的话题，有人认为特别重要，有人对其嗤之以鼻，也有人并不是很确定它的重要性。为什么要学习设计模式，这么多年以来其实我也没有看到一个很好的回答，前一阵在Youtube看到一个讲Android系统开发的youtuber的主页，发现他的一篇很短的文章探讨了这个问题，看完后感觉醍醐灌顶，因此有冲动翻译并记录下其主要的观点。</p>

<p>编程如下棋，一个新手刚开始接触时，首先要了解能够正常下棋的要素，如棋子，棋盘，要熟悉棋子移动，吃子，将军的规则，等这些都了解了以后，就可以正常下棋了，虽然可能下的不好，但是渐渐的，开始领会一些这个游戏的基本规律，如何占取优势，如何使用策略，通过一次次的棋局，逐步的识别出一些可能是很愚蠢的错误，并在以后的棋局中尽量避免，一个新手也可能下棋下的越来越好。</p>

<p>但是一个人如果想成为下棋的大师，却需要学习大师们所下过的棋局。隐藏在这些棋局中的模式必须通过理解，记忆，反复应用，最后成为一个人的本能。这些模式可能是成千上万的，开放模式更是繁多，以至于有很多关于其变化的书籍。 游戏中模式和结束模式也很普遍，作为大师们必须熟悉它们。</p>

<p>编程也一样，首先学习规则，学习算法，数据结构，熟悉了这些后就可以编程了，尽管所写的代码会比较蹩脚。之后，开始学习软件设计的原则，如结构化编程，模块化编程，面向对象编程，如高内聚低耦合的重要性，如信息隐藏和依赖管理。等这些都学习了以后，一个人要想成为真正的编程大师，还是需要学习大师们的设计，并深入这些设计，举一反三，这些模式必须被理解，记忆，反复应用，最后成为一个人的本能。</p>

<p>这篇文章本来就很短，但是我依旧要提炼出本文要划重点的句子:</p>

<blockquote>
<p>一个人要想成为真正的编程大师，还是需要学习大师们的设计，并深入这些设计，举一反三，这些模式必须被理解，记忆，反复应用，最后成为一个人的本能。</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>解决TextView中emoji被截断的问题</title>
	  <link>//fix-textview-emoji-problem</link>
	  <author>Tao He</author>
	  <pubDate>2020-04-22T04:54:12+08:00</pubDate>
	  <guid>//fix-textview-emoji-problem</guid>
	  <description><![CDATA[
	     <p>理论上TextView中包含emoji显示是没有问题的，问题出在如果TextView限制了宽度，且末尾包含了emoji字符，但是又不够显示，则会出现乱码的情况，原因是单个emoji由两个字符组成，TextView在截断字符时按单个字符截断，所以就有emoji的两个字符被截断后显示的情况，TexView自然无法正常显示。网上有很多解决办法，思路都是通过改变TextView的行为来规避这个问题，但都不理想，在一些特殊情况下仍然有问题。后来我改变了思路，不对TextView做任何更改，而是通过保证emoji本身不被截断来解决问题。</p>

<p>考虑这样一个场景，直播间顶部主播区域的主播昵称，肯定是有字数限制的，如果昵称中包含emoji，如何保证emoji不被截断，并且不丧失在昵称过长后需要...的功能?</p>

<p>代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void setAnchorName(String nick) {
    if (TextUtils.isEmpty(nick)) {
        labelUserName.setText(&quot;&quot;);
        return;
    }
    int len = TextCharUtils.getCurLength(nick);
    if (len &lt;= 8) {
        labelUserName.setText(nick);
        return;
    }
    String newNick = TextCharUtils.substring(nick, 6) + &quot;...&quot;;
    labelUserName.setText(newNick);
}
</code></pre></div>
<p>思路很好理解，就是预先算出String的长度，来决定要不要做处理。 准确计算字符长度的工具类如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class TextCharUtils {
    /**
     * 获取字符串中个数（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @return
     */
    public static int getCurLength(String source) {
        if (TextUtils.isEmpty(source)) {
            return 0;
        }
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (&quot;&quot;.equals(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            temp = index;
        }
        return size;
    }

    /**
     * 截取字符串（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @param end
     * @return
     */
    public static String substring(String source, int end) {
        if (TextUtils.isEmpty(source)) {
            return source;
        }
        StringBuffer sb = new StringBuffer();
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (TextUtils.isEmpty(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            if (size &gt; end) {
                break;
            }
            sb.append(sub);
            temp = index;
        }
        return sb.toString();
    }

    public static int getCharSize(char word) {
        return (isChineseChar(word) || isEmojiCharacter(word)) ? 2 : 1;
    }

    /**
     * 计算中文字符与表情字符
     */
    public static Pair&lt;Integer, Integer&gt; getSpecialCharNum(CharSequence sequence) {
        if (TextUtils.isEmpty(sequence)) {
            return new Pair&lt;&gt;(0, 0);
        }
        int chineseNum = 0, emojiNum = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {//中文
                chineseNum++;
            }

            if (isEmojiCharacter(word)) {
                emojiNum++;
            }
        }
        return new Pair&lt;&gt;(chineseNum, emojiNum / 2);
    }

    public static CharSequence getSubString(CharSequence sequence, int maxChar) {
        if (TextUtils.isEmpty(sequence)) {
            return sequence;
        }

        int size = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {
                size += 2;
            } else {
                size++;
            }

            if (size &gt;= maxChar) {
                return sequence.subSequence(0, i + 1);
            }
        }

        return sequence;
    }

    /**
     * 判断是否是中文
     */
    public static boolean isChineseChar(char c) {
        Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);
        return ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B
                || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS
                || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION;
    }

    public static boolean isEmojiCharacter(char codePoint) {
        return !(codePoint == 0x0 || codePoint == 0x9 || codePoint == 0xA ||
                codePoint == 0xD || codePoint &gt;= 0x20 &amp;&amp; codePoint &lt;= 0xD7FF);
    }
}
</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>最简LeakCanary原理解析</title>
	  <link>//most-simple-leakcanary-principle</link>
	  <author>Tao He</author>
	  <pubDate>2019-11-11T04:54:12+08:00</pubDate>
	  <guid>//most-simple-leakcanary-principle</guid>
	  <description><![CDATA[
	     <p>LeakCanary现在几乎成了Android开发过程中的一个标配，使用起来非常简单，能够帮助开发者发现和规避大部分的内存泄露问题。虽然大部分的开发者都或多或少，或深或浅的接触过LeakCanary，说起来是比较熟悉的一个第三方框架了，但是谈到LeakCanary的原理可能就会陌生很多。虽然网上也有非常多的讲解LeakCanary的文章，但是很多博文要么陷入无止境的代码细节中，要么就泛泛而谈，都不能很清楚的将LeakCanary的原理讲清楚。这篇文章尽力规避前两种文章的问题，用最小的篇幅把LeakCanary的原理讲清楚。</p>

<h4>LeakCanary到底是怎么工作的?</h4>

<p>LeakCanary能够准确，及时地检测到内存泄露，有以下几个关键点</p>

<ul>
<li>检测保留的实例</li>
</ul>

<p>LeakCanary能够工作的基石是一个叫做ObjectWatcher的库，它hook了Android中Activity和Fragment的生命周期，能够自动检测到Activity和Fragment的销毁和将要被GC，这些被检测到的Activity和Fragment的实例被传给了<code>ObjectWatcher</code>，<code>ObjectWatcher</code>以WeakReference持有他们。如果这些WeakReference在5秒后或者一次GC周期以后还没有被清理，那么LeakCanary认为这些实例被保留了，没有被回收，泄露发生了。检测没有被回收的实例是LeakCanary能够工作起来的基石，也是后续处理的基础，这一点非常重要。</p>

<ul>
<li>Dump 堆</li>
</ul>

<p>这一步需要对检测到的泄露进行处理，当然也不是检测到一个实例就会触发dump，而是有一个阈值，当达到一定数量实例的泄露后就会触发LeakCanary将Java堆内存dump到<code>.hprof</code>文件中去，当然了，这个文件存储在Android文件系统中。这个触发dump的阈值是如何确定的呢？如果App还可见，那这个阈值默认是5，如果App不可见，阈值默认是1。</p>

<ul>
<li>分析Java 堆</li>
</ul>

<p>LeakCanary使用<code>Shark</code>来分析<code>.hprof</code>文件，找出阻止实例被回收的引用链:leak trace.其实leak trace的另一个名字是GC Root到被引用实例的最短强引用路径。一旦leak trace确定了，LeakCanary会根据内置的对Android的知识库来推断出leak trace上哪个实例泄露了。</p>

<ul>
<li>Leak分组</li>
</ul>

<p>LeakCanary使用泄露的状态信息，将引用链缩小为可能引起泄露的子引用链，并且在界面上显示出来，也就是我们在LeakCanary界面上看到的信息。有的泄露可能不相关，但是引用链相同，也会被认为是同一个引用链，所以泄露会根据相同的子引用链分组。</p>

<p>以上就是LeakCanary基本原理的关键点，相信也是最简单的对LeakCanary原理的描述了吧!</p>

	  ]]></description>
	</item>

	<item>
	  <title>ImageSpan的定制使用</title>
	  <link>//custom-image-span</link>
	  <author>Tao He</author>
	  <pubDate>2019-10-19T04:54:12+08:00</pubDate>
	  <guid>//custom-image-span</guid>
	  <description><![CDATA[
	     <p>最近在做一个具体业务需求时，为了实现UI设计的要求，需要实现在同一段文字中，有一段文字是需要有形状的背景色，有一段文字中还有网络图片的插入，如果要达到这两个要求，简单的使用SpannableStringBuilder肯定是达不到要求的，虽然SpannableStringBuilder可以设置背景色，但是并不能绘制形状，说白了就是只能设置颜色，不能设置文字的背景图片。想要在文字中插入图片，可以直接使用ImageSpan，但是ImageSpan并不能加载网络图片。因此这种简单的使用方式都是行不通的，需要考虑去定制ImageSpan实现我们特殊的要求。</p>

<ul>
<li>实现给同一段文字的一部分文字区域设置背景图片</li>
</ul>

<p>这个功能的实现还是要继承ImageSpan，将我们的背景图片传进去，并且override ImageSpan的draw方法，根据对文字区域的测量，分别绘制出背景和文字。实现代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// BgImageSpan

public class BgImageSpan extends ImageSpan {

    private int textSize = 20;
    private int color = Color.GRAY;
    private TextView mTextView;
    static float textboundhight;
    static float textY;
    String mText;

    public BgImageSpan(Drawable d, TextView tv, String text) {
        super(d);
        mTextView = tv;
        mText = text;
        textSize = (int) mTextView.getTextSize();
    }


    @Override
    public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y,
                     int bottom, Paint paint) {

        String str = mText;
        Rect bounds = new Rect();
        paint.setTextSize(textSize);
        paint.getTextBounds(str, 0, str.length(), bounds);
        int textHeight = bounds.height();
        int textWidth = bounds.width();

        getDrawable().setBounds(0, top, (int)(bounds.width() * 1.3) , bottom);
        super.draw(canvas, str, start, end, x, top, y, bottom, paint);
        paint.setColor(mTextView.getTextColors().getDefaultColor());
        paint.setTypeface(Typeface.create(&quot;normal&quot;, Typeface.NORMAL));

        Rect bounds1 = getDrawable().getBounds();

        float textX = x + bounds1.width() / 2 - bounds.width() / 2;
        if (textboundhight == 0) {
            textboundhight = bounds.height();
            textY = (bounds1.height()) / 2 + textboundhight / 2;
        }
        canvas.drawText(str, textX, textY, paint);
    }
}
</code></pre></div>
<p>使用方法和ImageSpan并没有什么区别:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">String username = &quot;用户名：&quot;;
String message = &quot;哈哈，我是一个天才&quot;;

SpannableStringBuilder ssb = new SpannableStringBuilder(username);
ssb.append(message);

Rect bounds = new Rect();
Paint paint = mContent.getPaint();
paint.getTextBounds(username, 0, username.length(), bounds);

Drawable bgDrawable = getDrawable(R.drawable.round_rect);
bgDrawable.setBounds(0, 0, (int)(bounds.width() * 1.3), bounds.height());

ImageSpan nameBgSpan = new BgImageSpan(bgDrawable, mContent, username);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

ForegroundColorSpan contentColorSpan = new ForegroundColorSpan(Color.parseColor(&quot;#ffc800&quot;));
ssb.setSpan(contentColorSpan, username.length(), username.length() + message.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

mContent.setText(ssb);
mContent.postInvalidate();
</code></pre></div>
<p>使用代码需要注意一下几点:</p>

<ol>
<li>传给BgImageSpan的Drawable需要设置Bounds，然后再传进去，否则可能会出现字符重叠的问题。</li>
<li>如果设置了Bounds还有字符重叠错乱的问题，可以调用TextView的postInvalidate重绘。</li>
</ol>

<ul>
<li>第二种实现同一段文字的一部分文字区域设置背景图片</li>
</ul>

<p>这种实现的思路很简单，就是通过inflate一个单独的布局，然后用这个inflate好的view生成图片，然后传给一个ImageSpan，即可完成，代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">View view = LayoutInflater.from(this).inflate(R.layout.container, null);
TextView textView = view.findViewById(R.id.tv_value);
textView.setText(username);

view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),
        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
view.buildDrawingCache();
Bitmap bitmap = view.getDrawingCache();

ImageSpan nameBgSpan = new ImageSpan(this, bitmap);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
</code></pre></div>
<ul>
<li>实现一段文字中插入网络图片</li>
</ul>

<p>插入网络图片和插入本地图片其实没有本质区别，要插入网络图片，就得先获取到网络图片后再设置到ImageSpan中去。代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">String url = &quot;http://img2.imgtn.bdimg.com/it/u=1467875646,1039972052&amp;fm=26&amp;gp=0.jpg&quot;;
RequestOptions options = new RequestOptions()
        .dontAnimate()
        .diskCacheStrategy(DiskCacheStrategy.NONE);

Glide.with(this)
        .load(url)
        .apply(options)
        .into(new CustomTarget&lt;Drawable&gt;() {
            @Override
            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) {
                if (resource instanceof BitmapDrawable) {
                    resource.setBounds(0, 0, 50, 50);

                    ImageSpan iconSpan = new ImageSpan(resource);
                    ssb.setSpan(iconSpan, username.length(), username.length() + 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

                    mContent.setText(ssb);
                    mContent.postInvalidate();
                }
            }

            @Override
            public void onLoadCleared(@Nullable Drawable placeholder) {

            }
        });
</code></pre></div>
<p>使用起来需要注意的问题和上面的BgImageSpan相同，也是先要设置Drawable的Bounds。</p>

<p>虽然这两个实现看起来也没有什么难度，但是还是需要把这种解决过的，不那么常规的方法记录下来，以后遇到同样的问题可节省很多调研和调试的事件。</p>

	  ]]></description>
	</item>

	<item>
	  <title>修复VideoView引起的内存泄露小计</title>
	  <link>//fix-video-view-leak</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-21T02:30:12+08:00</pubDate>
	  <guid>//fix-video-view-leak</guid>
	  <description><![CDATA[
	     <p>最近写了非常简单的新手引导视频页面，逻辑很简单，就是新手用户在第一次使用App时可以点击引导视频入口，然后进入一个视频播放页面，为了快速实现功能，就直接使用了VideoView，从需求开发到交付也都没什么问题，需求上线后我打开LeakCanary，想观察下最近有没有新增的内存泄露，竟然发现这个视频页面竟然泄露了。排查了一圈也没有发现有什么会阻止Activity销毁。但是LeakCanary打出了引用链，发现和VideoView有关，通过Google发现，竟然是VideoView自身的bug！这种情况也不是第一次遇见，那也得解决啊，所以开始想办法。</p>

<p>首先显明确是谁导致了Activity的销毁，通过查看VideoView的源码，发现罪魁祸首是AudioManager，它可能会长期持有Context(即泄露的Activity)。很明显是因为生命周期不一致导致的泄露，因此最先想到的就是在创建VideoView时不要传Activity的Context，传给它ApplicationContext。当然了，在布局中创建的VideoView传入的就是Activity的Context，所以需要用代码动态创建:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mVideoView = new VideoView(getApplicationContext());
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);

layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
mContainer.addView(mVideoView, layoutParams);
</code></pre></div>
<p>这样修改后还是会有内存泄露，只是引用链变了，需要在Activity的onDestroy回调中做一些处理</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
protected void onDestroy() {
  super.onDestroy();

  if (mVideoView != null) {
      mVideoView.stopPlayback();
      mVideoView.setOnCompletionListener(null);
      mVideoView.setOnPreparedListener(null);
      mVideoView.setOnErrorListener(null);
      mVideoView = null;
  }

  if (mContainer != null) {
      mContainer.removeAllViews();
  }
</code></pre></div>
<p>以上解决办法需要注意三点：</p>

<ul>
<li>给VideoView设置的Listener都要分别置空，否则仍然会泄露</li>
<li>VideoView的父容器要删掉VideoView，光置空VideoView不够</li>
<li>需设置VideoView的OnErrorListener且返回true，防止弹出弹窗使用ApplicationContext导致崩溃 </li>
</ul>

<p>传递ApplicationContext还有人提出另一种方法，但是我test发现没有效果，这种方法我也贴出来:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// Override Activity的attachBaseContext的行为
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new ContextWrapper(newBase){
        @Override
        public Object getSystemService(String name) {
            if(Context.AUDIO_SERVICE.equals(name)){
                return getApplicationContext().getSystemService(name);
            }
            return super.getSystemService(name);
        }
    });
}
</code></pre></div>
<p>去规避系统API的bug真是很烦人的一件事，既不优雅，也不安全！</p>

	  ]]></description>
	</item>

	<item>
	  <title>Parcelable vs Serializable</title>
	  <link>//serializable-vs-parcelable</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-19T02:30:12+08:00</pubDate>
	  <guid>//serializable-vs-parcelable</guid>
	  <description><![CDATA[
	     <p>在实际的Android开发中Serializable和Parcelable我们都会用到，只是需要区分使用场景。刚开始遇到这两个接口的时候比较疑惑，貌似都是用来做序列化的，虽然能分得清什么时候用哪个，但是对这两个接口并没有清晰的认识，要是冷不丁的问我这俩有什么区别，可能还无法清晰的界定和阐述。因此有必要用一篇文章来彻底捋清这些东西。</p>

<h3>相同点</h3>

<p>相同点其实很明显，主要有如下两点:</p>

<ul>
<li><p>都可以序列化反序列化</p></li>
<li><p>都可以通过Intent传递</p></li>
</ul>

<h3>区别</h3>

<ul>
<li><p>Serializable是Java API，Parcelable是Android SDK API，设计目的不同。Serializable是一个通用的序列化机制，通过将文件保存到本地文件、网络流等实现便数据的传递，这种数据传递不仅可以在单个程序中进行，也可以在两个不同的程序中进行；Parcelable是Android SDK API,为了在同个程序的不同组件之间和不同程序（AIDL）之间高效的传输数据，是通过IBinder通信的消息的载体。从设计目的上可以看出Parcelable就是为了Android高效传输数据而生的。</p></li>
<li><p>Serializable序列化过程使用反射机制，速度慢，且产生很多临时对象，容易触发GC；Parcelable是直接在内存中读写的，自已实现封送和解封（marshalled &amp;unmarshalled）操作，将一个完整的对象分解成Intent所支持的数据类型，不需要使用反射，所以Parcelable具有效率高，内存开销小的优点。</p></li>
<li><p>Serializable是通用的序列化机制，将数据存储在磁盘，可以做到有限持久化保存，文件的生命周期不受程序影响，Parcelable的序列化操作完全由底层实现，不同版本的Android是实现方式可能不相同，所以不能进行持久化存储。</p></li>
<li><p>使用场景不同。Parcelable 是 Android 中的序列化方式，因此更适合于 Android 平台上，它的缺点是使用起来稍微麻烦点，但它的效率很高，这是 Android 推荐的序列化方式，因此我们要首选 Parcelable。但 Serializable 也不是在 Android 上无用武之地，下面两种情况就发日常适合 Serializable：</p>

<ol>
<li>需要将对象序列化到设备；</li>
<li>对象序列化后需要网络传输。</li>
</ol></li>
</ul>

<p>这样一一列举了两者的相同点和区别，对两者的认识清晰了很多！积跬步，共勉！</p>

	  ]]></description>
	</item>


</channel>
</rss>
