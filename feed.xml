<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>与机器，人，神共舞</title>
    <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
    <link>http://longlinht.github.io/</link>
    <atom:link href="http://longlinht.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>修复崩溃ANR小记</title>
        <description>&lt;p&gt;最近一直在集中精力解决Bugly的崩溃，到现在基本上把可以解决的已经都解决完了，剩下的都是一些特定系统版本和特定机型的崩溃，暂时没有太好的思路去排查，其中系统4.4版本的崩溃尤为特殊，有几个崩溃几乎都只出现在4.4版本的机器上，这些特定版本和特定机型的问题暂不谈论，下面来小结一下最近成功解决过的一些崩溃和ANR。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;复写父类方法要当心，注意父类的方法约定(崩溃)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)
java.lang.NullPointerException
Attempt to invoke virtual method &amp;#39;android.graphics.Rect android.graphics.drawable.Drawable.getBounds()&amp;#39; on a null object reference
1 android.text.style.DynamicDrawableSpan.getSize(DynamicDrawableSpan.java:78)
2 android.text.TextLine.handleReplacement(TextLine.java:813)
3 android.text.TextLine.handleRun(TextLine.java:908)
4 android.text.TextLine.measureRun(TextLine.java:387)
5 android.text.TextLine.measure(TextLine.java:277)

...

暂略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;堆栈太长，底下的暂略，这个崩溃乍一看，没啥线索，崩到了系统类DynamicDrawableSpan，然后就看工程中有没有用到DynamicDrawableSpan，果然发现我们的类EmojiTextSpan继承了这个类，那可以缩小问题范围了，从崩溃处逆推调用栈，可以发现我们的类复写了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private Drawable getCachedDrawable() {
    if (mDrawableRef == null || mDrawableRef.get() == null) {
        mDrawableRef = new WeakReference&amp;lt;Drawable&amp;gt;(getDrawable());
    }
    return mDrawableRef.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而DynamicDrawableSpan的方法实现如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private Drawable getCachedDrawable() {
    WeakReference&amp;lt;Drawable&amp;gt; wr = mDrawableRef;
    Drawable d = null;

    if (wr != null) {
        d = wr.get();
    }

    if (d == null) {
        d = getDrawable();
        mDrawableRef = new WeakReference&amp;lt;Drawable&amp;gt;(d);
    }

    return d;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显我们的类做了一个蠢事，其实不用去复写父类的方法，反而不会有问题，这个问题的根本原因是我们没有详细了解这个类，至少是没有了解这个方法的约定。只要删除我们的复写方法即可解决问题。当然，系统代码也不严谨，drawable在调用getBounds方法时没有判空。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主线程切不可进行IO操作(ANR)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class GameBgmService extends Service {

    ...
    ...

    @Override
    public void onCreate() {
        super.onCreate();
        ...
        ...

        PathUtil.findAllKV(BGM_PATH, mBgmMap);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据ANR的堆栈，可以追踪到是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;PathUtil.findAllKV(BGM_PATH, mBgmMap);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的调用导致了ANR，而这个方法是一个典型的IO操作，而这种操作不应该在系统组件的生命周期方法里调用。解决方法也很简单，就是将这种操作放到子线程去。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有时需要频繁IO操作，可考虑建立内存缓存，避免ANR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个ANR和上面的类似，也是要进行一个IO操作，并且和上面不一样的是，这个操作需要同步进行，不能异步，因此我们采取建立内存缓存的方式来解决。这个IO操作其实是通过解析文件中的json，创建出一个对象列表返回，而这个操作在App进入首页的时候就在子线程中操作过一次，但是并没有在这个时机去建立内存缓存，因此这个问题的最简单解决方式就是建立内存缓存，在之前需要IO操作的地方直接操作内存，并且保证文件和内存的内容一致即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用RxJava需要注意Backpressure(崩溃)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)

io.reactivex.exceptions.MissingBackpressureException

Can&amp;#39;t deliver value 9440 due to lack of requests

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | io.reactivex.exceptions.MissingBackpressureException: Can&amp;#39;t deliver value 9440 due to lack of requests
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 io.reactivex.exceptions.MissingBackpressureException:Can&amp;#39;t deliver value 9440 due to lack of requests
6 io.reactivex.internal.operators.flowable.FlowableIntervalRange$IntervalRangeSubscriber.run(FlowableIntervalRange.java:117)
7 io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:38)
8 java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:458)
9 java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307)
10 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302)
11 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
12 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
13 java.lang.Thread.run(Thread.java:784)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个崩溃根据堆栈可追溯到RxJava中的intervalRange操作符，工程中有多处使用，找到一个典型使用:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private void startCountDown(String order, String text, long time) {
    if (time &amp;gt; 0) {
        if (mDisposable != null &amp;amp;&amp;amp; !mDisposable.isDisposed()) {
            mDisposable.dispose();
            mDisposable = null;
        }
        mDisposable = Flowable.intervalRange(0, time + 1, 0, 1, TimeUnit.SECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&amp;lt;Long&amp;gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        if (mKillerAreaTop != null) {
                            if (aLong == time) {
                                mKillerAreaTop.setText(String.format(&amp;quot;【%s号】%s&amp;quot;, order, text));
                            } else {
                                mKillerAreaTop.setText(String.format(Locale.CHINA,
                                        &amp;quot;【%s号】%s(%d)&amp;quot;, order, text, time - aLong));
                            }
                        }
                    }
                });

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个问题RxJava在GitHub上的issue已解决，添加流量控制，在调用intervalRange后紧接着调用onBackpressDrop即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RxJava和ButterKnife混用时先clear disposable后unbind&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)

java.lang.NullPointerException

Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:java.lang.NullPointerException: Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 java.lang.NullPointerException:Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference
6 io.liuliu.music.hall.hall.widget.UserInfoView$1.onStartDownload(UserInfoView.java:159)
7 io.liuliu.music.resource.GoodsResProvider.lambda$startEffect$3(GoodsResProvider.java:121)
8 io.liuliu.music.resource.-$$Lambda$GoodsResProvider$o_C6H-o_OQTCEa45A-3wRHNQygg.accept(Unknown Source:10)
9 io.reactivex.internal.observers.ConsumerSingleObserver.onSuccess(ConsumerSingleObserver.java:62)

......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看似一个很普通的一个崩溃，对这个View对象使用前判空就完事了，但是实际问题没那么简单，很多页面使用了这个机制，难道要每个页面的每个View在使用前都要判空吗？必须从机制上保证在RxJava的异步回调中View对象不为空，检查代码后发现的确是有这个保证的，就是在View要销毁时clear掉RxJava的异步回调，问题出在先后顺序上，写代码时并没有注意到这个先后顺序，unbind都在clear disposable之前，导致了这种崩溃有概率发生。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fragment has not been attached yet 崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个崩溃时因为Fragmegnt还没有Attach到Activity就调用了getChildFragmnetManager()导致，可通过添加isAdded判断，或在attach和detach时加一个标志来判断当前fragment的状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多线程没有同步导致的崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种问题比较常见了，虽然一个移动端App不需要很大量的并发，但是多个线程同时存在，并且操作共享变量的情况也不少，在这次修复崩溃的过程中就遇到很多例，都是因为对共享变量没有保护，导致其中一个线程已经把变量置空，而其他线程还在dereference这个变量而导致崩溃。这类问题，可根据实际情况采取不同的同步策略。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在UI线程中start，reset，release MediaPlayer导致的ANR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只要用到MediaPlayer的工程可能都避免不了这个问题吧，最好的解决办法就是将这些操作都放在一个非UI线程里，而把一些事件回调调度回UI线程，这样既不会有ANR，也将MediaPlayer的使用变得比较简单。典型的做法是对MediaPlayer进行封装，使用两个Handler和一个HandlerThread，将对MediaPlayer的操作都放在HandlerThread中，事件回调都通过其中一个Handler调度回主线程。&lt;/p&gt;

&lt;p&gt;以上就是最近解决的一些典型的崩溃和ANR，作此小计，积跬步。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Sep 2019 02:30:12 +0800</pubDate>
        <link>http://longlinht.github.io//fix-crash-and-anr</link>
        <guid isPermaLink="true">http://longlinht.github.io//fix-crash-and-anr</guid>
      </item>
    
      <item>
        <title>Android防空指南</title>
        <description>&lt;p&gt;最近集中进行了一段时间降低公司App崩溃率的工作，现在App的崩溃率控制在了万一与万三之间，整体来说还比较顺利，有必要将其中的方法和经验做一个沉淀。由于空指针异常导致的崩溃对App整体的崩溃率贡献巨大，日常的崩溃修复总是少不了几个空指针异常，虽然明显的空指针异常修复很容易，但是发出去的版本会持续崩溃，影响留存和体验，因此在积极修复空指针崩溃的同时也需要未雨绸缪，在开发阶段就把空指针拒之门外，对于事前防空的讨论非常多，也有大量的文章总结和分析这件事情，此文可能会提及这些讨论，但是主要还是总结我实践过的一些防空措施：&lt;/p&gt;

&lt;h3&gt;编写不空的代码&lt;/h3&gt;

&lt;p&gt;这个是基础，也是第一道防线，如果这一步没有做好，后面的一些措施可能负担更重。编写不空的代码其实就是要求我们在编写具体的方法和接口时尽量保证不返回null值，以及一些编程语言特性来避免空指针，也就是从根源上杜绝client代码不经意间去dereference一个空对象，具体的办法，或者说一些规约如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于数组，比如Point，返回空对象，return new Point[0];&lt;/li&gt;
&lt;li&gt;对于容器，比如ArraryList,返回空对象。如果需要泛型支持，retrun Collections.emptyList(); 如果不需要泛型支持，则 return Collections.EMPTY_LIST;&lt;/li&gt;
&lt;li&gt;对于字符串String,返回空对象， return “”; 而不是return null;&lt;/li&gt;
&lt;li&gt;这一条用语言不好表达，直接看代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// wrong way - may cause NullPointerException
if (unknownObj.equals(&amp;quot;unknownObj&amp;quot;)) {
}
// right way - avoid NPE even if unknownObj is null
if (&amp;quot;unknownObj&amp;quot;.equals(unknownObj) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;更加偏好使用valueOf()，而不是toString()&lt;/li&gt;
&lt;li&gt;避免没有必要的boxing和unboxing&lt;/li&gt;
&lt;li&gt;遵守约定，定义有意义的default(初始)对象&lt;/li&gt;
&lt;li&gt;如果必须返回null值，则用@Nullable注解标注，并在Android Studio中打开此类注解的警告开关，如遇警告，积极修复此类警告后再继续编码。&lt;/li&gt;
&lt;li&gt;进行双重入参校验&lt;/li&gt;
&lt;li&gt;使用Java8新特性，Optional&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些措施需要在代码编写时真正去遵守和实践，长期坚持下来会有不错的效果。如果以上措施是事前，那下面的措施就算是事后防空屏障了。&lt;/p&gt;

&lt;h3&gt;通过静态检测工具检查编译阶段代码&lt;/h3&gt;

&lt;p&gt;在不胜其烦的修复了很多Bugly上的空指针以后，我决定一定要找出一个能在编译阶段就能发现空指针风险的办法，于是就想到了通过静态代码检测工具来做这个事情。最先想到的就是findbugs，还找到了一个叫SpotBug的插件，但是这两个插件都没有针对性，毕竟我最优先要解决的是空指针异常的问题。又开始重新找寻，最后找到了由Uber公司研发的Nullaway检查器，它需要配合ErrorProne插件一起使用。因为Nullaway在Gradle里的配置，github上的README有点语焉不详，至少下面两个问题就很让人疑惑:
* 那些配置语句到底写在project的build.gradle文件里还是app下的build.gradle？ （当然如果你的工程只有一个app模块的话不存在这个问题)
* 在多模块的情况下是否可以统一在project的build.gradle文件里配置，还是需要在每个模块里配置一遍？&lt;/p&gt;

&lt;p&gt;所以我决定记录下我的采坑过程:  &lt;/p&gt;

&lt;h4&gt;配置ErrorProne插件和Nullaway检查器&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//build.gradle

buildscript {
    dependencies {
        classpath deps.gradlePlugin
        classpath deps.butterKnife
        classpath deps.wallePlugin
        classpath deps.sensorsPlugin

        classpath deps.realmPlugin

        // 配置ErrorProne插件和Nullaway检查器
        classpath deps.spotBugPlugin
        classpath deps.errorPronePlugin
    }
    repositories {
        google()
        jcenter()
    }
}


// check.gradle

apply plugin: &amp;#39;net.ltgt.errorprone&amp;#39;
tasks.withType(JavaCompile) {
    // remove the if condition if you want to run NullAway on test code
    if (!name.toLowerCase().contains(&amp;quot;test&amp;quot;)) {
        // remove &amp;quot;-Xep:NullAway:ERROR&amp;quot; to have NullAway only emit warnings
        options.compilerArgs += [&amp;quot;-Xep:NullAway:WARN&amp;quot;,
                                 //&amp;quot;-XepAllErrorsAsWarnings&amp;quot;,
                                 &amp;quot;-XepExcludedPaths:.*/build/generated/.*&amp;quot;,
                                 &amp;quot;-Xep:UnusedVariable:OFF&amp;quot;,
                                 &amp;quot;-Xep:UnusedMethod:OFF&amp;quot;,
                                 &amp;quot;-Xep:UnnecessaryParentheses:OFF&amp;quot;,
                                 &amp;quot;-Xep:CatchAndPrintStackTrace:OFF&amp;quot;,
                                 &amp;quot;-Xep:DefaultCharset:OFF&amp;quot;,
                                 &amp;quot;-Xep:JdkObsolete:OFF&amp;quot;,
                                 &amp;quot;-Xep:ClassCanBeStatic:OFF&amp;quot;,
                                 &amp;quot;-Xep:MissingOverride:OFF&amp;quot;,
                                 &amp;quot;-Xep:FragmentNotInstantiable:OFF&amp;quot;,
                                 &amp;quot;-Xep:VariableNameSameAsType:OFF&amp;quot;,
                                 &amp;quot;-Xep:FallThrough:OFF&amp;quot;,
                                 &amp;quot;-Xep:FutureReturnValueIgnored:OFF&amp;quot;,
                                 &amp;quot;-Xep:OperatorPrecedence:OFF&amp;quot;,
                                 &amp;quot;-Xep:UndefinedEquals:OFF&amp;quot;,
                                 &amp;quot;-Xep:RxReturnValueIgnored:OFF&amp;quot;,
                                 &amp;quot;-Xep:StringSplitter:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsHashCode:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsGetClass:OFF&amp;quot;,
                                 &amp;quot;-Xep:ComplexBooleanConstant:OFF&amp;quot;,
                                 &amp;quot;-Xep:DoubleBraceInitialization:OFF&amp;quot;,
                                 &amp;quot;-Xep:InconsistentCapitalization:OFF&amp;quot;,
                                 &amp;quot;-Xep:HidingField:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsUnsafeCast:OFF&amp;quot;,
                                 &amp;quot;-XepOpt:NullAway:AnnotatedPackages=com.inyuapp,io.liuliu&amp;quot;]
    }
}

// 因为我们的工程有很多个模块，因此我在每个module的build.gradle如下配置:

apply plugin: &amp;#39;com.android.library&amp;#39;
apply from: &amp;#39;../../check.gradle&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个配置之后基本就可以正常使用了，但是还是需要特别注意几个问题，也是我在集成的过程中踩过的坑:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在project的build.gradle中统一配置的方式会报Nullaway找不到的问题，这个目前无解，就只能通过在每个module分别配置，不过可以通过统一写一个check.gradle，在每个module的build.gradle中apply，如上&lt;/li&gt;
&lt;li&gt;可以配置ErrorProne每个检查器的编译错误级别，分别有ERROR，WARN，OFF，如果某个检查器配置为ERROR级别，那么此检查器如果在代码中发现此类问题，就会导致整个build失败，如果对特定的错误很关注，可设为ERROR级别，限制处理完此类问题才能build成功。&lt;/li&gt;
&lt;li&gt;Nullaway检查器需要配置要检查的包，多个源代码包可通过”,&amp;quot;分割&lt;/li&gt;
&lt;li&gt;Nullaway的检查都是基于@Nullable注解，因此在类中的字段，方法返回值，入参上适当使用@Nullable才能使Nullaway检查器很好工作&lt;/li&gt;
&lt;li&gt;此类代码不会通过Nullaway检查&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (ControllerHelper.getTopLineModel() != null) {
    ControllerHelper.getTopLineModel().setUserLifeShow(false);
    ControllerHelper.getTopLineModel().setCoinNumberShow(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在开启了ErrorProne和Nullable检查器后，公司的工程出现了大量无法通过检查器的代码，出现问题最多的错误如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;dereferenced expression is @Nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而此类错误就是很多Bugly上空指针异常的罪魁祸首，需重点排查。&lt;/p&gt;

&lt;p&gt;实际上Nullaway可以检查很多情况的问题，Nullaway的文档显示有诸如以下致空的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dereferenced expression is @Nullable&lt;/li&gt;
&lt;li&gt;returning @Nullable expression from method with @NonNull return type&lt;/li&gt;
&lt;li&gt;passing @Nullable parameter where @NonNull is required&lt;/li&gt;
&lt;li&gt;assigning @Nullable expression to @NonNull field&lt;/li&gt;
&lt;li&gt;method returns @Nullable, but superclass method returns @NonNull&lt;/li&gt;
&lt;li&gt;referenced method returns @Nullable, but functional interface method returns @NonNull&lt;/li&gt;
&lt;li&gt;parameter is @NonNull, but parameter in superclass method is @Nullable&lt;/li&gt;
&lt;li&gt;parameter is @NonNull, but parameter in functional interface method is @Nullable&lt;/li&gt;
&lt;li&gt;unbound instance method reference cannot be used, as first parameter of functional interface method is @Nullable&lt;/li&gt;
&lt;li&gt;initializer method does not guarantee @NonNull field is initialized / @NonNull field not initialized&lt;/li&gt;
&lt;li&gt;read of @NonNull field before initialization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在公司的工程只开启了两个module作为试点，如果能有好的防空效果，会逐步应用到整个工程。目前的主要防空措施就是这些，当然在调研的过程中也引入了一个类似findbugs的工具SpotBug，此插件也已集成好，只要通过一个简单的命令即可开始一次检查&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查的结果可以通过输出的本地html文件查看&lt;/p&gt;

&lt;p&gt;用了这么多工具，又是插件，又是检查器，又是注解，说以前道一万，这些都是辅助措施，要真正减少空指针，降低崩溃率，还是要通过编写高质量的代码来实现，上面提到的那个代码片段，实在不能容忍，肯定要喷，必须要改，共勉！&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Sep 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//guide-to-prevent-null-in-android-project</link>
        <guid isPermaLink="true">http://longlinht.github.io//guide-to-prevent-null-in-android-project</guid>
      </item>
    
      <item>
        <title>在WebView中支持视频全屏</title>
        <description>&lt;p&gt;最近感觉和WebView杠上了，刚解决完在WebView中使用Android相机拍照和录像的问题，又遇到在WebView中视频无法全屏，和之前相机拍照和视频的问题一样，iOS和其他浏览器都没有问题，独WebView出错。通过网上查阅一些资料，最终顺利解决，虽不是什么难搞的东西，但是真要弄起来，也需要一些心力，所以通过此篇记录下整个过程。&lt;/p&gt;

&lt;p&gt;解决整个问题其实很程式化，先按部就班保证视频能够正常播放:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在AndroidManifest.xml中声明hardwareAccelerate属性&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; &amp;lt;application android:hardwareAccelerated =&amp;quot;true&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在Activity中声明&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;activity android:hardwareAccelerated=&amp;quot;true&amp;quot; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在代码中设置&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;getWindow.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后来实现全屏, 而能够全屏的关键在于重写WebChromeClient的onShowCustomView()和onHideCustomView()方法, 在Activity中实现自定义的WebChromeClient，在onShowCustomView中横屏，隐藏WebView,并将得到的View添加到FrameLayout中显示。在onHideCustomView中隐藏View，显示WebView，并竖屏.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private View mCustomView;
private WebChromeClient.CustomViewCallback mCustomViewCallback;

@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    if (mCustomView != null) {
        callback.onCustomViewHidden();
        return;
    }
    mCustomView = view;
    webViewContainer.addView(mCustomView);
    mCustomViewCallback = callback;
    mWebView.setVisibility(View.GONE);
    mTitle.setVisibility(View.GONE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
}

@Override
public void onHideCustomView() {
    mWebView.setVisibility(View.VISIBLE);
    mTitle.setVisibility(View.VISIBLE);
    if (mCustomView == null) {
        return;
    }
    mCustomView.setVisibility(View.GONE);
    webViewContainer.removeView(mCustomView);
    mCustomViewCallback.onCustomViewHidden();
    mCustomView = null;
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中mCustomView和 mCustomViewCallback 需要保存下来，WebView的父容器在实现中也很重要。&lt;/p&gt;

&lt;p&gt;需要注意的问题&lt;/p&gt;

&lt;p&gt;如果H5工程师在html中使用了iframe, 那需要H5工程师配合在其中中加入一些属性才能对视频进行操作，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;allowfullscreen=&amp;quot;true&amp;quot; webkitallowfullscreen=&amp;quot;true&amp;quot; mozallowfullscreen=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Thu, 11 Jul 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//h5-video-fullscreen-in-webview</link>
        <guid isPermaLink="true">http://longlinht.github.io//h5-video-fullscreen-in-webview</guid>
      </item>
    
      <item>
        <title>解决SharedPreferences导致的ANR</title>
        <description>&lt;p&gt;这几天在Google Play的ANR实时报告中看到很多貌似与SharedPreferences相关的ANR，看了历史版本后发现，这个已经是一个老问题了，在历次版班的ANR中居高不下。今天实在忍不了，决定对这个问题一探究竟。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; at java.lang.Object.wait! (Native method)
- waiting on &amp;lt;0x0a351954&amp;gt; (a java.lang.Object)
  at java.lang.Thread.parkFor$ (Thread.java:1220)
- locked &amp;lt;0x0a351954&amp;gt; (a java.lang.Object)
  at sun.misc.Unsafe.park (Unsafe.java:299)
  at java.util.concurrent.locks.LockSupport.park (LockSupport.java:158)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt (AbstractQueuedSynchronizer.java:810)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly (AbstractQueuedSynchronizer.java:970)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly (AbstractQueuedSynchronizer.java:1278)
  at java.util.concurrent.CountDownLatch.await (CountDownLatch.java:203)
  at android.app.SharedPreferencesImpl$EditorImpl$1.run (SharedPreferencesImpl.java:366)
  at android.app.QueuedWork.waitToFinish (QueuedWork.java:88)
  at android.app.ActivityThread.handleServiceArgs (ActivityThread.java:3029)
  at android.app.ActivityThread.access$2200 (ActivityThread.java:155)
  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1450)
  at android.os.Handler.dispatchMessage (Handler.java:102)
  at android.os.Looper.loop (Looper.java:175)
  at android.app.ActivityThread.main (ActivityThread.java:5430)
  at java.lang.reflect.Method.invoke! (Native method)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:726)
  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:616)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这事Google Play提供的堆栈信息，信息非常有限，但是还是能观察到SharedPreferences的身影的，这个 &lt;code&gt;waitToFinish&lt;/code&gt; 非常可疑，追踪到代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&amp;#39;s onPause(), after
 * BroadcastReceiver&amp;#39;s onReceive, after Service command handling,
 * etc. (so async work is never lost)
 */
public static void waitToFinish() {
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) {
        toFinish.run();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的注释已经很清楚了，如果我们使用SharedPreference的apply方法, 虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity, BroadcastReceiver和Service的一些回调方法被调用时，会等待写入到文件系统的任务完成，如果写入比较慢，主线程就会出现ANR问题。&lt;/p&gt;

&lt;p&gt;另外，SharedPreference除了提供apply外还提供commit方法，源码如下所示，该方法直接在调用线程中执行，不会转入后台，但如果我们在UI线程commit，且磁盘写入较慢的情况下，ANR依然会发生。行文至此，问题应该描述的比较清楚了，可以理解为SharedPreferences的机制导致系统组件回调过程中的阻塞，触发了ANR。可以将这个问题视为Android一个bug，也可以将问题归咎于为使用SharedPreferences不当(在SharedPreferences里读写数据量太大), 但是问题终究要解决，所以下面提出解决方案，并且记录下解决过程中的实践经验。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案一&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑启动一个线程commit，不使用apply&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案二&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hook ActivityThread，拿到Handler变量，在调用QueuedWork.waitToFinish()之前，将其中保存的队列清空，防止ANR的发生&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案三&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用MMKV替代SharedPrferences&lt;/p&gt;

&lt;p&gt;最后我们选用了第三种方案，对于我们现有的代码改动量最小。第一种方案可行，但是也有问题，会有线程同步，仍然需要管理其他线程，保证读写的一致性。第二种方案不好验证它的副作用，因此也没有采纳。&lt;/p&gt;

&lt;p&gt;选用MMKV后也有一个问题需要解决，那就是数据迁移，因为不可能针对之前所有使用SharedPreferences的地方逐一进行迁移，因此写了一个MMKV的封装类来统一对外提供数据迁移和读写的接口，可以实现对现已代码最小改动的情况下完成替换和迁移。封装类如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class SharedPreferencesStore {
    public static final String TAG = SharedPreferencesStore.class.getSimpleName();

    private MMKV mMMKV;

    private SharedPreferencesStore(MMKV mmkv) {
        mMMKV = mmkv;
    }

    // 初始化，必须在使用前调用
    public static void initialize(Context context) {
        String rootDir = MMKV.initialize(context);
        ApplicationDelegate.log(TAG + &amp;quot; MMKV root directory=&amp;quot; + rootDir);
    }

    // 获取全局SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobal() {
        MMKV mmkv = MMKV.defaultMMKV();
        return new SharedPreferencesStore(mmkv);
    }

    // 获取全局SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobalWithMigration(Context context) {
        MMKV mmkv = MMKV.defaultMMKV();
        importFromDefaultSharePreferences(mmkv, context);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        importFromSharePreferences(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        importFromSharePreferencesMultiProcess(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    public void put(final String key, boolean value) {
        mMMKV.encode(key, value);
    }

    public boolean getBoolean(final String key, boolean defValue) {
        return mMMKV.decodeBool(key, defValue);
    }

    public void put(final String key, int value) {
        mMMKV.encode(key, value);
    }

    public int getInt(final String key, int defValue) {
        return mMMKV.decodeInt(key, defValue);
    }

    public void put(final String key, long value) {
        mMMKV.encode(key, value);
    }

    public long getLong(final String key, long defValue) {
        return mMMKV.decodeLong(key, defValue);
    }

    public void put(final String key, float value) {
        mMMKV.encode(key, value);
    }

    public float getFloat(final String key, float defValue) {
        return mMMKV.decodeFloat(key, defValue);
    }

    public void put(final String key, double value) {
        mMMKV.encode(key, value);
    }

    public double getDouble(final String key, double defValue) {
        return mMMKV.decodeDouble(key, defValue);
    }

    public void put(final String key, final String value) {
        mMMKV.encode(key, value);
    }

    public String getString(final String key, final String defValue) {
        return mMMKV.decodeString(key, defValue);
    }

    public void put(final String key, final byte[] value) {
        mMMKV.encode(key, value);
    }

    public byte[] getBytes(final String key) {
        return mMMKV.decodeBytes(key);
    }

    public Map&amp;lt;String, ?&amp;gt; getAll() {
        return mMMKV.getAll();
    }

    public void remove(final String key) {
        mMMKV.remove(key);
    }

    public void removeForKey(final String key) {
        mMMKV.removeValueForKey(key);
    }

    public void removeForKeys(final String[] keys) {
        mMMKV.removeValuesForKeys(keys);
    }

    public boolean contains(final String key) {
        return mMMKV.contains(key);
    }

    public boolean containsKey(final String key) {
        return mMMKV.containsKey(key);
    }

    public SharedPreferences.Editor edit() {
        return mMMKV.edit();
    }

    public static void importFromSharePreferences(MMKV mmkv, final Context context, final String name) {
        if (null == context) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_PRIVATE);
        doImport(mmkv, sp, name);
    }

    public static void importFromSharePreferencesMultiProcess(MMKV mmkv, final Context context, final String name) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_MULTI_PROCESS);
        doImport(mmkv, sp, name);
    }

    public static void importFromDefaultSharePreferences(MMKV mmkv, final Context context) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
        doImport(mmkv, sp, context.getPackageName() + &amp;quot;_preferences&amp;quot;);
    }

    private static void doImport(MMKV mmkv, SharedPreferences sp, final String name) {
        ApplicationDelegate.log(TAG + &amp;quot; ------&amp;quot; + name + &amp;quot;-----SharedPreferences迁移开始-----------&amp;quot;);
        if (sp.getAll() == null || sp.getAll().size() == 0) {
            ApplicationDelegate.log(TAG + &amp;quot; &amp;quot; + name + &amp;quot; SharedPreferences 为空，不需要迁移&amp;quot;);
            return;
        }

        int oldSize = sp.getAll().size();
        ApplicationDelegate.log(TAG + &amp;quot; old size: &amp;quot; + oldSize);

        Map&amp;lt;String, ?&amp;gt; map = sp.getAll();

        Map&amp;lt;String, String&amp;gt; keyTypes = new HashMap&amp;lt;&amp;gt;();

        ApplicationDelegate.log(TAG + &amp;quot; ---old data: &amp;quot;);
        for (Map.Entry&amp;lt;String, ?&amp;gt; entry : map.entrySet()) {
            Object obj = entry.getValue();
            if (obj instanceof Boolean) {
                keyTypes.put(entry.getKey(), &amp;quot;Boolean&amp;quot;);
            } else if (obj instanceof Integer) {
                keyTypes.put(entry.getKey(), &amp;quot;Integer&amp;quot;);
            } else if (obj instanceof Long) {
                keyTypes.put(entry.getKey(), &amp;quot;Long&amp;quot;);
            } else if (obj instanceof Float) {
                keyTypes.put(entry.getKey(), &amp;quot;Float&amp;quot;);
            } else if (obj instanceof Double) {
                keyTypes.put(entry.getKey(), &amp;quot;Double&amp;quot;);
            } else if (obj instanceof String) {
                keyTypes.put(entry.getKey(), &amp;quot;String&amp;quot;);
            }
            ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + entry.getKey() + &amp;quot; value: &amp;quot; + entry.getValue());
        }


        int imported = mmkv.importFromSharedPreferences(sp);
        ApplicationDelegate.log(TAG + &amp;quot; imported size: &amp;quot; + imported);

        if (BuildConfig.DEBUG) {
            ApplicationDelegate.log(TAG +  &amp;quot; ---imported data: &amp;quot;);

            String[] keys = mmkv.allKeys();
            for (int i = 0; i &amp;lt; keys.length; i++) {

                String type = keyTypes.get(keys[i]);
                if (type == null) {
                    continue;
                }

                switch (type) {
                    case &amp;quot;Boolean&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeBool(keys[i]));
                        break;
                    case &amp;quot;Integer&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeInt(keys[i]));
                        break;
                    case &amp;quot;Long&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeLong(keys[i]));
                        break;
                    case &amp;quot;Float&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeFloat(keys[i]));
                        break;
                    case &amp;quot;Double&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeDouble(keys[i]));
                        break;
                    case &amp;quot;String&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeString(keys[i]));
                        break;
                    default:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: unknown type&amp;quot;);
                        break;
                }
            }
        }


        if (imported &amp;gt; 0 &amp;amp;&amp;amp; oldSize == imported) {
            sp.edit().clear().apply();
        }

        if (oldSize != imported) {
            ApplicationDelegate.log(TAG + &amp;quot; SharedPreferences 迁移失败, name=&amp;quot; + name);
            ApplicationDelegate.bugTrace(ApplicationDelegate.MAIN_CODE_MMKV_IMPORT_FAIL, 0,
                    &amp;quot;name=&amp;quot; + name + &amp;quot;, old size=&amp;quot; + oldSize + &amp;quot;, import size=&amp;quot; + imported);
        }
        ApplicationDelegate.log(TAG +  &amp;quot; ------&amp;quot; + name + &amp;quot;-----SharedPreferences迁移结束-----------&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次替换和迁移目前已经上线验证 ，目前只发现在API 19的机器上出现崩溃，报java.lang.UnsatisfiedLinkError，MMKV的官网上有次问题的解答，可以参考解决。&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jul 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//fix-anr-related-sharedpreferences</link>
        <guid isPermaLink="true">http://longlinht.github.io//fix-anr-related-sharedpreferences</guid>
      </item>
    
      <item>
        <title>在WebView中调用Android相机拍照录像</title>
        <description>&lt;p&gt;最近公司App需要以H5的方式接入七鱼客服，根据他们的开发文档接入起来还是很容易，成本很低。理论上如果以native的方式接入的话，用户体验会更好，但是接入后增加的包体积是无法接受的，遂改用H5的方式，整个接入过程还算顺利，有相对详尽的接入文档和demo，只是在最后接入完成后，因为沟通不畅，忽略了客服聊天界面在Android上无法发图片和发视频的问题。同一份html，iOS就是正常的，Android上就死活没反应。后来才恍然大悟，WebView是不支持JS去直接操作Android相机的，必须通过回调到native，由native完成照片的选择，拍摄和录像后将数据返回给JS才能完成一次照片和视频的发送。清楚了问题所在，就需要实现WebView的标准接口来实现这个回调到native的功能，在代码实现前，需要先厘清一些WebView的基本概念和原理。&lt;/p&gt;

&lt;p&gt;像发送图片和视频这样的操作，涉及到了定制WebView的一些默认行为，理论上如果要做定制，就需要了解WebSettings、JavaScriptInterface、WebViewClient以及WebChromeClient，一般而言，通过配置WebSettings，使用JavasScriptInterface，重写WebViewClient和WebChromeClient对象的相关方法，就可以实现一些我们想要的行为。发图片和发视频就是通过重写WebChromeClient对象的几个方法来实现的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// 重写WebChromeClient的特定方法来实现图片和视频的发送
mWebView.setWebChromeClient(new WebChromeClient() {
    // For Android &amp;gt;=3.0
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg, String acceptType) {
        if(acceptType.equals(&amp;quot;image/*&amp;quot;)) {
            if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(null);
                return;
            }
            mUploadMessage = uploadMsg;
            selectImage();
        } else {
            onReceiveValue();
        }
    }

    // For Android &amp;lt; 3.0
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg) {
        openFileChooser(uploadMsg, &amp;quot;image/*&amp;quot;);
    }

    // For Android  &amp;gt;= 4.1.1
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg, String acceptType, String capture) {
        openFileChooser(uploadMsg, acceptType);
    }

    // For Android  &amp;gt;= 5.0
    @Override
    @SuppressLint(&amp;quot;NewApi&amp;quot;)
    public boolean onShowFileChooser(WebView webView, ValueCallback&amp;lt;Uri[]&amp;gt; filePathCallback, FileChooserParams fileChooserParams) {
        if (fileChooserParams != null &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes() != null
                &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes().length &amp;gt; 0 &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;image/*&amp;quot;)) {
            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            selectImage();
        } else if (fileChooserParams != null &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes() != null
                &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes().length &amp;gt; 0 &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;video/*&amp;quot;)){

            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            PermissionUtil.requestPermission(QiyuWebViewActivity.this, PermissionUtil.PERMISSIONS_CAMERA_RECORD_AUDIO, PermissionUtil.REQUEST_CAMERA_RECORD_AUDIO);
        } else {
            onReceiveValue();
        }
        return true;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，这几个回调方法，需要针对不同Android版本分别做处理，在onShowFileChooser方法中需要区分是图片还是视频，并且无论是在相册中选取还是拍摄照片，录像都需要申请相应的权限，这个一定不能少，网上很多的demo都是没有权限申请环节的，代码根本不可用。&lt;/p&gt;

&lt;p&gt;在正确的回调到onShowFileChooser后，就要区分图片和视频的情况下走正常的选取，拍照，录像的流程，并且把获取到的图片，视频数据回传给JS调用，这样就完成了桥接调用。虽然现在看起来挺简单的，但是还是有些点容易成为坑点，让人走很多弯路:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要的配置一定要设定&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mWebView.getSettings().setJavaScriptEnabled(true);
mWebView.getSettings().setDomStorageEnabled(true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态权限申请一定不能少&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正确区分图片和视频&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// &amp;quot;video/* 为视频&amp;quot;
fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;image/*&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下，在WebView的JS调用系统相机的关键是重写WebChromeClient的特定方法来实现的。&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Jun 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//operate-camera-in-webview</link>
        <guid isPermaLink="true">http://longlinht.github.io//operate-camera-in-webview</guid>
      </item>
    
      <item>
        <title>HTTP/2 从初探到实际场景的运用</title>
        <description>&lt;p&gt;HTTP/2其实出来已经很长时间了，但是一个新的协议，新的标准从出现到大量被采用，总是会经历一个过程。我们的产品最近基于网络请求优化的要求，需要将之前的HTTP/1都升级到支持HTTP/2，这个事情其实需要两方同时进行，服务端和客服端需要同时支持HTT/2。在做这个事情之前需要首先调研HTTP/2，了解它的特性和优缺点。&lt;/p&gt;

&lt;p&gt;对HTTP2的基本的调研结果如下:&lt;/p&gt;

&lt;h4&gt;HTTP/2的由来&lt;/h4&gt;

&lt;p&gt;HTTP/2 的前身是 SPDY协议，第一版草稿就是基于 SPDY3 规范修改制定而来。HTTP/2维持了原来 HTTP 的范式（不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等等）&lt;/p&gt;

&lt;h4&gt;为什么是HTTP/2&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接次数减少 
理想情况下，单个域名对应一条链接，如果此链接一直保持有数据传输，则类似一个长链接，不会建立多条链接，HTTP/1.1虽然也可以通过keep-alive做到类似的效果，但是无法做到请求并发，这也是HTTP/2不同于HTTP/1.x的一个重要方面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发发送请求 
发送请求不再是串行, 提高了发送效率,同一时间可同时发出多个请求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流量节省 
由于 HTTP/2的发送协议的修改和优化，流量的表现也有明显提升。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;HTTP/2的特性&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制分帧
HTTP/2 在维持原有 HTTP 范式的前提下，实现突破性能限制，改进传输性能，实现低延迟和高吞吐量的其中一个关键是：在应用层（HTTP2）和传输层（TCP or
UDP）之间增加了二进制分帧层&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多路复用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同一个流中的帧是交错传输的！&lt;/li&gt;
&lt;li&gt;Header 帧必须在 data 帧前面，因为无论是客户端还是服务端，都依赖 header 帧的信息解析 data 帧的数据！&lt;/li&gt;
&lt;li&gt;先到的帧不一定先返回，快的可以先返回！ &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头压缩&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过HPACK 压缩算法，HTTP2 在户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器推送&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;送优先级与依赖性&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可重置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流量控制&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTPS RFC 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和服务器实现都基于 HTTPS 来实现 HTTP/2&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是在支持HTTP/2前所做的一些调研，一些HTTP/2的特性，略显简略，因为此文的重点并不是介绍协议特性，因此就不赘述了。接下我想具体谈谈我们在支持HTTP/2的过程中所做的事，所遇到的问题和解决方法。&lt;/p&gt;

&lt;h4&gt;在现有工程支持HTTP/2&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用大名鼎鼎的OkHttp来替换原有使用HttpURLConnection封装的网络基础模块，因为OkHttp原生支持HTTP/2，实际上我们不需要自己去实现HTTP/2协议，更不需要去设计和管理复杂的网络基础设施。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对现有代码逻辑的兼容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为现有代码中很多不那么规范的写法，例如文件上传，将参数拼接和文件内容的字节流写在了一起，这类网络请求本来也不是HTTP/2的优势场景，因此还是走HTTP/1.x协议，因此我们设计了一个网络请求协议分派的管理类，在这个类里面统一做网络请求协议的分发。这样做的另一个考量是如果支持HTTP/2协议的这个版本在上线后出现大面积问题的话，可以迅速再切回HTTP/1.x。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加入顺延心跳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP/2的理想情况下有点类似长连接，但是毕竟不是长连接，在一定的时间段如果没有请求的话，连接一样会断开，因为我们App的大部分业务请求其实都对应一个域名，所以保持这条连接一直不断就变得比较有意义，所有我们加入了心跳机制，心跳间隔以顺延的方式，进一步减少不必要的心跳，这样一来既不会有过多的心跳，也保证了连接不会频繁断开。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS 优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个在上一篇讨论连通性的文章中已经讨论过了，这里就不再详述。&lt;/p&gt;

&lt;h4&gt;如何衡量HTTP/2带来的提升&lt;/h4&gt;

&lt;p&gt;有的时候衡量你做的事的结果比起做事本省可能还要难，这次支持HTTP/2和优化连通性的工作就属于此类，做本身真不是很难，可预见的问题也都在可控范围之内，但是要衡量它的效果，或者说带来的提升和优化，这就需要设计一整套的衡量指标了，并且这些指标也都需要在这个支持HTTP/2的版本上线前就准备好。为此，我们也是调研了很多资料，结合我们能通过上报的数据，最终定下了如下几个指标来衡量:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RTT - 完成整个事件的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据我们为了和没有支持HTTP/2的版本作比较，将上报的数据做了分区间整理，也就是将耗时从&lt;200ms, 200~500ms, 500~700ms, 700~1000ms, &gt;1000ms做了五个区间来统计每个区间的请求数在总请求数中的占比，通过两个版本的数据来验证HTTP/2的优化和提升，这个指标是最直观的。为了避免一些脏数据导致的数据偏差，我们还针对单个接口进行了数据分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求失败率 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个比率是有所下降的，尤其UnknownHostException异常导致的失败在总失败中所占比重明显下降，这个数据的提升得益于上篇文章中对连通性的优化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求各个阶段的耗时 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据做了上报和统计，但是并没有去细致的分析各个阶段的耗时，不过的确可以作为一个参考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;观察并发请求下的表现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为我们做的是直播业务，在进入直播间的一瞬间，可能会有非常多的并发请求，这种场景就体现出了HTTP/2并发发送请求的特性，可以说提升非常可观。&lt;/p&gt;

&lt;h4&gt;如何测试HTTP/2&lt;/h4&gt;

&lt;p&gt;如果在有限的资源条件下测试和验证HTTP/2，可能最先想到的就是要进行弱网环境测试:&lt;/p&gt;

&lt;p&gt;如何进行弱网测试:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SIM卡的网络切换,手机-设置-移动网络设置-网络类型选择3G,4G卡都可以设置关闭3G/4G，只走2G网络&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用虚拟机模拟网络速度,如用树莓派搭建的弱网测试仪&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件进行网络代理,模拟不同的网络带宽、延时率、丢包率&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Charles&lt;/li&gt;
&lt;li&gt;Chrome的webview调试工具&lt;/li&gt;
&lt;li&gt;iOS自带Network Linker Conditioner&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上就是我们在支持HTTP/2过程中的一些调研结果和实际工作中的经验总结。&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jun 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//upgrade-to-http2</link>
        <guid isPermaLink="true">http://longlinht.github.io//upgrade-to-http2</guid>
      </item>
    
      <item>
        <title>优化App网络连通性问题</title>
        <description>&lt;p&gt;最近遇到一个棘手的问题，我们开发的一款App在中东那边出现大量的&lt;code&gt;UnknownHostException&lt;/code&gt;, 导致App在中东那边体验很糟，很快这个问题就被抛给了我们技术优化组，我和另外一名同事就开始定位问题的原因并且试图提出一个可行的解决方案。一般理解，出现&lt;code&gt;UnkownHostException&lt;/code&gt;就是DNS失败了，在我们开始解决这个问题的时候，App的网络库已逐渐开始使用OkHttp，我们想到自定义DNS过程，在系统DNS失败的情况下再尝试其他DNS方式，降低&lt;code&gt;UnknownHostException&lt;/code&gt;出现的频率，优化App网络连通性。
为了实现我们的技术方案，我们针对OkHttp的DNS做了如下几件事:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建OkHttpClient时自定义DNS&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;OkHttpClient.Builder builder = new OkHttpClient.Builder()
    // 实现OKHttp DNS接口, 改变默认的DNS行为
    .dns(OkHttpDns.getInstance())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的OkHttpDns须实现Dns接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现自定义DNS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前我们的设计是使用责任链模式实现四层DNS的lookup: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第一层是本地DNS缓存(Local Cache)，整个缓存只是内存缓存，DNS过程开始时，先去本地缓存找，如果在缓存中没有命中，就走系统DNS， 系统DNS如果也失败，整个链条就继续往下，到GA，到Google DNS，如果到Google DNS还没有解析成功，仍旧抛出&lt;code&gt;UnknownHostException&lt;/code&gt;，DNS过程失败。基本的代码逻辑如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private OkHttpDns() {

  //使用责任链模式实现四层DNS的lookup: Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
  mDnsChain = new CacheDnsHandler();

  SystemDnsHandler okhttp = new SystemDnsHandler();
  GADnsHandler ga = new GADnsHandler();
  GoogleHttpDnsHandler google = new GoogleHttpDnsHandler();

  mDnsChain.setTarget(okhttp);
  okhttp.setTarget(ga);
  ga.setTarget(google);
}

@Override
public List&amp;lt;InetAddress&amp;gt; lookup(String hostname) throws UnknownHostException {
  // IP直连的情况,直接返回
  if (InetAddressValidator.isIPAddress(hostname)) {
      return Arrays.asList(InetAddress.getAllByName(hostname));
  }

  List&amp;lt;InetAddress&amp;gt; allDNSResult = new ArrayList&amp;lt;&amp;gt;();
  List&amp;lt;InetAddress&amp;gt; list = mDnsChain.lookup(hostname, allDNSResult);

  if (list == null) {

      // DNS完全失败后,清空黑名单,删除local cache相应的条目
      IPStatusCache.getInstance().clear();

      if (allDNSResult.isEmpty()) {
          throw new UnknownHostException(&amp;quot;Broken system behaviour for dns lookup of &amp;quot; + hostname);
      } else {
          return allDNSResult;
      }
  }
  return list;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加黑名单机制，进一步优化DNS
一次连接成功后缓存DNS结果，host+ip为key，IPStatus为value，连接失败后会更新DNS缓存的失败次数，超过5次则认为进入了黑名单，在每次DNS完全失败后清空本地DNS缓存，防止所有的缓存都进入黑名单，缓存失效。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理IP直连的情况
这种情况的处理很简单，检查传入的host是不是ip，如果是就直接返回。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过这样的优化以后，&lt;code&gt;UnknownHostException&lt;/code&gt;在请求失败中的比重和请求的总失败率大幅下降，验证了我们这个技术方案的合理性，可以说网络连通性大大提高，再次回顾这个方案，突然发现它其实一个通用的解决方案，虽然我们这次解决的是海外，如中东地区的连通性问题，其实这个方案完全可以移植到国内，只要将Google HttpDNS换成国内的HttpDNS即可，整体的DNS流程可以不做任何改动即可成为一个完整的App DNS解决方案。&lt;/p&gt;
</description>
        <pubDate>Wed, 29 May 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//connectivity-in-android</link>
        <guid isPermaLink="true">http://longlinht.github.io//connectivity-in-android</guid>
      </item>
    
      <item>
        <title>三星折叠屏适配小计</title>
        <description>&lt;p&gt;三星要在近期发布折叠屏手机，消息一出，我们就得抓紧做适配，也没有什么现成的经验作参考，尤其令人头疼的是还没有真机供我们测试。没办法，兵来将挡，水来土掩，进过一周多的调研和开发，终于做完了大部分App页面的适配工作，也因为做这个适配的过程踩了很多坑，特写下这篇小记。&lt;/p&gt;

&lt;p&gt;在我们开始做适配前，首先要解决没有真机可做测试的问题，无法验证适配的效果，还好三星也想到了这个问题，在官网提供了一个模拟器应用，Foldable Emulator， 通过这个模拟器App可以在Fold和Unfold模式之间自由切换，验证适配效果。当我们适配工作结束后在真机上测试时发现，这个模拟器的仿真度极高，基本没有出现和真机上效果有出入的地方。&lt;/p&gt;

&lt;p&gt;在解决了没有真机的问题之后，我们就开始着手真正的适配工作。首先遇到的问题就是折叠屏手机需要在Fold和Unfold之间频繁切换，而这种切换的效果和横竖屏切换是一样的，默认都会导致Activity重建，而Activity重建又会导致一系列的连锁反应，如需要恢复大量数据、重新建立网络连接或执行其他密集操作，因此在适配前就需要规划哪些页面(Activity)需要重建，哪些不需要重建，所以需要按Activity是否重建这两种情况来分析切屏的后果和应对方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重建Activity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。 此外，依靠系统通过onSaveInstanceState() 回调保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。当 Android 系统因配置变更而关闭 Activity 时，不会销毁已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。
要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;扩展 Fragment 类并声明对有状态对象的引用&lt;/li&gt;
&lt;li&gt;在创建片段后调用 setRetainInstance(boolean)&lt;/li&gt;
&lt;li&gt;将片段添加到 Activity&lt;/li&gt;
&lt;li&gt;重启 Activity 后，使用 FragmentManager 检索片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如，按如下方式定义片段：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class RetainedFragment extends Fragment {

    // 想要保存的数据
    private MyDataObject data;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 保存这个fragment
        setRetainInstance(true);
    }
    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，使用 &lt;code&gt;FragmentManager&lt;/code&gt; 将片段添加到 &lt;code&gt;Activity&lt;/code&gt;。在运行时配置变更期间再次启动 &lt;code&gt;Activity&lt;/code&gt; 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class MyActivity extends Activity {
    private RetainedFragment retainedFragment;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 在activity重启后，获取保留的fragment
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);
        // 首次创建
        if (retainedFragment == null) {
            // 添加fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // 从网络获取data
            retainedFragment.setData(loadMyData());
        }
        // retainedFragment.getData()获取的数据可用
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onCreate() 添加了一个片段或恢复了对它的引用。此外，onCreate() 还将有状态的对象存储在片段实例内部。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;尽管Fragment内部可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;不重建Activity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想不重新启动的情况下处理配置更改，则需要在清单中添加一个android：configChanges属性，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;activity
    android:name=&amp;quot;......CMVideoPlayerActivity&amp;quot;
    android:configChanges=&amp;quot;screenSize|smallestScreenSize|screenLayout&amp;quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要手动更新视图布局并在onConfigurationChaged（）中重新加载资源&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onConfigurationChanged(Configuration newConfig) {
   super.onConfigurationChanged(newConfig);
   if ((newConfig.screenLayout &amp;amp; Configuration.SCREENLAYOUT_LONG_MASK) == Configuration.SCREENLAYOUT_LONG_YES) {

   }
   if ((newConfig.screenLayout &amp;amp; Configuration.SCREENLAYOUT_LONG_MASK ) == Configuration.SCREENLAYOUT_LONG_NO) {

   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在遵循上述基本原则以后，就要应对实际的适配问题了，整个适配的工作主要涉及以下几个问题的解决:&lt;/p&gt;

&lt;h4&gt;检测设备是否可折叠,当前是Fold状态还是Unfold，并且能够在切屏时通知到需要对切屏事件作出处理的页面&lt;/h4&gt;

&lt;p&gt;为了统一解决这个问题，设计了一个单例类来统一管理&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class FoldObserable extends Observable {

    public static final int SCREEN_LARGE_WIDTH = 1536;

    public static final int SCREEN_LARGE = 0;
    public static final int SCREEN_SMALL = 1;

    private static class SINGLE {
        public static FoldObserable INSTANCE = new FoldObserable();
    }

    private FoldObserable() {
        String model = android.os.Build.MODEL;
        if (model.contains(&amp;quot;SM-F9000&amp;quot;)) {
            canFlod = true;
            if (isLargeScreen()) {
                screenType = SCREEN_LARGE;
            } else {
                screenType = SCREEN_SMALL;
            }
        }
    }
    //大屏无statusbar 小屏有statusbar，根据此来判断是是否减bar
    private int screenType;
    private boolean canFlod;

    public static FoldObserable getInstance() {
        return SINGLE.INSTANCE;
    }

    public void setScreenType(int screenType) {
        this.screenType = screenType;
        setChanged();
        notifyObservers();
    }

    public int getScreenType() {
        return screenType;
    }

    /**
     * 是否是折叠屏
     * @return
     */
    public boolean getCanFlod() {
        return canFlod;
    }

    private boolean isLargeScreen() {
        WindowManager wm = (WindowManager) BloodEyeApplication.getInstance().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point pp = new Point();
        display.getSize(pp);
        return pp.x == FoldObserable.SCREEN_LARGE_WIDTH;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为要通过这个单例还通知需要响应切屏事件的页面，所以需要在App的所有Activity基类的onConfigurationChanged中调用setScreenType来通知所有的观察者，这些观察者就是需要相应切屏事件的Activigty和Fragment。代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (FoldObserable.getInstance().getCanFlod()) {
        UiProcessTask.updateScreenSize();
        boolean isLargeScreen = isLargeScreen();
        if (isLargeScreen) {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_LARGE);
        } else {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_SMALL);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将需要响应切屏的页面注册为观察者:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    FoldObserable.getInstance().addObserver(this);
}

@Override
public void onDestroy() {
  super.onDestroy();
  FoldObserable.getInstance().deleteObserver(this);
}

// 处理切屏事件
@Override
public void update(Observable o, Object arg) {
  if (o instanceof FoldObserable) {
      mAdapter.notifyDataSetChanged();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;处理实际的可能因为各种原因导致的适配问题&lt;/h4&gt;

&lt;p&gt;经过模拟器的测试发现App种有很多页面在Fold和Unfold切换后出现适配问题，总结起来有如下几种情况:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码中为了提高测量和绘制View的性能，缓存了屏幕的宽度，导致一些用了屏幕宽度的地方使用了切换前的屏幕宽度的旧值，导致宽度适配错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：在屏幕切换的时候更新缓存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有些没有重建的页面，RecyclerView的Adapter在Fold和Unfold切换以后没有重新回调onBindView，导致Item的大小适配错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法: 在屏幕切换时手动调用Adapter的notifyDataSetChanged()去刷新列表&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布局xml文件中写死了一些控件的宽度，导致适配问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：尽量不要使用写死的值，推荐使用match_parent + margin或padding来应对这种情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在切屏时未能及时更新与界面宽高相关的全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决办法: 在Application的onConfigurationChanged中更新相关变量&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static void updateScreenSize() {

}


// 在Application中调用
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    updateScreenSize();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在适配的过程中具体的问题可能都不一样，但是都跑不出这几类，只要抓住本质，一般都能得到很好的解决。比较麻烦的适配工作可算搞完了，第二天就得到三星跳票的消息，也是服气！&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//sumsung-foldable-adapt</link>
        <guid isPermaLink="true">http://longlinht.github.io//sumsung-foldable-adapt</guid>
      </item>
    
      <item>
        <title>加速Gradle构建</title>
        <description>&lt;p&gt;最近刚换工作，来这家新公司没几天，还在熟悉和适应阶段，leader也没安排什么特别的事情，只是说有空可以看看我们工程Gradle Build速度慢的问题。总算接到一个方向比较明确的任务，正好可以从工程的构建流程入手，可以一窥整个工程的结构和依赖。因为Gradle构建速度慢这个问题，其实有一些常见的排查方法，解决问题第一步，还是用最快的排查法，首先排除一些最常见的造成构建速度缓慢的原因。但是要找出构建速度慢的问题也需要将问题分情况来看，分两种情况，一种是在开发过程中的构建和正式发版上线的构建，这两种构建通常是相同的，但有时为了节约开发过程中的构建时间，会做一些特殊的设置和开启关闭一些选项来加速开发过程中的构建，因此，这两种情况面临的问题其实是类似的，因为还不是很清楚leader更在意的是开发过程中的构建时间还是发布上线的构建，因此我决定把这两种情况合二为一，罗列出所有的加速建议:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查是否使用了最新的Android Gradle Plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然了，这个排查不是硬性的，得看实际情况，但是如果能升到最新的插件版本，建议升级，随着插件的逐步完善，性能也会有很大提升&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;尽量少用Module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有技术博文称Module的构建时间可能是jar和aar的4倍（有待验证）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Property选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在gradle.property文件中添加如下两行代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.configureondemand=true

// 这些值可以按实际情况设置
org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免在 minSdkVersion &amp;lt; 21 时使用Multidex&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Disable Multi-APK(限开发中的构建)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你没有使用ABI或者Density splits， 你可以略过，如果你使用了，可以通过在Gradle文件里添加如下代码关闭这个选项，可以节省开发中的很多构建时间:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android {
   if (project.hasProperty(‘devBuild’)){
      splits.abi.enable = false
      splits.density.enable = false
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;最小化打包资源(限开发中的构建)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在开发过程中，其实没必要打包所有App用到的资源，我们可以通过配置来控制开发构建中要打包的资源, 可在Gradle文件中加入如下代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;productFlavors {
  development {
    minSdkVersion 21
    //only package english translations, and xxhdpi resources   
    resConfigs (“en”, “xxhdpi”)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别小看这点改动，可能节省你很多开发中的构建时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Disable PNG 优化 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PNG优化是默认开启的，但是在开发中的构建没什么必要，建议关闭 :&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android {
  if (project.hasProperty(‘devBuild’)){
    aaptOptions.cruncherEnabled = false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用Instant Run&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然这个功能有时会有一些问题，但是在加速构建方面还是很有用的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免很耗时的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def buildDateTime = new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种代码在开发构建种就不要出现了， 因为每次构建都要重新一次额外的处理和打包，可以改为这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def buildDateTime = project.hasProperty(‘devBuild’) ? 100 : new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个陷阱是Crashlytics build IDs, Crashlytics在每一次构建时都会产生一个新的id，一行代码就可将这个选项关闭:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;apply plugin: ‘io.fabric’
android {
  buildTypes {
    debug {
      ext.alwaysUpdateBuildId = false
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;避免使用动态的依赖版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用动态的依赖版本号会导致Gradle检查新的依赖版本，导致解析时间加长, 严重拖慢构建速度&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开启Gradle Cache&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;org.gradle.caching=true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在将这些建议和排查方法逐一的排查验证了一遍以后，发现这些Tips公司的工程都已采纳，一些坑也都完美的躲过，要想在这种情况下再去加速Gradle的构建速度，可就没那么容易了，必须通过一些方法，细化整个构建过程，找出一些耗时过长的操作，幸运的是，Gradle已经提供了这种功能，可以输出一个Gradle构建的profile报告，只要在苟建时添加一个参数即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew :android:assembleDebug --profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建结束后会在build的子目录下生成一个html文件的报告：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/7033bf1dly1g295fu83jyj20lz0ccabp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;整个报告里面会比较详细的列出构建过程中Configuration，Dependency Resolution， Task Execution的具体耗时，非常详细和直观，有助于分析构建每个阶段的耗时。建议在分析构建过程的时候用起来。我就用这个选项也为公司的工程打了这样一份报告出来，并没有什么特别的发现，主要的耗时还好在app模块。那这样下去还是不能解决问题，因为我们的发布和上线构建是在Jekins上打包，看了打包脚本也并没有太多特殊的地方，于是我想到用Gradle build scan插件来进一步审视构建内部的情况。&lt;/p&gt;

&lt;p&gt;为自己的工程创建build scan其实比较简单，具体步骤如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Project的build.gradle文件添加下面几行代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &amp;#39;com.android.tools.build:gradle:3.0.0&amp;#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

// 这7行是添加的
plugins {
    id &amp;#39;com.gradle.build-scan&amp;#39; version &amp;#39;1.16&amp;#39;
}
buildScan {                     
    licenseAgreementUrl = &amp;#39;https://gradle.com/terms-of-service&amp;#39;
    licenseAgree = &amp;#39;yes&amp;#39;
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在控制台执行命令 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew build --scan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;命令执行完后会给出一个网址，打开网址根据提示就可以得到相应的构建审核内容，如下图:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/7033bf1dly1g297i2yza3j20zh0ff41e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;经过这个插件工具的分析，也仍旧没有发现什么异常，看来公司的工程就是因为太大了，每个版本的自然增长导致当前的构建比很早一个版本的慢，虽然这次的调研没有提升打包速度，但是整个调研的构成让我了解了很多与Gradle有关的东西，也算是收获不少, 没有白忙活。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Mar 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//speed-up-gradle-build</link>
        <guid isPermaLink="true">http://longlinht.github.io//speed-up-gradle-build</guid>
      </item>
    
      <item>
        <title>移动应用中的典型页面</title>
        <description>&lt;p&gt;今天这篇文章不做具体技术细节的探讨，而是来观察诸多移动应用中反复出现，具有典型特征和重要作用的一些页面来一窥一般移动应用的基本结构。这些反复出现的页面原型可以归纳为如下六类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录注册页面 - 但凡有账户系统的业务这种页面就不可或缺&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流式页面(内容，信息流) - 这种页面可能就是App主页，用户可以通过滑动页面中的列表去看到多余一屏的内容&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;详情页面 - 这个页面是对流式页面的补充，可能流式页面展示的信息只是缩略图或者摘要，用户想要看到更多详细的内容就需要跳转至此页面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建页面 - 是App承载的内容的来源页面，用户可通过此页面创建内容和资源&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户主页 - 用户账户信息的详情页&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置页面 - 这个页面几乎是每一个App都会有的，无论你的App有多简单，也是需要这个页面来允许用户对App做出配置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这六种些典型的主要页面以外，还会经常遇到一些扩展的页面，或者说是子页面，包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;闪屏页面(Splash) &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新手引导&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地图视图&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息(聊天)页面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日历&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;媒体播放页面&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有App，无论规模大小，其实都是这些典型页面的组合构建出来的，所以在开发过程中需要注意你所开发的页面是不是这些典型页面中的一种，如果不是，需要你反思这个页面是否需要，设计是否合理。虽然国内一些超级App已经变得非常巨大和复杂，但是也并没有标新立异，超出这些典型页面的范围，一来需要追求用户体验的一致性，二来这种做法已经成了一个大家默认遵守的规范。所以用户在使用不同的App时没有强烈的陌生感，就如同一个会开车的人，换辆其他品牌的车他仍旧会开，并不会产生疏离感。如果细细观察下来，一些扩展页面的情况会很多，但是主要的典型页面应该不会超过如上的六种。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Feb 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//typical-pages-in-mobile-app</link>
        <guid isPermaLink="true">http://longlinht.github.io//typical-pages-in-mobile-app</guid>
      </item>
    
  </channel>
</rss>