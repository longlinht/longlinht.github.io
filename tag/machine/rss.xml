<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>优化App网络连通性问题</title>
	  <link>//connectivity-in-android</link>
	  <author>Tao He</author>
	  <pubDate>2019-05-29T04:20:12+08:00</pubDate>
	  <guid>//connectivity-in-android</guid>
	  <description><![CDATA[
	     <p>最近遇到一个棘手的问题，我们开发的一款App在中东那边出现大量的<code>UnknownHostException</code>, 导致App在中东那边体验很糟，很快这个问题就被抛给了我们技术优化组，我和另外一名同事就开始定位问题的原因并且试图提出一个可行的解决方案。一般理解，出现<code>UnkownHostException</code>就是DNS失败了，在我们开始解决这个问题的时候，App的网络库已逐渐开始使用OkHttp，我们想到自定义DNS过程，在系统DNS失败的情况下再尝试其他DNS方式，降低<code>UnknownHostException</code>出现的频率，优化App网络连通性。
为了实现我们的技术方案，我们针对OkHttp的DNS做了如下几件事:</p>

<ul>
<li>创建OkHttpClient时自定义DNS</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">OkHttpClient.Builder builder = new OkHttpClient.Builder()
    // 实现OKHttp DNS接口, 改变默认的DNS行为
    .dns(OkHttpDns.getInstance())
</code></pre></div>
<p>上面的OkHttpDns须实现Dns接口</p>

<ul>
<li>实现自定义DNS</li>
</ul>

<p>目前我们的设计是使用责任链模式实现四层DNS的lookup: </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Local Cache --&gt; System DNS --&gt; GA --&gt; Google DNS
</code></pre></div>
<p>其中第一层是本地DNS缓存(Local Cache)，整个缓存只是内存缓存，DNS过程开始时，先去本地缓存找，如果在缓存中没有命中，就走系统DNS， 系统DNS如果也失败，整个链条就继续往下，到GA，到Google DNS，如果到Google DNS还没有解析成功，仍旧抛出<code>UnknownHostException</code>，DNS过程失败。基本的代码逻辑如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private OkHttpDns() {

  //使用责任链模式实现四层DNS的lookup: Local Cache --&gt; System DNS --&gt; GA --&gt; Google DNS
  mDnsChain = new CacheDnsHandler();

  SystemDnsHandler okhttp = new SystemDnsHandler();
  GADnsHandler ga = new GADnsHandler();
  GoogleHttpDnsHandler google = new GoogleHttpDnsHandler();

  mDnsChain.setTarget(okhttp);
  okhttp.setTarget(ga);
  ga.setTarget(google);
}

@Override
public List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException {
  // IP直连的情况,直接返回
  if (InetAddressValidator.isIPAddress(hostname)) {
      return Arrays.asList(InetAddress.getAllByName(hostname));
  }

  List&lt;InetAddress&gt; allDNSResult = new ArrayList&lt;&gt;();
  List&lt;InetAddress&gt; list = mDnsChain.lookup(hostname, allDNSResult);

  if (list == null) {

      // DNS完全失败后,清空黑名单,删除local cache相应的条目
      IPStatusCache.getInstance().clear();

      if (allDNSResult.isEmpty()) {
          throw new UnknownHostException(&quot;Broken system behaviour for dns lookup of &quot; + hostname);
      } else {
          return allDNSResult;
      }
  }
  return list;
}
</code></pre></div>
<ul>
<li><p>添加黑名单机制，进一步优化DNS
一次连接成功后缓存DNS结果，host+ip为key，IPStatus为value，连接失败后会更新DNS缓存的失败次数，超过5次则认为进入了黑名单，在每次DNS完全失败后清空本地DNS缓存，防止所有的缓存都进入黑名单，缓存失效。</p></li>
<li><p>处理IP直连的情况
这种情况的处理很简单，检查传入的host是不是ip，如果是就直接返回。</p></li>
</ul>

<p>经过这样的优化以后，<code>UnknownHostException</code>在请求失败中的比重和请求的总失败率大幅下降，验证了我们这个技术方案的合理性，可以说网络连通性大大提高，再次回顾这个方案，突然发现它其实一个通用的解决方案，虽然我们这次解决的是海外，如中东地区的连通性问题，其实这个方案完全可以移植到国内，只要将Google HttpDNS换成国内的HttpDNS即可，整体的DNS流程可以不做任何改动即可成为一个完整的App DNS解决方案。</p>

	  ]]></description>
	</item>

	<item>
	  <title>三星折叠屏适配小计</title>
	  <link>//sumsung-foldable-adapt</link>
	  <author>Tao He</author>
	  <pubDate>2019-04-10T04:20:12+08:00</pubDate>
	  <guid>//sumsung-foldable-adapt</guid>
	  <description><![CDATA[
	     <p>三星要在近期发布折叠屏手机，消息一出，我们就得抓紧做适配，也没有什么现成的经验作参考，尤其令人头疼的是还没有真机供我们测试。没办法，兵来将挡，水来土掩，进过一周多的调研和开发，终于做完了大部分App页面的适配工作，也因为做这个适配的过程踩了很多坑，特写下这篇小记。</p>

<p>在我们开始做适配前，首先要解决没有真机可做测试的问题，无法验证适配的效果，还好三星也想到了这个问题，在官网提供了一个模拟器应用，Foldable Emulator， 通过这个模拟器App可以在Fold和Unfold模式之间自由切换，验证适配效果。当我们适配工作结束后在真机上测试时发现，这个模拟器的仿真度极高，基本没有出现和真机上效果有出入的地方。</p>

<p>在解决了没有真机的问题之后，我们就开始着手真正的适配工作。首先遇到的问题就是折叠屏手机需要在Fold和Unfold之间频繁切换，而这种切换的效果和横竖屏切换是一样的，默认都会导致Activity重建，而Activity重建又会导致一系列的连锁反应，如需要恢复大量数据、重新建立网络连接或执行其他密集操作，因此在适配前就需要规划哪些页面(Activity)需要重建，哪些不需要重建，所以需要按Activity是否重建这两种情况来分析切屏的后果和应对方法。</p>

<ul>
<li>重建Activity</li>
</ul>

<p>因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。 此外，依靠系统通过onSaveInstanceState() 回调保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。当 Android 系统因配置变更而关闭 Activity 时，不会销毁已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。
要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p>

<ul>
<li>扩展 Fragment 类并声明对有状态对象的引用</li>
<li>在创建片段后调用 setRetainInstance(boolean)</li>
<li>将片段添加到 Activity</li>
<li>重启 Activity 后，使用 FragmentManager 检索片段</li>
</ul>

<p>例如，按如下方式定义片段：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class RetainedFragment extends Fragment {

    // 想要保存的数据
    private MyDataObject data;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 保存这个fragment
        setRetainInstance(true);
    }
    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
</code></pre></div>
<p>然后，使用 <code>FragmentManager</code> 将片段添加到 <code>Activity</code>。在运行时配置变更期间再次启动 <code>Activity</code> 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class MyActivity extends Activity {
    private RetainedFragment retainedFragment;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 在activity重启后，获取保留的fragment
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);
        // 首次创建
        if (retainedFragment == null) {
            // 添加fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // 从网络获取data
            retainedFragment.setData(loadMyData());
        }
        // retainedFragment.getData()获取的数据可用
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }
}
</code></pre></div>
<p>onCreate() 添加了一个片段或恢复了对它的引用。此外，onCreate() 还将有状态的对象存储在片段实例内部。</p>

<blockquote>
<p>尽管Fragment内部可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。</p>
</blockquote>

<ul>
<li>不重建Activity</li>
</ul>

<p>如果想不重新启动的情况下处理配置更改，则需要在清单中添加一个android：configChanges属性，例如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;activity
    android:name=&quot;......CMVideoPlayerActivity&quot;
    android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout&quot;
/&gt;
</code></pre></div>
<p>需要手动更新视图布局并在onConfigurationChaged（）中重新加载资源</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public void onConfigurationChanged(Configuration newConfig) {
   super.onConfigurationChanged(newConfig);
   if ((newConfig.screenLayout &amp; Configuration.SCREENLAYOUT_LONG_MASK) == Configuration.SCREENLAYOUT_LONG_YES) {

   }
   if ((newConfig.screenLayout &amp; Configuration.SCREENLAYOUT_LONG_MASK ) == Configuration.SCREENLAYOUT_LONG_NO) {

   }
}
</code></pre></div>
<p>在遵循上述基本原则以后，就要应对实际的适配问题了，整个适配的工作主要涉及以下几个问题的解决:</p>

<h4>检测设备是否可折叠,当前是Fold状态还是Unfold，并且能够在切屏时通知到需要对切屏事件作出处理的页面</h4>

<p>为了统一解决这个问题，设计了一个单例类来统一管理</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class FoldObserable extends Observable {

    public static final int SCREEN_LARGE_WIDTH = 1536;

    public static final int SCREEN_LARGE = 0;
    public static final int SCREEN_SMALL = 1;

    private static class SINGLE {
        public static FoldObserable INSTANCE = new FoldObserable();
    }

    private FoldObserable() {
        String model = android.os.Build.MODEL;
        if (model.contains(&quot;SM-F9000&quot;)) {
            canFlod = true;
            if (isLargeScreen()) {
                screenType = SCREEN_LARGE;
            } else {
                screenType = SCREEN_SMALL;
            }
        }
    }
    //大屏无statusbar 小屏有statusbar，根据此来判断是是否减bar
    private int screenType;
    private boolean canFlod;

    public static FoldObserable getInstance() {
        return SINGLE.INSTANCE;
    }

    public void setScreenType(int screenType) {
        this.screenType = screenType;
        setChanged();
        notifyObservers();
    }

    public int getScreenType() {
        return screenType;
    }

    /**
     * 是否是折叠屏
     * @return
     */
    public boolean getCanFlod() {
        return canFlod;
    }

    private boolean isLargeScreen() {
        WindowManager wm = (WindowManager) BloodEyeApplication.getInstance().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point pp = new Point();
        display.getSize(pp);
        return pp.x == FoldObserable.SCREEN_LARGE_WIDTH;
    }
}
</code></pre></div>
<p>因为要通过这个单例还通知需要响应切屏事件的页面，所以需要在App的所有Activity基类的onConfigurationChanged中调用setScreenType来通知所有的观察者，这些观察者就是需要相应切屏事件的Activigty和Fragment。代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (FoldObserable.getInstance().getCanFlod()) {
        UiProcessTask.updateScreenSize();
        boolean isLargeScreen = isLargeScreen();
        if (isLargeScreen) {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_LARGE);
        } else {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_SMALL);
        }
    }
}
</code></pre></div>
<p>将需要响应切屏的页面注册为观察者:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    FoldObserable.getInstance().addObserver(this);
}

@Override
public void onDestroy() {
  super.onDestroy();
  FoldObserable.getInstance().deleteObserver(this);
}

// 处理切屏事件
@Override
public void update(Observable o, Object arg) {
  if (o instanceof FoldObserable) {
      mAdapter.notifyDataSetChanged();
  }
}
</code></pre></div>
<h4>处理实际的可能因为各种原因导致的适配问题</h4>

<p>经过模拟器的测试发现App种有很多页面在Fold和Unfold切换后出现适配问题，总结起来有如下几种情况:</p>

<ul>
<li>代码中为了提高测量和绘制View的性能，缓存了屏幕的宽度，导致一些用了屏幕宽度的地方使用了切换前的屏幕宽度的旧值，导致宽度适配错误。</li>
</ul>

<p>解决方法：在屏幕切换的时候更新缓存</p>

<ul>
<li>有些没有重建的页面，RecyclerView的Adapter在Fold和Unfold切换以后没有重新回调onBindView，导致Item的大小适配错误。</li>
</ul>

<p>解决方法: 在屏幕切换时手动调用Adapter的notifyDataSetChanged()去刷新列表</p>

<ul>
<li>布局xml文件中写死了一些控件的宽度，导致适配问题</li>
</ul>

<p>解决方法：尽量不要使用写死的值，推荐使用match_parent + margin或padding来应对这种情况</p>

<ul>
<li>在切屏时未能及时更新与界面宽高相关的全局变量</li>
</ul>

<p>解决办法: 在Application的onConfigurationChanged中更新相关变量</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static void updateScreenSize() {

}


// 在Application中调用
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    updateScreenSize();
}
</code></pre></div>
<p>在适配的过程中具体的问题可能都不一样，但是都跑不出这几类，只要抓住本质，一般都能得到很好的解决。比较麻烦的适配工作可算搞完了，第二天就得到三星跳票的消息，也是服气！</p>

	  ]]></description>
	</item>

	<item>
	  <title>加速Gradle构建</title>
	  <link>//speed-up-gradle-build</link>
	  <author>Tao He</author>
	  <pubDate>2019-03-10T04:20:12+08:00</pubDate>
	  <guid>//speed-up-gradle-build</guid>
	  <description><![CDATA[
	     <p>最近刚换工作，来这家新公司没几天，还在熟悉和适应阶段，leader也没安排什么特别的事情，只是说有空可以看看我们工程Gradle Build速度慢的问题。总算接到一个方向比较明确的任务，正好可以从工程的构建流程入手，可以一窥整个工程的结构和依赖。因为Gradle构建速度慢这个问题，其实有一些常见的排查方法，解决问题第一步，还是用最快的排查法，首先排除一些最常见的造成构建速度缓慢的原因。但是要找出构建速度慢的问题也需要将问题分情况来看，分两种情况，一种是在开发过程中的构建和正式发版上线的构建，这两种构建通常是相同的，但有时为了节约开发过程中的构建时间，会做一些特殊的设置和开启关闭一些选项来加速开发过程中的构建，因此，这两种情况面临的问题其实是类似的，因为还不是很清楚leader更在意的是开发过程中的构建时间还是发布上线的构建，因此我决定把这两种情况合二为一，罗列出所有的加速建议:</p>

<ul>
<li>检查是否使用了最新的Android Gradle Plugin</li>
</ul>

<p>当然了，这个排查不是硬性的，得看实际情况，但是如果能升到最新的插件版本，建议升级，随着插件的逐步完善，性能也会有很大提升</p>

<ul>
<li>尽量少用Module</li>
</ul>

<p>有技术博文称Module的构建时间可能是jar和aar的4倍（有待验证）</p>

<ul>
<li>使用Property选项</li>
</ul>

<p>在gradle.property文件中添加如下两行代码：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.configureondemand=true

// 这些值可以按实际情况设置
org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
</code></pre></div>
<ul>
<li><p>避免在 minSdkVersion &lt; 21 时使用Multidex</p></li>
<li><p>Disable Multi-APK(限开发中的构建)</p></li>
</ul>

<p>如果你没有使用ABI或者Density splits， 你可以略过，如果你使用了，可以通过在Gradle文件里添加如下代码关闭这个选项，可以节省开发中的很多构建时间:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">android {
   if (project.hasProperty(‘devBuild’)){
      splits.abi.enable = false
      splits.density.enable = false
   }
}
</code></pre></div>
<ul>
<li>最小化打包资源(限开发中的构建)</li>
</ul>

<p>在开发过程中，其实没必要打包所有App用到的资源，我们可以通过配置来控制开发构建中要打包的资源, 可在Gradle文件中加入如下代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">productFlavors {
  development {
    minSdkVersion 21
    //only package english translations, and xxhdpi resources   
    resConfigs (“en”, “xxhdpi”)
  }
}
</code></pre></div>
<p>别小看这点改动，可能节省你很多开发中的构建时间</p>

<ul>
<li>Disable PNG 优化 </li>
</ul>

<p>PNG优化是默认开启的，但是在开发中的构建没什么必要，建议关闭 :</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">android {
  if (project.hasProperty(‘devBuild’)){
    aaptOptions.cruncherEnabled = false
  }
}
</code></pre></div>
<ul>
<li>使用Instant Run</li>
</ul>

<p>虽然这个功能有时会有一些问题，但是在加速构建方面还是很有用的</p>

<ul>
<li>避免很耗时的计算</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">def buildDateTime = new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
</code></pre></div>
<p>这种代码在开发构建种就不要出现了， 因为每次构建都要重新一次额外的处理和打包，可以改为这样:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def buildDateTime = project.hasProperty(‘devBuild’) ? 100 : new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
</code></pre></div>
<p>还有一个陷阱是Crashlytics build IDs, Crashlytics在每一次构建时都会产生一个新的id，一行代码就可将这个选项关闭:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">apply plugin: ‘io.fabric’
android {
  buildTypes {
    debug {
      ext.alwaysUpdateBuildId = false
    }
  }
}
</code></pre></div>
<ul>
<li>避免使用动态的依赖版本号</li>
</ul>

<p>使用动态的依赖版本号会导致Gradle检查新的依赖版本，导致解析时间加长, 严重拖慢构建速度</p>

<ul>
<li>开启Gradle Cache</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">org.gradle.caching=true
</code></pre></div>
<p>在将这些建议和排查方法逐一的排查验证了一遍以后，发现这些Tips公司的工程都已采纳，一些坑也都完美的躲过，要想在这种情况下再去加速Gradle的构建速度，可就没那么容易了，必须通过一些方法，细化整个构建过程，找出一些耗时过长的操作，幸运的是，Gradle已经提供了这种功能，可以输出一个Gradle构建的profile报告，只要在苟建时添加一个参数即可。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">./gradlew :android:assembleDebug --profile
</code></pre></div>
<p>构建结束后会在build的子目录下生成一个html文件的报告：</p>

<p><img src="https://wx2.sinaimg.cn/mw690/7033bf1dly1g295fu83jyj20lz0ccabp.jpg" alt=""></p>

<p>整个报告里面会比较详细的列出构建过程中Configuration，Dependency Resolution， Task Execution的具体耗时，非常详细和直观，有助于分析构建每个阶段的耗时。建议在分析构建过程的时候用起来。我就用这个选项也为公司的工程打了这样一份报告出来，并没有什么特别的发现，主要的耗时还好在app模块。那这样下去还是不能解决问题，因为我们的发布和上线构建是在Jekins上打包，看了打包脚本也并没有太多特殊的地方，于是我想到用Gradle build scan插件来进一步审视构建内部的情况。</p>

<p>为自己的工程创建build scan其实比较简单，具体步骤如下:</p>

<ol>
<li>在Project的build.gradle文件添加下面几行代码：</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.0.0&#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

// 这7行是添加的
plugins {
    id &#39;com.gradle.build-scan&#39; version &#39;1.16&#39;
}
buildScan {                     
    licenseAgreementUrl = &#39;https://gradle.com/terms-of-service&#39;
    licenseAgree = &#39;yes&#39;
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}
</code></pre></div>
<ol>
<li>在控制台执行命令 </li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">./gradlew build --scan
</code></pre></div>
<ol>
<li>命令执行完后会给出一个网址，打开网址根据提示就可以得到相应的构建审核内容，如下图:</li>
</ol>

<p><img src="https://wx1.sinaimg.cn/mw690/7033bf1dly1g297i2yza3j20zh0ff41e.jpg" alt=""></p>

<p>经过这个插件工具的分析，也仍旧没有发现什么异常，看来公司的工程就是因为太大了，每个版本的自然增长导致当前的构建比很早一个版本的慢，虽然这次的调研没有提升打包速度，但是整个调研的构成让我了解了很多与Gradle有关的东西，也算是收获不少, 没有白忙活。</p>

	  ]]></description>
	</item>

	<item>
	  <title>移动应用中的典型页面</title>
	  <link>//typical-pages-in-mobile-app</link>
	  <author>Tao He</author>
	  <pubDate>2019-02-19T04:20:12+08:00</pubDate>
	  <guid>//typical-pages-in-mobile-app</guid>
	  <description><![CDATA[
	     <p>今天这篇文章不做具体技术细节的探讨，而是来观察诸多移动应用中反复出现，具有典型特征和重要作用的一些页面来一窥一般移动应用的基本结构。这些反复出现的页面原型可以归纳为如下六类:</p>

<ul>
<li><p>登录注册页面 - 但凡有账户系统的业务这种页面就不可或缺</p></li>
<li><p>流式页面(内容，信息流) - 这种页面可能就是App主页，用户可以通过滑动页面中的列表去看到多余一屏的内容</p></li>
<li><p>详情页面 - 这个页面是对流式页面的补充，可能流式页面展示的信息只是缩略图或者摘要，用户想要看到更多详细的内容就需要跳转至此页面</p></li>
<li><p>创建页面 - 是App承载的内容的来源页面，用户可通过此页面创建内容和资源</p></li>
<li><p>用户主页 - 用户账户信息的详情页</p></li>
<li><p>设置页面 - 这个页面几乎是每一个App都会有的，无论你的App有多简单，也是需要这个页面来允许用户对App做出配置</p></li>
</ul>

<p>除了这六种些典型的主要页面以外，还会经常遇到一些扩展的页面，或者说是子页面，包括:</p>

<ul>
<li><p>闪屏页面(Splash) </p></li>
<li><p>新手引导</p></li>
<li><p>地图视图</p></li>
<li><p>消息(聊天)页面</p></li>
<li><p>日历</p></li>
<li><p>媒体播放页面</p></li>
</ul>

<p>所有App，无论规模大小，其实都是这些典型页面的组合构建出来的，所以在开发过程中需要注意你所开发的页面是不是这些典型页面中的一种，如果不是，需要你反思这个页面是否需要，设计是否合理。虽然国内一些超级App已经变得非常巨大和复杂，但是也并没有标新立异，超出这些典型页面的范围，一来需要追求用户体验的一致性，二来这种做法已经成了一个大家默认遵守的规范。所以用户在使用不同的App时没有强烈的陌生感，就如同一个会开车的人，换辆其他品牌的车他仍旧会开，并不会产生疏离感。如果细细观察下来，一些扩展页面的情况会很多，但是主要的典型页面应该不会超过如上的六种。</p>

	  ]]></description>
	</item>

	<item>
	  <title>解决ScrollView内容显示不全</title>
	  <link>//scrollview-can-not-display-whole-content</link>
	  <author>Tao He</author>
	  <pubDate>2018-12-05T04:20:12+08:00</pubDate>
	  <guid>//scrollview-can-not-display-whole-content</guid>
	  <description><![CDATA[
	     <p>这个问题其实只要使用过<code>ScrollView</code>，可能都有机会遇到，问题的表现就是<code>ScrollView</code>包裹内容的高度超过<code>ScrollView</code>可视高度的话，被包裹的内容就会显示不全，最底部的内容永远也看不到了，这种情况肯定是无法接受的， 解决这个问题比较简单，其实就是简单的一句设置语句:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">android:fillViewport=&quot;true&quot;
</code></pre></div>
<p>虽然这样可以解决问题，但是还是心中还有疑惑，我放在<code>ScrollView</code>中的<code>LinearLayout</code>是的高度是设置了<code>mactch_parent</code> 属性的，现在看来并没有生效，我猜测可能是<code>ScrollView</code>重写了测量方法导致的，于是去看<code>ScrollView</code>的<code>onMeasure</code> 方法:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
  super.onMeasure(widthMeasureSpec, heightMeasureSpec);

  if (!mFillViewport) {
      return;
  }

  final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
  if (heightMode == MeasureSpec.UNSPECIFIED) {
      return;
  }

  if (getChildCount() &gt; 0) {
      final View child = getChildAt(0);
      final int widthPadding;
      final int heightPadding;
      final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
      final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
      if (targetSdkVersion &gt;= VERSION_CODES.M) {
          widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
          heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
      } else {
          widthPadding = mPaddingLeft + mPaddingRight;
          heightPadding = mPaddingTop + mPaddingBottom;
      }

      final int desiredHeight = getMeasuredHeight() - heightPadding;
      if (child.getMeasuredHeight() &lt; desiredHeight) {
          final int childWidthMeasureSpec = getChildMeasureSpec(
                  widthMeasureSpec, widthPadding, lp.width);
          final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                  desiredHeight, MeasureSpec.EXACTLY);
          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
      }
  }
}
</code></pre></div>
<p>很明显，在没有设置fillViewport属性为true时，<code>ScrollView</code>并没有去测量子View的高度，这就导致超过一屏内容的<code>View</code>的高度无法正确测量。解决了这个问题以后PM又提了一个底部内容有一部分被遮挡，滑不出的问题，布局代码是这样的:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;ScrollView
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:fillViewport=&quot;true&quot;
    android:layout_below=&quot;@id/tv_title&quot;
    android:layout_marginBottom=&quot;84dp&quot;
    &gt;

  &lt;com.zhy.view.flowlayout.TagFlowLayout
      android:id=&quot;@+id/tfl_label&quot;
      zhy:max_select=&quot;-1&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_marginTop=&quot;14dp&quot;
      android:layout_marginStart=&quot;12dp&quot;
      android:layout_marginEnd=&quot;12dp&quot;
      &gt;
  &lt;/com.zhy.view.flowlayout.TagFlowLayout&gt;

&lt;/ScrollView&gt;
</code></pre></div>
<p>看了代码后发现被遮挡区域的高度差不多就是这个<code>TagFlowLayout</code>的<code>layout_marginTop</code>的值，当我去掉这个属性的设置后，遮挡的问题没有了，换作<code>paddingTop</code>后也没有问题，就是不能用<code>marginTop</code>，好吧，这个<code>ScrollView</code>的默认设定也是很奇葩啊！</p>

	  ]]></description>
	</item>

	<item>
	  <title>解决闹人的can not found symbol BR问题</title>
	  <link>//br-not-found</link>
	  <author>Tao He</author>
	  <pubDate>2018-12-03T04:20:12+08:00</pubDate>
	  <guid>//br-not-found</guid>
	  <description><![CDATA[
	     <p>最近公司研发的这个App是我从零到一搭建的，在框架搭建时分别使用了Databinding和Room，今天在做新需求时需要向Room中的实体类新添加一个字段，在写完了所有相关的逻辑后，build工程，所有自动生成的Databinding类都报错，build log中并没有指向任何具体报错的Databinding类，这就令人很困惑，因为这个需求的添加并没有改动任何Databinding的类，在不知所以的情况下，那就尝试其他方法解决，之前我在一个技术博客上看到过一个Databinding类的Troubleshooting: </p>

<p><strong>Troubleshooting the Issues with Binding Class</strong></p>

<ul>
<li><p>Make sure you have the proper dataBinding.enabled = true in gradle and trigger &quot;Sync with Gradle&quot;</p></li>
<li><p>Open the layout file and ensure that the XML file is valid and is wrapped in a <layout> tag.</p></li>
<li><p>Check the layout file for the correct name i.e activity_main.xml maps to ActivityMainBinding.java.</p></li>
<li><p>Run File =&gt; Invalidate Caches  Restart to clear the caches.</p></li>
<li><p>Run Project =&gt; Clean and Project =&gt; Re-Build to regenerate the class file.</p></li>
<li><p>Restart Android Studio again and then try the above steps again.</p></li>
</ul>

<p>对这几条Troubleshooting依次尝试后，报错依旧，这就非常恼人，然后我又怀疑是不是build log打印的信息不全，导致跑偏了定位问题的方向，因此在project Gradle中更改了错误信息的条数:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">allprojects {
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs &lt;&lt; &quot;-Xmaxerrs&quot; &lt;&lt; &quot;4000&quot;
            options.compilerArgs &lt;&lt; &quot;-Xmaxwarns&quot; &lt;&lt; &quot;4000&quot;
        }
    }
}
</code></pre></div>
<p>在打印更多错误信息以后，仍旧看不出错误的源头在哪里。排查到这一步，可能就需要最笨的办法了，倒推法，在依次回退了可能导致这个错误的代码后，算是定位到了出错的修改， 就是Room的实体类添加了一个新的字段导致的，这就很奇怪，添加一个字段不是非常正常的操作吗？就算添加的字段不符合规范，那也应该是Room报错，关Databinding什么事，一开始真是一头雾水，但是我猜想可能是Room和Databinding这两类组件都自动生成了很多代码，在生成Room代码的时候的出错导致Databinding类生成失败，所以编译时表现为Databinding类找不到，这下问题变得清晰起来，问题的源头应该还是Room导致的，最后发现其实就是一个小的细节导致的，在给Room实体类添加字段的时候是private的，但是并没有提供getter和setter方法，因此导致编译失败，只是错误的表现误导了我的思路。白白浪费了几个小时排查这种因为违反了组件使用规范的问题，以后必须引以为戒，再次重申这个恼人的细节:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Entity(tableName = &quot;messages&quot;)
public class ChatMessageEntity {

    @NonNull
    @PrimaryKey(autoGenerate = true)
    //common field
    private int id;

    @SerializedName(&quot;title&quot;)
    private String title;

    @NonNull
    public int getId() {
        return id;
    }

    public void setId(@NonNull int id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}
</code></pre></div>
<ul>
<li><p>被注解为Entity的实体类添加字段，如果是private的必须提供getter和setter方法，或者修饰为public的</p></li>
<li><p>如果违反了这个规则，变异错误信息不一定会指向这个错误</p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>记一次看似困难的Debug</title>
	  <link>//record-a-debug-process</link>
	  <author>Tao He</author>
	  <pubDate>2018-11-30T04:20:12+08:00</pubDate>
	  <guid>//record-a-debug-process</guid>
	  <description><![CDATA[
	     <p>今年把自己的手机换成了Android，拿到新机后就想找到一款手写笔记的App，因为在iOS用过一款体验很好，还用那个写了一篇游记，在试用了十几款此类的Andorid App后最终找到了一款名为INKredible的手写笔记App，刚开始用的时候很不顺手，都想卸载了，但是经过一番摸索后找到了技巧，再去试用后有一种惊艳的感觉，今天在地铁通勤的时候竟然用它谢了一篇技术博文，并已图片的形式到了出来，全文如下:(字迹潦草，读者莫怪，其实如果以正楷的形式书写, 效率较差，体验会大打折扣).</p>

<p><img src="https://wx3.sinaimg.cn/mw690/7033bf1dly1g0aqh53p3dj20m80zkdlh.jpg" alt=""></p>

	  ]]></description>
	</item>

	<item>
	  <title>使用VideoView实现视频开屏页</title>
	  <link>//play-video-in-raw-folder</link>
	  <author>Tao He</author>
	  <pubDate>2018-11-28T01:20:12+08:00</pubDate>
	  <guid>//play-video-in-raw-folder</guid>
	  <description><![CDATA[
	     <p>今天PM提了一个视频开屏页的需求，需要在用户第一次使用时播放一个开屏视频，乍一看，挺简单一需求，但是也或多或少碰到了一些坑，也发现了Android资源编译的一个问题，本着研发之事无小事的原则，还是要记录下踩坑经验和发现的问题。整个实现过程一共两三个小时，逐步解决了以下问题:</p>

<h4>视频全屏</h4>

<p>看到这个问题的第一反应就是把<code>VideoView</code> 的宽高设置为<code>match_parent</code>, 并且保证父容器也是<code>match_parent</code> 根布局, 但是事实没那么简单，视频播放后并没有完全全屏，在我的开发机上视频底部有一条细细的白边，很明显视频没有完全全屏。后来又想到设置<code>MediaPlayer</code>的视频缩放模式:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mPlayer.setVideoScalingMode(MediaPlayer.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);
</code></pre></div>
<p>设置了两种模式以后都没有效果，这说明<code>VideoView</code>本身没有全屏，没有铺满整个屏幕，所以需要根据屏幕大小动态设置<code>VideoView</code>的尺寸，所以用自定义View实现。
自定义一个继承自<code>VideoView</code>的类来满足要求，具体实现如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class FullScreenVideoView extends VideoView {
    public FullScreenVideoView(Context context) {
        super(context);
    }

    public FullScreenVideoView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public FullScreenVideoView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = getDefaultSize(0, widthMeasureSpec);
        int height = getDefaultSize(0, heightMeasureSpec);
        setMeasuredDimension(width, height);
    }
}
</code></pre></div>
<p>这样比较顺利的实现了全屏，接下来需要解决第二个问题:</p>

<h4>循环播放</h4>

<p>这个比较容易，几乎就是一行代码，是对播放器的设置:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mBinding.vvSplash.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
    @Override
    public void onPrepared(MediaPlayer mp) {
        mPlayer = mp;
        mPlayer.setLooping(true);
        mPlayer.setVideoScalingMode(MediaPlayer.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);
        mPlayer.start();

        mPlayer.setVideoScalingMode();
    }
});
</code></pre></div>
<p>第三个问题:</p>

<h4>音量切换</h4>

<p>这个问题也比较简单，主要是对播放器的操作，虽然简单但是需要注意以下几个问题:</p>

<ul>
<li>要保证操作的播放器一直是同一个</li>
<li>调用setVolume以后不需要再调用start</li>
<li>恢复音量时最好的方式是通过系统服务(AudioManager)去获取当前音量，但是这个需求只要设置为1就可以了</li>
</ul>

<p>到此，问题都逐一解决了，最后需要记录下一个Android资源编译的问题，问题如下:</p>

<blockquote>
<p>我的工程目录res/drawable下有一个图片文件名为splash.png，开屏视频的MP4文件在res/raw下，名为splash.mp4，编译工程运行后一直报错：
<code>无法播放此视频</code></p>
</blockquote>

<p>当时还以为我代码哪里写错了，检查发现没有错误，后来怀疑路径是不是错了，但断点调试也没问题，就很纳闷，后来拷贝了其它视频播放，发现是正常的，我才想到可能是资源文件名字冲突了，我给开屏视频文件重命名以后一切OK了，冲突在编译期间竟然没有报错，感觉有点坑，这样看来Android在编译资源时并没有区分res/drawable目录和res/raw目录，这个问题需要重视起来，不然会比较恼人。</p>

	  ]]></description>
	</item>

	<item>
	  <title>MultidexApplication相关的一个crash</title>
	  <link>//multidex-application-crash</link>
	  <author>Tao He</author>
	  <pubDate>2018-11-26T04:20:12+08:00</pubDate>
	  <guid>//multidex-application-crash</guid>
	  <description><![CDATA[
	     <p>最近在内测的一个App在内测开始后有用户反馈启动就crash的问题，后来拿到用户的信息后发现几个crash的机器都是4.4的机器，因为现在真实用户使用4.4系统的用户真的是不多了，就没怎么在意，但是在阿里云移动测试平台进行兼容性测试的时候，这个问题必现，并且都出现在4.4的机器上，查看兼容性测试报告，都是同一个crash，崩溃的堆栈记录了下来:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">FATAL EXCEPTION: main Process: com.ross.android, PID: 9282 java.lang.RuntimeException: Unable to get provider com.readystatesoftware.chuck.internal.data.ChuckContentProvider: 
java.lang.ClassNotFoundException: Didn&#39;t find class &quot;com.readystatesoftware.chuck.internal.data.ChuckContentProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.ross.android-1.apk&quot;],nativeLibraryDirectories=[/data/app-lib/com.ross.android-1, /vendor/lib, /system/lib]] 
at android.app.ActivityThread.installProvider(ActivityThread.java:5060) 
at android.app.ActivityThread.installContentProviders(ActivityThread.java:4631) 
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4571) 
at android.app.ActivityThread.access$1500(ActivityThread.java:155) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1406) 
at android.os.Handler.dispatchMessage(Handler.java:110) 
at android.os.Looper.loop(Looper.java:193)
at android.app.ActivityThread.main(ActivityThread.java:5341) 
at java.lang.reflect.Method.invokeNative(Native Method) 
at java.lang.reflect.Method.invoke(Method.java:515) 
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:830) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:646) 
at dalvik.system.NativeStart.main(Native Method) Caused by: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;com.readystatesoftware.chuck.internal.data.ChuckContentProvider&quot; on path: DexPathList[[zip file &quot;/data/app/com.ross.android-1.apk&quot;],nativeLibraryDirectories=[/data/app-lib/com.ross.android-1, /vendor/lib, /system/lib]] at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56) 
at java.lang.ClassLoader.loadClass(ClassLoader.java:497) 
at java.lang.ClassLoader.loadClass(ClassLoader.java:457)
at android.app.ActivityThread.installProvider(ActivityThread.java:5045) 
at android.app.ActivityThread.installContentProviders(ActivityThread.java:4631)
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4571) 
at android.app.ActivityThread.access$1500(ActivityThread.java:155) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1406) 
at android.os.Handler.dispatchMessage(Handler.java:110) 
at android.os.Looper.loop(Looper.java:193) 
at android.app.ActivityThread.main(ActivityThread.java:5341) 
at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:515)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:830) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:646) 
at dalvik.system.NativeStart.main(Native Method)
</code></pre></div>
<p>看到这个崩溃的记录后，赶紧去查看到了build.gradle中multiDexEnabled选项，果然是true，处于打开状态，然后看了本App的Application竟然并没有继承自<code>MultiDexApplication</code>，在<code>Application</code>的onCreate的方法中也没有调用<code>MultiDex.install(this)</code>, 这也就难怪在4.4中出现这个崩溃了，因为貌似这个崩溃只出现在 api&lt;21 的情况下, 因为我平时的开发机都是8.0的系统，所以这个问题一直没有暴露出来, 直到将这个App安装在用户的机器上，崩溃出现了，这个问题解决起来其实很简单，要么将本App的Application继承自<code>MultiDexApplication</code>, 要么在Application中的onCreate中调用<code>MultiDex.install(this)</code>。就是这么简单,那这么简单的一个问题为什么要专写一篇来记录呢？其实也是因为这次这个内测阶段的crash的问题很典型，它就是在开发工程中被忽略，或者现有环境没有覆盖到，导致崩溃出现在了用户的机器上，其实这类问题是可以在发布版本前就能避免的，算是一次很好的教训。 解决方案再明确下:</p>

<ul>
<li>方法一 </li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">TestApplcation extends MultiDexApplication {


}
</code></pre></div>
<ul>
<li>方法二</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">TestApplcation extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        MultiDex.install(this);
    }

}
</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>读《1984》</title>
	  <link>//reading-1984</link>
	  <author>Tao He</author>
	  <pubDate>2018-07-16T02:20:12+08:00</pubDate>
	  <guid>//reading-1984</guid>
	  <description><![CDATA[
	     <p>1984应该是我读的第一本英文原版小说，我其实不太喜欢看小说，汉语的我也很少看，但竟然每天在地铁上看，一个月下来竟然看完了，期间总会遇到生词，看不懂的长句，但竟然读出了惊叹，大有拍案叫绝的冲动，感受得到人物的绝望，恐惧，第一次，读着非母语写成的文字，生出了喟叹，感动。这些英文单词变得不那么疏离，它所描绘的情景人物变得栩栩如生，人物的落寞与心死都可透出纸面，感染到我。也许好的文字无论用什么语言表达都能直直抵人心吧！</p>

<p>有一些段落我在读的过程中记录了下来，现摘录如下：</p>

<p>BIG BROTHER IS WATCHING YOU</p>

<p>The telescreen received and transmitted simultaneously. Any sound that Winston made, above the level of a very low whisper, would be picked up by it, moreover, so long as he remained within the field of vision which the metal plaque commanded, he could be seen as well as heard. There was of course no way of knowing whether you were being watched at any given moment. How often, or on what system, the Thought Police plugged in on any individual wire was guesswork. It was even conceivable that they watched everybody all the time. But at any rate they could plug in your wire whenever they wanted to. You had to live—did live, from habit that became instinct—in the assumption that every sound you made was overheard, and, except in darkness, every movement scrutinized.</p>

<p>WAR IS PEACE
FREEDOM IS SLAVERY 
IGNORANCE IS STRENGTH</p>

<p>This was not illegal ( nothing was illegal, since there were no longer any laws), but if detected it was reasonably certain that it would be punished by death, or at least by twenty-five years in a forced-labor camp.</p>

<p>The horrible thing about the Two Minutes Hate was not that one was obliged to act a part, but, on the contrary,that it was impossible to avoid joining in. Within thirty seconds any pretence was always unnecessary. A hideous ecstasy of fear and vindictiveness, a desire to kill, to torture, to smash faces in with a sledge-hammer, seemed to flow through the whole group of people like an electric current, turning one even against one&#39;s will into a grimacing, screaming lunatic. And yet the rage that one felt was an abstract, undirected emotion which could be switched from one object to another like the flame of a blow lamp. </p>

<p>Nearly all children nowadays were horrible.What was worst of all was that by means of such organizations as the Spies they were systematically turned into ungovernable little savages, and yet this produced in them no tendency whatever to rebel against the discipline of the Party. On the contrary, they adored the Party and everything connected with it. The songs, the processions, the banners, the hiking, the drilling with dummy rifles, the yelling of slogans, the worship of Big Brother--it was all a sort of glorious game to them. All their ferocity was turned outwards, against the enemies of the State, against foreigners, traitors, saboteurs, thought-criminals. It was almost normal for people over thirty to be frightened of their own children. And with good reason, for hardly a week passed in which The Times did not carry a paragraph describing how some eavesdropping little sneak -- &quot;child hero&quot; was the phrase generally used — had overheardsome compromising remark and denounced its parents to the Thought Police.</p>

<p>Years ago — how long was it? Seven years it must be — he had dreamed that he was walking through a pitch-dark room. And someone sitting to one side of him had said as he passed: &quot;We shall meet in the place where there is no darkness.&quot; It was said very quietly, almost casually — a statement, not a command. He had walked on without pausing. What was curious was that at the time, in the dream, the words had not made much impression on him. It was only later and by degrees that they had seemed to take on significance. He could not now remember whether it was before or after having the dream that he had seen O&#39;Brien for the first time, nor could he remember when he had first identified the voice as O&#39;Brien&#39;s. But at any rate the identification existed. It was O&#39;Brien who had spoken to him out of the dark.
Winston had never been able to feel sure — even after this morning&#39;s flash of the eyes it was still impossible to be sure whether O&#39;Brien was a friend or an enemy. Nor did it even seem to matter greatly. There was a link of understanding between them, more important than affection or partisanship.&quot;We shall meet in the place where there is no darkness,&quot; he had said. Winston did not know what it meant, only that in some way or another it would come true.</p>

<p>It was always at night. The arrests invariably happened at night. The sudden jerk out of sleep, the rough hand shaking your shoulder, the lights glaring in your eyes, the ring of hard faces round the bed. In the vast majority of cases there was no trial, no report of the arrest. People simply disappeared, always during the night. Your name was removed from the registers, every record of everything you had ever done was wiped out, your one-time existence was denied and then forgotten. You were abolished, annihilated: vaporized was the usual word. </p>

<p>Thoughtcrime does not entail death: thoughtcrime IS death. </p>

<p>Tragedy,he perceived,belonged to the ancient time,to a time when there were still privacy,love and friendship,and when the members of a family stood by one another without needing to know the reason.</p>

<p>Who controls the past controls the future, who controls the present controls the past.</p>

<p>“Don&#39;t you see that the whole aim of Newspeak is to narrow the range of thought?In the end we shall make thought-crime literally impossible, beacuse there will be no words in which to express it. Every concept that can ever be needed will be expressed by exactly one word, with its meaning rigidly defined and all its subsidiary meanings rubbed out and forgotten. Already,in the Eleventh Edition, we&#39;re not far from that point. But the process will still be continuing long after you and I are dead. Every year fewer and fewer words,and the range of consciousness always alittle smaller. Even now, of course there&#39;s no reason or excuse for committing thought-crime. It&#39;s merely a question of self-discipline, reality-control. But in the end there won&#39;t be any need even for that. The Revolution will be complete when the language is perfect. Nespeak is Ingsoc and Ingsoc is Newspeak,” he added with a sort of mystical satisfaction. &quot;Has it ever occurred to you, Winston, that by the year2050, at the very latest, not a single human being will be alive who could understant such a conversation as we are having now?&quot;</p>

<p>In some ways she was far more acute than Winston, and far less susceptible to Party propaganda. Once when he happened in some connexion to mention the war against Eurasia, she startled him by saying casually that in her opinion the war was not happening. The rocket bombs which fell daily on London were probably fired by the Government of Oceania itself, “just to keep people frightened”. </p>

<p>&#39;You&#39;re only a rebel from the waist downwards,&#39; he told her.</p>

<p>Throughout recorded time, and probably since the end of the Neolithic Age, there have been three kinds of people in the world, the High, the Middle, and the Low. They have been subdivided in many ways, they have borne countless different names, and their relative numbers, as well as their attitude towards one another, have varied from age to age: but the essential structure of society has never altered. Even after enormous upheavals and seemingly irrevocable changes, the same pattern has always reasserted itself, just as a gyroscope will always return to equilibrium, however far it is pushed one way or the other.</p>

<p>In one combination or another, these three super-states are permanently at war, and have been so for the past twenty-five years. War, however, is no longer the desperate, annihilating struggle that it was in the early decades of the twentieth century. It is a warfare of limited aims between combatants who are unable to destroy one another, have no material cause for fighting and are not divided by any genuine ideological difference This is not to say that either the conduct of war, or the prevailing attitude towards it, has become less bloodthirsty or more chivalrous. On the contrary, war hysteria is continuous and universal in all countries, and such acts as raping, looting, the slaughter of children, the reduction of whole populations to slavery, and reprisals against prisoners which extend even to boiling and burying alive, are looked upon as normal, and, when they are committed by one&#39;s own side and not by the enemy, meritorious. But in a physical sense war involves very small numbers of people, mostly highly-trained specialists, and causes comparatively few casualties. The fighting, when there is any, takes place on the vague frontiers whose whereabouts the average man can only guess at, or round the Floating Fortresses which guard strategic spots on the sea lanes. In the centres of civilization war means no more than a continuous shortage of consumption goods, and the occasional crash of a rocket bomb which may cause a few scores of deaths. War has in fact changed its character. </p>

<p>The war, therefore, if we judge it by the standards of previous wars, is merely an imposture. It is like the battles between certain ruminant animals whose horns are set at such an angle that they are incapable of hurting one another. But though it is unreal it is not meaningless. It eats up the surplus of consumable goods, and it helps to preserve the special mental atmosphere that a hierarchical society needs. War, it will be seen, is now a purely internal affair. In the past, the ruling groups of all countries, although they might recognize their common interest and therefore limit the destructiveness of war, did fight against one another, and the victor always plundered the vanquished. In our own day they are not fighting against one another at all. The war is waged by each ruling group against its own subjects, and the object of the war is not to make or prevent conquests of territory, but to keep the structure of society intact. The very word &#39;war&#39;, therefore, has become misleading. It would probably be accurate to say that by becoming continuous war has ceased to exist. The peculiar pressure that it exerted on human beings between the Neolithic Age and the early twentieth century has disappeared and been replaced by something quite different. The effect would be much the same if the three super-states, instead of fighting one another, should agree to live in perpetual peace, each inviolate within its own boundaries. For in that case each would still be a self-contained universe, freed for ever from the sobering influence of external danger. A peace that was truly permanent would be the same as a permanent war. This -- although the vast majority of Party members understand it only in a shallower sense -- is the inner meaning of the Party slogan: War is Peace</p>

<p>Between life and death, and between physical pleasure and physical pain, there is still a distinction, but that is all. Cut off from contact with the outer world, and with the past, the citizen of Oceania is like a man in interstellar space, who has no way of knowing which direction is up and which is down. The rulers of such a state are absolute, as the Pharaohs or the Caesars could not be. They are obliged to prevent their followers from starving to death in numbers large enough to be inconvenient, and they are obliged to remain at the same low level of military technique as their rivals; but once that minimum is achieved, they can twist reality into whatever shape they choose.</p>

<p>War, it will be seen, is now a purely internal affair. In the past, the ruling groups of all countries, although they might recognize their common interest and therefore limit the destructiveness of war, did fight against one another, and the victor always plundered the vanquished. In our own day they are not fighting against one another at all. The war is waged by each ruling group against its own subjects, and the object of the war is not to make</p>

<p>The aims of these three groups are entirely irreconcilable. The aim of the High is to remain where they are. The aim of the Middle is to change places with the High. The aim of the Low, when they have an aim — for it is an abiding characteristic of the Low that they are too much crushed by drudgery to be more than intermittently conscious of anything outside their daily lives —is to abolish all distinctions and create a society in which all men shall be equal. Thus throughout history a struggle which is the same in its main outlines recurs over and over again. For long periods the High seem to be securely in power, but sooner or later there always comes a moment when they lose either their belief in themselves or their capacity to govern efficiently, or both. They are then overthrown by the Middle, who enlist the Low on their side by pretending to them that they are fighting for liberty and justice. As soon as they have reached their objective, the Middle thrust the Low back into their old position of servitude, and themselves become the High. Presently a new Middle group splits off from one of the other groups, or from both of them, and the struggle begins over again. Of the three groups, only the Low are never even temporarily successful in achieving their aims. It would be an exaggeration to say that throughout history there has been no progress of a material kind. Even today, in a period of decline, the average human being is physically better off than he was a few centuries ago. But no advance in wealth, no softening of manners,no reform or revolution has ever brought human equality a millimetre nearer. From the point of view of the Low, no historic change has ever meant much more than a change in the name of their masters.</p>

<p>Part of the reason for this was that in the past no government had the power to keep its citizens under constant surveillance. The invention of print, however, made it easier to manipulate public opinion, and the film and the radio carried the process further. With the development of television, and the technical advance which made it possible to receive and transmit simultaneously on the same instrument, private life came to an end. Every citizen, or at least every citizen important enough to be worth watching, could be kept for twentyfour hours a day under the eyes of the police and in the sound of official propaganda, with all other channels of communication closed. The possibility of enforcing not only complete obedience to the will of the State, but complete uniformity of opinion on all subjects, now existed for the first time.</p>

<p>It had long been realized that the only secure basis for oligarchy is collectivism. Wealth and privilege are most easily defended when they are possessed jointly. The so-called &quot;abolition of private property&quot; which took place in the middle years of the century meant, in effect, the concentration of property in far fewer hands than before: but with this difference, that the new owners were a group instead of a mass of individuals. Individually, no member of the Party owns anything, except petty personal belongings. Collectively, the Partyowns everything in Oceania, because it controls everything, and disposes of the products as it thinks fit.</p>

<p>&quot; When you make love you&#39;re using up energy; and afterwards you feel happy and don&#39;t give a damn for anything. They can&#39;t bear you to feel like that. They want you to be bursting with energy all the time. All this marching up and down and cheering and waving flags is simply sex gone sour.&quot; ... There was a direct, intimate connection between chastity and political orthodoxy. 
...The family could not actually be abolished, and, indeed, people were encouraged to be fond of their children in an almost the old-fashioned way. The children, on the other hand, were systematically turned against their parents and taught to spy on them and report their deviations...It was a device by means of which everyone could be surrounded night and day by informers who knew him intimately.</p>

<p>He had won the victory over himself. He loved Big Brother.</p>

	  ]]></description>
	</item>


</channel>
</rss>
