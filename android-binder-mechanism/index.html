<!DOCTYPE html>
<html>
<head>
    <!-- [[! Document Settings ]] -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- [[! Page Meta ]] -->
    <title>Android Binder Mechanism</title>
    <meta name="description" content="Dancing with Machine, Human and God - World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it." />

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="/assets/images/favicon.ico" >

    <!-- [[! Styles'n'Scripts ]] -->
    <link rel="stylesheet" type="text/css" href="/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css"
          href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/assets/css/syntax.css" />
    
    <!-- [[! Ghost outputs important style and meta data with this tag ]] -->
        <link rel="canonical" href="/" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/page2/" />

    <meta property="og:site_name" content="Dancing with Machine, Human and God" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Dancing with Machine, Human and God" />
    <meta property="og:description" content="World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it." />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Dancing with Machine, Human and God" />
    <meta name="twitter:description" content="World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it." />
    <meta name="twitter:url" content="/" />
    <meta name="twitter:image:src" content="/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Tao's Page",
    "url": "/",
    "image": "/assets/images/cover1.jpg",
    "description": "World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Dancing with Machine, Human and God" href="/rss.xml" />

</head>
<body class="post-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/about.html">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/tag/machine/">Machine</a></li>
        <li class="nav-speeches " role="presentation"><a href="/tag/human/">Human</a></li>
        <li class="nav-fiction " role="presentation"><a href="/tag/god/">God</a></li>
        <li class="nav-author " role="presentation"><a href="/author/hetao/">Author</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/rss.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- [[! Everything else gets inserted here ]] -->
        <!-- < default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="post tag-machine">

        <header class="post-header">
            <h1 class="post-title">Android Binder Mechanism</h1>
            <section class="post-meta">
            <!-- <a href='/'>Tao He</a> -->
            <time class="post-date" datetime="2016-08-03">03 Aug 2016</time>
                <!-- [[tags prefix=" on "]] -->
                 
                on 
                
                    
                       <a href='/tag/machine'>Machine</a>
                       
                
                
            </section>
        </header>

        <section class="post-content">
            
            <h4 id="what-is-binder">What is Binder</h4>

<ul>
  <li>The Binder mechanism has started from a simple idea. </li>
</ul>

<blockquote>
  <p>“Let requests and responses be written in an area where all processes can share and let each process refer to the memory address.” </p>
</blockquote>

<ul>
  <li>
    <p>Binder is a IPC mechanism.</p>
  </li>
  <li>
    <p>Binder implementation is based on <strong>OpenBinder</strong>.</p>
  </li>
  <li>
    <p>Binder refers to a kernel memory which is shared between all processes to minimize the overhead caused by memory copy. </p>
  </li>
  <li>
    <p>It provides the Remote Procedure Call (RPC) framework written in C++ for high productivity.</p>
  </li>
</ul>

<h4 id="why-need-binder">Why need Binder</h4>

<ul>
  <li>
    <p>Android need IPC mechanism because of its loosely coupled component design. Every application in Android is comprised of some components ,like Activity or Service, they maybe in same process or not. If they are in different process, they need communicate each other.</p>
  </li>
  <li>
    <p>All of the default system functions of Android are provided as the <strong>server process</strong> type. In other words, to use the functions such as <code>SurfaceFlinger</code> or <code>AudioFlinger</code>, a request should be made as a separate process that runs on the user mode. As all system services are provided as a <strong>server process</strong>, a mechanism to send requests and responses to other processes is necessary. In Android it is called the Binder. Android uses functions provided by other processes through Binder.</p>
  </li>
  <li>
    <p>Android is based on Linux, Linux has a lot of IPC mechanism. But, Android didn’t adopted it. Maybe because of performance and low memory of Android device.</p>
  </li>
</ul>

<h4 id="the-benefits-of-using-binder-mechanism">The Benefits of Using Binder Mechanism</h4>

<ul>
  <li>
    <p>Easy to expand or remove functions: It is easy to add a new system service or remove an existing function.</p>
  </li>
  <li>
    <p>Easy to port: Porting to a new processor requires few changes. A toolchain for porting is provided.</p>
  </li>
  <li>
    <p>Easy to test: Tests are limited by the component unit, so it is not necessary to test the entire services, and more strict tests are available.</p>
  </li>
  <li>
    <p>Support for distribution system: Process communication is based on the Binder, so it guarantees transparency in location between components.</p>
  </li>
</ul>

<h4 id="binder-driver">Binder Driver</h4>

<p>A Binder Driver is implemented to use the kernel space. The role of the Binder driver is to convert the memory address that each process has mapped with the memory address of the kernel space for reference.</p>

<h4 id="understanding-binder-mechanism-through-media-service">Understanding Binder Mechanism through Media Service</h4>

<h5 id="servicemanager"><code>ServiceManager</code></h5>

<p>ServiceManager is a system manager which manages all services in Android.</p>

<h5 id="what-is-media-service">What is Media Service</h5>

<ul>
  <li>
    <p>Media Service is a general C++ application, is core of android media.</p>
  </li>
  <li>
    <p>Media Service is a general service Android supplied.</p>
  </li>
  <li>
    <p>Source code location: <em>frameworks/base/media/mediaserver/main_mediaserver.cpp</em></p>
  </li>
  <li>
    <p>Entry point:</p>
  </li>
</ul>

<p>```c++
int main(int argc, char** argv)
{
    // Require a ServiceManager proxy
    sp<processstate> proc(ProcessState::self());
    sp<iservicemanager> sm = defaultServiceManager();
    LOGI("ServiceManager: %p", sm.get());
    AudioFlinger::instantiate();
    MediaPlayerService::instantiate();
    CameraService::instantiate();
    AudioPolicyService::instantiate();</iservicemanager></processstate></p>

<pre><code>// Forever process messages sent from Binder.
ProcessState::self()-&gt;startThreadPool();
IPCThreadState::self()-&gt;joinThreadPool(); } ``` * Media server service has four sub-module.
</code></pre>

<ul>
  <li>
    <p><code>AudioFlinger</code></p>
  </li>
  <li>
    <p><code>MediaPlayerService</code></p>
  </li>
  <li>
    <p><code>CameraService</code></p>
  </li>
  <li>
    <p><code>AudioPolicyService</code></p>
  </li>
</ul>

<h5 id="processstate"><code>ProcessState</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/libs/binder/ProcessState.cpp</em></p>
  </li>
  <li>
    <p>Media Service first call <code>ProcessState::self()</code></p>
  </li>
</ul>

<p>```c++
sp<processstate> ProcessState::self()
{
    if (gProcess != NULL) return gProcess;</processstate></p>

<pre><code>AutoMutex _l(gProcessMutex);
if (gProcess == NULL) gProcess = new ProcessState;
return gProcess; } ```
</code></pre>

<ul>
  <li>Then <code>ProcessState::self()</code> call ProcessState constructor</li>
</ul>

<p><code>c++
ProcessState::ProcessState()
    : mDriverFD(open_driver())
    , mVMStart(MAP_FAILED) // Map the memory start address
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD &gt;= 0) {
        // XXX Ideally, there should be a specific define for whether we
        // have mmap (or whether we could possibly have the kernel module
        // availabla).
#if !defined(HAVE_WIN32_IPC)
        // mmap the binder, providing a chunk of virtual address space to receive transactions.
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            LOGE("Using /dev/binder failed: unable to mmap transaction memory.\n");
            close(mDriverFD);
            mDriverFD = -1;
        }
#else
        mDriverFD = -1;
#endif
    }
    if (mDriverFD &lt; 0) {
        // Need to run without the driver, starting our own thread pool.
    }
}
</code></p>

<ul>
  <li>
    <p><code>open_driver()</code> function</p>

    <ul>
      <li>
        <p>Very important function call to open a virtual device for communication.</p>
      </li>
      <li>
        <p>This functon will open this device <strong>/dev/binder</strong>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>When <code>ProcessState::self()</code> complete, it had do two important jobs:</p>

    <ul>
      <li>Open the virtual device <strong>/dev/binder</strong>, so there has been a channel to communicate with kernel.</li>
      <li>Map <strong>/dev/binder</strong> device’s fd to memory.  </li>
    </ul>
  </li>
</ul>

<h5 id="defaultservicemanager"><code>defaultServiceManager()</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/libs/binder/IServiceManager.cpp</em></p>
  </li>
  <li>
    <p>Trace the source code call path, finally find that this call <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> equals <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code>.</p>
  </li>
  <li>
    <p>BpBinder</p>

    <ul>
      <li>
        <p>Source code location: <em>frameworks/base/libs/binder/BpBinder.cpp</em></p>
      </li>
      <li>
        <p>BpBinder constructor:</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
BpBinder::BpBinder(int32_t handle)
    : mHandle(handle)
    , mAlive(1)
    , mObitsSent(0)
    , mObituaries(NULL)
{
    LOGV(“Creating BpBinder %p handle %d\n”, this, mHandle);</p>

<pre><code>extendObjectLifetime(OBJECT_LIFETIME_WEAK);
IPCThreadState::self()-&gt;incWeakHandle(handle); } ```
</code></pre>

<ul>
  <li>
    <p>What did <code>interface_cast</code> do?</p>

    <ul>
      <li>
        <p><code>interface_cast</code> defined in <em>/home/tao/android_source/frameworks/base/include/binder/IInterface.h</em></p>
      </li>
      <li>
        <p><code>interface_cast</code> defination</p>
      </li>
    </ul>
  </li>
</ul>

<p><code>c++
template&lt;typename INTERFACE&gt;
inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return INTERFACE::asInterface(obj);
}
</code>
   * So <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement call <code>interface_cast</code> will equals:</p>

<p><code>c++
inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)
{
    return IServiceManager::asInterface(obj);
}
</code></p>

<ul>
  <li>
    <p>We need find clue in <code>IServiceManager</code></p>

    <ul>
      <li>
        <p>Source code location: <em>frameworks/base/include/binder/IInterface.h</em></p>
      </li>
      <li>
        <p><code>IServiceManager</code> defination</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
class IServiceManager : public IInterface
{
public:
    DECLARE_META_INTERFACE(ServiceManager);</p>

<pre><code>/**
 * Retrieve an existing service, blocking for a few seconds
 * if it doesn't yet exist.
 */
virtual sp&lt;IBinder&gt;         getService( const String16&amp; name) const = 0;

/**
 * Retrieve an existing service, non-blocking.
 */
virtual sp&lt;IBinder&gt;         checkService( const String16&amp; name) const = 0;

/**
 * Register a service.
 */
virtual status_t            addService( const String16&amp; name,
                                        const sp&lt;IBinder&gt;&amp; service) = 0;

/**
 * Return list of all existing services.
 */
virtual Vector&lt;String16&gt;    listServices() = 0;

enum {
    GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
    CHECK_SERVICE_TRANSACTION,
    ADD_SERVICE_TRANSACTION,
    LIST_SERVICES_TRANSACTION,
}; }; ```     
* We need trace this macro `DECLARE_META_INTERFACE(ServiceManager)` 
</code></pre>

<p>```c++
#define DECLARE_META_INTERFACE(INTERFACE)                           <br />
    static const String16 descriptor;                               <br />
    static sp&lt;I##INTERFACE&gt; asInterface(const sp<ibinder>&amp; obj);      
    virtual const String16&amp; getInterfaceDescriptor() const;           
    I##INTERFACE();                                                   
    virtual ~I##INTERFACE();                                          </ibinder></p>

<h1 id="define-implementmetainterfaceinterface-name">define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)</h1>
<pre><code>const String16 I##INTERFACE::descriptor(NAME);                    
const String16&amp; I##INTERFACE::getInterfaceDescriptor() const {    
    return I##INTERFACE::descriptor;                              
}                                                                 
sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(const sp&lt;IBinder&gt;&amp; obj)
{                                                                 
    sp&lt;I##INTERFACE&gt; intr;                                        
    if (obj != NULL) {                                            
        intr = static_cast&lt;I##INTERFACE*&gt;(                        
            obj-&gt;queryLocalInterface(                             
                    I##INTERFACE::descriptor).get());             
        if (intr == NULL) {                                       
            intr = new Bp##INTERFACE(obj);                        
        }                                                         
    }                                                             
    return intr;                                                  
}                                                                 
I##INTERFACE::I##INTERFACE() { }                                  
I##INTERFACE::~I##INTERFACE() { }                                  ```
</code></pre>

<ul>
  <li>Finally, we find that <code>interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement actually return a <code>BpServiceManager</code> object. It means <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> acquired a <code>BpServiceManager</code> object.</li>
</ul>

<h5 id="bpservicemanager"><code>BpServiceManager</code></h5>

<ul>
  <li>Bp stands for Binder proxy, it means <code>BpServiceManager</code> is <code>ServiceManager</code>’s proxy to Binder.</li>
</ul>

<h5 id="mediaplayerservice"><code>MediaPlayerService</code></h5>

<ul>
  <li>
    <p>Source code location: <em>frameworks/base/media/libmediaplayerservice/MediaPlayerService.cpp</em></p>
  </li>
  <li>
    <p>Defination and instantiation </p>
  </li>
</ul>

<p>```c++
void MediaPlayerService::instantiate() {
    defaultServiceManager()-&gt;addService(
            String16(“media.player”), new MediaPlayerService());
}</p>

<p>MediaPlayerService::MediaPlayerService()
{
    LOGV(“MediaPlayerService created”);
    mNextConnId = 1;
}</p>

<p>MediaPlayerService::~MediaPlayerService()
{
    LOGV(“MediaPlayerService destroyed”);
}
```</p>

<ul>
  <li>
    <p><code>MediaPlayerService</code> derivatived from <code>BnMediaPlayerService</code></p>
  </li>
  <li>
    <p>Bn stands for Binder native.</p>
  </li>
  <li>
    <p>Add <code>MediaPlayerService</code> to <code>ServiceManager</code></p>
  </li>
</ul>

<p><code>c++
virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)
{
    Parcel data, reply;
    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());
    data.writeString16(name);
    data.writeStrongBinder(service);
    // remote() return BpBinder object
    status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);
    return err == NO_ERROR ? reply.readInt32() : err;
}
</code>
* <code>remote()</code> return BpBinder</p>

<p>```c++
status_t BpBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }</p>

<pre><code>return DEAD_OBJECT; } ```
</code></pre>

<ul>
  <li>
    <p><code>IPCThreadState</code> do with transaction, write add service command and wait for response.</p>
  </li>
  <li>
    <p><code>BpServiceManager</code> had sent a add service message, but who receive and process it?</p>
  </li>
  <li>
    <p><code>BnServiceManager</code>? unfortunately it doesn’t exist. service do same job.</p>
  </li>
  <li>
    <p>service</p>
    <ul>
      <li>
        <p>service is a general c++ applcation.</p>
      </li>
      <li>
        <p>Source code location: <em>frameworks/base/cmds/servicemanager/service_manager.c</em></p>
      </li>
      <li>
        <p>Entry point:</p>
      </li>
    </ul>
  </li>
</ul>

<p>```c++
int main(int argc, char **argv)
{
    struct binder_state *bs;
    //  BINDER_SERVICE_MANAGER is NULL, is a magic number
    void *svcmgr = BINDER_SERVICE_MANAGER;</p>

<pre><code>bs = binder_open(128*1024);

if (binder_become_context_manager(bs)) {
    LOGE("cannot become context manager (%s)\n", strerror(errno));
    return -1;
}

svcmgr_handle = svcmgr;
binder_loop(bs, svcmgr_handler);
return 0; } ```
</code></pre>

<h4 id="conclusion">Conclusion</h4>

<p>Through tracing so many codes, the MediaPlayerService example maybe reveal the Binder’s mysterious veil. We need write down some important conclusions:</p>

<ul>
  <li>
    <p>If two processes need communicate each other, one as Client, the other is Server, Server need registered to <code>ServiceManager</code>, if Client want request to Server, it need query Server’s info from <code>ServiceManager</code>, based the qureid info, Client and Server can communicate each other. </p>
  </li>
  <li>
    <p>Client, Server, <code>ServiceManager</code> are implemented in use space, Binder is implemented in kernel space.</p>
  </li>
  <li>
    <p><code>ServiceManager</code> and Binder is implemented by Android, developers need implemente their Client and Server.</p>
  </li>
  <li>
    <p>Binder supplied device file <strong>/dev/binder</strong> communicate to user space. Client, Server and <code>ServiceManager</code> communicated to Binder through <code>open</code> and <code>ioctl</code> file operation function.</p>
  </li>
  <li>
    <p>Client and Server communicate each other immediately through Binder.</p>
  </li>
  <li>
    <p><code>ServiceManager</code> is a daemon process, it manages Server, supply interface to qurey Server function.</p>
  </li>
</ul>

<p>If want to learn Android IPC mechanism deeply, a lot of Android source code need be read. Linus said:</p>

<blockquote>
  <p>Read The Fucking Source Code.</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->

            
            <figure class="author-image">
                <a class="img" href="/author/hetao" style="background-image: url(/assets/images/casper.png)"><span class="hidden">'s Picture</span></a>
            </figure>
            

            <section class="author">
                <h4><a href="/author/hetao">Tao He</a></h4>
                
                
                    <p> A computer engineer, reader and thinker.</p>
                
                <div class="author-meta">
                    <span class="author-location icon-location"> Beijing, China</span> 
                    <span class="author-link icon-link"><a href="http://longlinht.github.io/"> longlinht.github.io/</a></span> 
                </div>
            </section>

            <!-- /author  -->

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="http://twitter.com/share?text=Android Binder Mechanism&amp;url=http://longlinht.github.io//android-binder-mechanism"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://longlinht.github.io//android-binder-mechanism"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=http://longlinht.github.io//android-binder-mechanism"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>
            
            <!-- Add Disqus Comments -->
            
                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//hetaoof.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

            
            
        </footer>

    </article>

</main>

<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="http://longlinht.github.io//java-garbage-collection">
            <section class="post">
                <h2>Understanding Java Garbage Collection</h2>
                <p>**stop-the-world** Stop-the-world means that the JVM is stopping the application from running to execute a...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="http://longlinht.github.io//memory-leak-in-android-development">
            <section class="post">
                <h2>Memory Leak in Android Development</h2>
                <p><p>When programming Android, although java has GC mechanism, some our wrong code way and personal...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/">Dancing with Machine, Human and God</a> &copy; 2017</section>
        </footer>
    </div>
    <!-- [[! Ghost outputs important scripts and data with this tag ]] -->
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    <!-- [[! The main JavaScript file for Casper ]] -->
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="/assets/js/index.js"></script>

    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-78960009-1', 'auto');
	    ga('send', 'pageview');

     </script>
   
</body>
</html>
