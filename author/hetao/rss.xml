<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>xCrash运用小结</title>
	  <link>//summary-of-using-xcrash</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-29T22:00:00+08:00</pubDate>
	  <guid>//summary-of-using-xcrash</guid>
	  <description><![CDATA[
	     <p>公司在做海外产品，由于免费版firebase对native崩溃的捕获上报能力有限(无堆栈，无具体上下文信息)，因此对我们定位和降低native极为不利，当native崩溃总量进入top行列的时候，就不能对其视而不见了，因此我开始调研解决方案，最后决定接入爱奇艺推出的xCrash来捕获native崩溃，当然了，xCrash本身是不具备上报功能的，它只是将崩溃信息写入tombstone文件。因此需要在其基础之上添加上报功能。</p>

<p>要实现上报功能，就需要选择一个上报时机，在崩溃发生时或App再次启动时，我选择了在崩溃发生时即时上传tombstone文件，并与服务端约定上报协议，最终实现可在firebase后台通过设备ID来查看上传到服务器的tombstone文件。</p>

<p>具体实现如下：</p>

<p>在崩溃发生的回调中找到最新的tombstone文件，打包上传至服务器</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public void init(Context context) {
    XCrash.init(context, new XCrash.InitParameters()
            .setAppVersion(BuildConfig.VERSION_NAME)
            .setLogDir(getCrashDir().getAbsolutePath())
            .setJavaRethrow(true)
            .setJavaLogCountMax(3)
            .setJavaDumpAllThreadsWhiteList(new String[]{&quot;^main$&quot;, &quot;^Binder:.*&quot;, &quot;.*Finalizer.*&quot;})
            .setJavaDumpAllThreadsCountMax(0)
            .setNativeRethrow(true)
            .setNativeLogCountMax(3)
            .setNativeDumpAllThreadsWhiteList(new String[]{&quot;^Signal Catcher$&quot;, &quot;^Jit thread pool$&quot;, &quot;.*(R|r)ender.*&quot;, &quot;.*Chrome.*&quot;})
            .setNativeDumpAllThreadsCountMax(0)
            .setAnrRethrow(true)
            .setAnrLogCountMax(3)
            .setPlaceholderCountMax(0)
            .setLogFileMaintainDelayMs(1000)
            .setLogger(mLogger)
            .setLibLoader(new ILibLoader() {
                @Override public void loadLibrary(String libName) {
                    try {
                        ReLinker.loadLibrary(context, libName);
                    } catch (Exception e) {
                        printLog(e + &quot; | &quot; + libName);
                        System.loadLibrary(libName);
                    }
                }
            }).setAnrCallback(new ICrashCallback() {
                // ANR发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchANRLogDelay();
                }
            }).setJavaCallback(new ICrashCallback() {

                // Java崩溃发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchCrashLog();
                }
            }).setNativeCallback(new ICrashCallback() {
               //Native崩溃发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchCrashLog();
                }
            })
    );
}


// 打包上传tombstone文件
private void catchCrashLog() {
    crashZipId = generateCrashId();
    final File out = new File(AppInstances.getPathManager().getTmpFilePath() + crashZipId + &quot;.gzip&quot;);

    try {
        List&lt;File&gt; files = Arrays.asList(getCrashDir().listFiles());
        if (ListUtils.isEmpty(files)) {
            return;
        }

        File crashFile = null;
        long lastModified = 0;
        for (File f : files) {
            if (f.lastModified() &gt; lastModified) {
                lastModified = f.lastModified();
                crashFile = f;
            }
        }

        if (crashFile != null) {
            GZIPUtils.gzipFile(crashFile.getAbsolutePath(), out.getAbsolutePath());
        }

    } catch (Throwable e) {
        e.printStackTrace();
    }

    upload();
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre></div>
<p>上面的代码有一点需要注意: 为了尽可能将崩溃日志成功上传至服务器，主线程sleep五秒，对于anr的情况则是在非UI线程中上传日志。</p>

<p>日志上传成功后，就可以在firebase的崩溃列表中查看某一个崩溃，在数据一栏找到设备ID来查询。因为我们有运营后台可以将设备ID和用户ID关联，因此就可以轻松查到每个用户的崩溃日志。</p>

<p>此即时上报的方案上线后虽然助力定位到了一些问题，但也有如下缺陷和问题</p>

<ul>
<li><p>引入了新的问题，如OOM，ANR等问题。</p></li>
<li><p>由于上报依赖于全局的OkHttp Client，因此如果App在没有初始化OkHttp Client的情况下崩溃，则不会上报，就属漏报了。</p></li>
<li><p>崩溃和anr不能即时聚合到一处供查看</p></li>
<li><p>ANR目前不能查询，但是已尝试使用firebase Event上报，但是貌似免费版无法查看Event的字段，上报的意义不大，后期考虑向服务端上报。</p></li>
</ul>

<p>问题2和3其实可以很容易改善，但是问题1还有待进一步观察，同期因为我们代码的原因引入了一个严重的OOM问题，所以不太确定是不是xCrash受到了影响和牵连。这个OOM问题修复后准备再打开xCrash进一步验证。</p>

<p>目前观察到一个现象，Android 7以下的机器基本都没有成功上报，比较奇怪，但是本地测试Android 4的机器是可以上报的，此问题后续有待验证。</p>

	  ]]></description>
	</item>

	<item>
	  <title>客户端线上问题应对小记</title>
	  <link>//resolve-online-problem</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-26T22:00:00+08:00</pubDate>
	  <guid>//resolve-online-problem</guid>
	  <description><![CDATA[
	     <p>今年三四月份我所在的App项目经历了不少我之前很少遇到的情况，回看这些无论是突发状况，还是隐匿得让人无法发觉的细节导致的问题，都非常有借鉴意义，也是很大的教训，难能可贵的经验，有必要用一小文记录下。</p>

<p>两个月的时间，经历了一次线上crash激增，一次新发版本用户无法播放视频的集中反馈，和一次OOM和ANR持续上涨。下面分别复盘这三次惊魂时刻。</p>

<p>先来说说线上crash突然激增，那天上午的时候突然native崩溃曲线陡升，而我们App最近的一个版本已经全量好多天了，native崩溃一直都是一个相对稳定的曲线，这使我们一头雾水，因为firebase对native崩溃的捕获很不好，更加导致我们焦急万分，我负责App的整体质量，当时更是如热锅上的蚂蚁。着急归着急，也不能乱了阵脚，先开始排除活动或广告下发的影响，于是赶紧联系了市场的同学，让他们确定最近是否有活动或广告投放，询问后发现并没有，但是得知最近的确有买量的操作，并且DAU有上涨的趋势，于是怀疑是不是因为买量导致native崩溃激增，但是后来查看firebase后台，native崩溃大多发生在低端机器上，这就说不过去了，难道买到的量都是低端机器?于是很快推翻了这个怀疑。开始分版本分析，很快发现，近几个版本的native崩溃上涨曲线基本都能吻合，说明这是一个外部环境变化导致的崩溃，而不是某一个版本引入的新崩溃，在firebase有限的native崩溃信息中，还是发现了
libmonochrome.so这个信息，当看到这个so的时候，直觉告诉我是广告导致的没跑了，但是问题来了，最近并没有增加广告的投放，广告又如何使native崩溃激增呢？直到我们搜到这条新闻:<a href="https://www.cnbeta.com/articles/tech/1105323.htm">谷歌正在修复Android系统WebView组件引发的应用崩溃问题</a>一切才豁然开朗，是因为Google推送的webview组件更新有bug，导致了大面积的崩溃，于是我们果断的关闭了广告的投放，到晚上八点的时候，native崩溃曲线终于回归了正常。</p>

<p>再来说说集中反馈，事情是这样的，我们新发布了一个版本，在放量不到20%时，一天内集中收到好几个用户反馈视频不能播放，从用户提供的截图可以看出视频进度条还在动，但是并未渲染出视频，这个问题与之前我们已知的黑屏问题不同，显然是一个新问题。在没有任何头绪的情况下，就只能通过对比此版本与上个版本的diff来寻找蛛丝马迹，看完所有的diff后还是很让人疑惑，因为真的没有修改任何与播放器相关的代码，就连可能影响播放器的代码也没有，那这个版本到底有什么不同呢？在第二次对比diff的时候，广告sdk的升级改动引起了我的注意，我大胆猜想，难不成是这导致的，如果非要找个嫌疑人的话，只能是它了，于是赌上客户端组的声誉，告知市场广告sdk有问题，新版本去除更新重新发版，放量后再未出现此问题反馈，也是神奇，猜测广告sdk使用了opengl，可能影响到了播放器的视频渲染。</p>

<p>最后说下OOM和ANR持续上涨得情况，这可以说是一次线上事故，是因为使用第三方库不当和第三方工具本身的问题合力导致的，这次问题是在版本全量后几天后才逐步暴露出来的，坏就坏在这个问题是逐步积累，然后雪球越滚越大最后导致了严重的问题。因为firebase不能统计到有些OOM的崩溃，期初的几天我们还奇怪为什么在没有新增崩溃的情况下，崩溃率竟然一直在涨，于是尽快分析firebase的数据，但仍旧没有什么有用的线索，因为我们一直习惯于在firebase后台看崩溃，在Google Play Console看ANR，因此一直以来的习惯是没有人去GPC去看崩溃，直到在一次看ANR的时候不经意间看到了一个之前未发现的崩溃，显示为OOM问题，至此，问题浮出水面，是全量的这个版本在使用第三方库的时候，未注意到第三方库有一个每次操作如果是在主线程调用的话都新建线程的逻辑，导致了严重的OOM，再加上同一版本也接入了xCrash和BoostMultiDex，因此到底是谁导致了OOM和ANR，已然纠缠不清，版本已发出xCrash和BoostMultiDex已无法绕过，但是导致OOM的这个rtt上报却有开关，可以动态关闭，于是在关闭几天后，崩溃率逐步恢复正常，ANR也恢复正常，因此可以断定rtt上报应该是罪魁祸首。这是一个失误导致的大问题，教训深刻，既暴露了我们工程对线程的管理不善，也暴露出firebase可能漏报了很多我们不知道的OOM崩溃，也就说实际的OOM可能比我们现在看到的还要严重。</p>

<p>这三次线上问题，都已经过去了，App的崩溃率和ANR也恢复正常，但是教训却很深刻，经过几天的认真复盘和思考，总结出如下经验和教训:</p>

<ul>
<li>一个问题激增时不一定是App本身的代码导致的，但也需要及时诊断和定位，不能倾向于从用户设备和DAU变化找问题</li>
<li>诊断问题要聚焦，不要受一些外部因素干扰</li>
<li>当问题发生时，倾向于App本身有问题，而不是找外部原因，不要被误导诊断方向</li>
<li>当反馈集中发生时，肯定是有问题，而不用怀疑是反馈变集中了，事出反常必有妖</li>
<li>接入第三方库和工具时要慎之又慎，多测试，多验证，多怀疑，做好兜底，做好出了问题的应对之策</li>
<li>影响较大的功能和模块不宜同时出现在一个版本里，出现问题后纠缠不清，无法定位</li>
<li>一个问题持续出现后，必须引起重视，在上报数据不完整，无上下文的情况下也要通过其他途径去诊断和定位，切不可倾向于没有问题。</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>13个问题测试你对这个世界的无知有多严重</title>
	  <link>//13-questions-test-your-ignorance</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-22T04:54:12+08:00</pubDate>
	  <guid>//13-questions-test-your-ignorance</guid>
	  <description><![CDATA[
	     <p>在Factfulness这本书中作者一开头就抛出13个对事实认知的问题，以此测试读者对这个世界的认知，因为我已经读完了这本书，我觉得这些问题值得将其单列出来，有兴趣的可以做做这些测试题，文末附有答案，相信我你的成绩不一定好过大猩猩，问题列表如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">1. In all low-income countries across the world today, how many girls finish primary school? 
   A: 20 percent    B: 40 percent    C: 60 percent 

2. Where does the majority of the world population live? 
   A: Low-income countries    B: Middle-income countries    C: High-income countries 

3. In the last 20 years, the proportion of the world population living in extreme poverty has … 
   A: almost doubled    B: remained more or less the same    C: almost halved 

4. What is the life expectancy of the world today?
    A: 50 years    B: 60 years    C: 70 years 

5. There are 2 billion children in the world today, aged 0 to 15 years old. How many children will there be in the year 2100, according to the United Nations? 
   A: 4 billion    B: 3 billion    C: 2 billion

6. The UN predicts that by 2100 the world population will have increased by another 4 billion people. What is the main reason? 
   A: There will be more children (age below 15)    B: There will be more adults (age 15 to 74)    C: There will be more very old people (age 75 and older) 

7. How did the number of deaths per year from natural disasters change over the last hundred years? 
   A: More than doubled    B: Remained about the same    C: Decreased to less than half 

8. There are roughly 7 billion people in the world today. Which map shows best where they live? (Each figure represents 1 billion people.) 

9. How many of the world’s 1-year-old children today have been vaccinated against some disease?
   A: 20 percent    B: 50 percent    C: 80 percent 

10. Worldwide, 30-year-old men have spent 10 years in school, on average. How many years have women of the same age spent in school? 
   A: 9 years    B: 6 years    C: 3 years 

11. In 1996, tigers, giant pandas, and black rhinos were all listed as endangered. How many of these three species are more critically endangered today? 
   A: Two of them    B: One of them    C: None of them 

12. How many people in the world have some access to electricity? 
   A: 20 percent    B: 50 percent    C: 80 percent 

13. Global climate experts believe that, over the next 100 years, the average temperature will … 
   A: get warmer    B: remain the same    C: get colder
</code></pre></div>
<p>Here are the correct answers:</p>

<p>1: C, 2: B, 3: C, 4: C, 5: C, 6: B, 7: C, 8: A, 9: C, 10: A, 11: C, 12: C, 13: A</p>

	  ]]></description>
	</item>

	<item>
	  <title>重读Sapiens</title>
	  <link>//read-sapiens</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-18T04:54:12+08:00</pubDate>
	  <guid>//read-sapiens</guid>
	  <description><![CDATA[
	     <p>两年前读过《人类简史》的中译本，去年年终和今年年初一口气读完了《未来简史》和《今日简史》的英文版，就一直惦记着干脆把《人类简史》的英文版再读一遍，今年过年时本来想一鼓作气读完，但是中间又读了《The Black Swan》，就一直没顾上，最近坐地铁通勤，断断续续终于又读了一遍，不得不说，再读英文版，依旧有新的收获。不管从写史的风格，思路，框架，格局，还是文笔，都是一等一的杰作。</p>

<p>且看开篇这个段落：</p>

<p>Years Before the Present </p>

<p>13.5 billion Matter and energy appear. Beginning of physics. Atoms and molecules appear. Beginning of chemistry. </p>

<p>4.5 billion Formation of planet Earth. </p>

<p>3.8 billion Emergence of organisms. Beginning of biology. </p>

<p>6 million Last common grandmother of humans and chimpanzees. </p>

<p>2.5 million Evolution of the genus Homo in Africa. First stone tools. </p>

<p>2 million Humans spread from Africa to Eurasia. Evolution of different human species. </p>

<p>500,000 Neanderthals evolve in Europe and the Middle East. </p>

<p>300,000 Daily usage of fire. </p>

<p>200,000 Homo sapiens evolves in East Africa. </p>

<p>70,000 The Cognitive Revolution. Emergence of fictive language. Beginning of history. Sapiens spread out of Africa.</p>

<p>45,000 Sapiens settle Australia. Extinction of Australian megafauna. </p>

<p>30,000 Extinction of Neanderthals. </p>

<p>16,000 Sapiens settle America. Extinction of American megafauna. </p>

<p>13,000 Extinction of Homo floresiensis. Homo sapiens the only surviving human species. </p>

<p>12,000 The Agricultural Revolution. Domestication of plants and animals. Permanent settlements. </p>

<p>5,000 First kingdoms, script and money. Polytheistic religions. </p>

<p>4,250 First empire– the Akkadian Empire of Sargon. </p>

<p>2,500 Invention of coinage– a universal money. The Persian Empire– a universal political order ‘for the benefit of all humans’. Buddhism in India– a universal truth ‘to liberate all beings from suffering’. </p>

<p>2,000 Han Empire in China. Roman Empire in the Mediterranean. Christianity.</p>

<p>1,400 Islam. </p>

<p>500 The Scientific Revolution. Humankind admits its ignorance and begins to acquire unprecedented power. Europeans begin to conquer America and the oceans. The entire planet becomes a single historical arena. The rise of capitalism. </p>

<p>200 The Industrial Revolution. Family and community are replaced by state and market. Massive extinction of plants and animals. The Present Humans transcend the boundaries of planet Earth. Nuclear weapons threaten the survival of humankind. Organisms are increasingly shaped by intelligent design rather than natural selection. The Future Intelligent design becomes the basic principle of life? Homo sapiens is replaced by superhumans? </p>

<p>我也看过不少历史类的书籍，没有一个作者像赫拉利这样，寥寥数言，已经清晰的勾勒出人类历史的基本脉络，并且文字有趣，简洁。坦白讲，自柏杨先生《中国人史纲》的开篇后，好多年没再看到这么好的历史类段落了。</p>

<p>书中所论述的一些观点之新颖，视角之新奇，思想之深刻，足可让赫拉利本人创立一个学派，而这些观点和视角完全值得细数一番：</p>

<p>人类相较于其他哺乳动物都是早产儿。</p>

<p>在地球上曾经存在过很多个人种，现在只剩下智人一支，而其他人种的消亡智人有脱不了的干系，就如一些巨形陆生动物的消亡也与智人的出现脱不了干系一样。</p>

<p>使用火，吃上熟食，依旧是人类节省消化能量，促进大脑进化的关键。</p>

<p>人类的崛起，或者说是成为这个世界的主宰的关键，不是会使用工具，而是智人虚构出了一些不存在的东西，如神鬼，宗教，国家，法律，公司等，这是消亡的其他人种和其它动物所没有的。</p>

<p>人类在农业革命之前可能活的是最轻松和健康的，从那之后人类就进入了无尽的辛劳和焦虑，直到今日这种状况也并没有改善，只是换了一种表现形式。</p>

<p>人类的秩序是想象出来的，包括钱，因为人相信这些是真实存在的。</p>

<p>汉谟拉比法典和人权宣言都不能细细推敲，如严格说来都是胡说八道。</p>

<p>书中如上述的一些观点和论述都有更多的细节，可参阅原文，几乎每一条都新是新思路，新视角，使人总有拍案叫绝的冲动。文字也是好文字，使我一个可通读英文书籍没几年的人也感觉没有刻板，不觉晦涩。</p>

<p>好书就该为其写一篇读后感，虽是最俗套的做法，但还是写下了自己的一些感受和领悟。今后回看也好有个参照。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Booster使用小结</title>
	  <link>//summary-of-using-booster</link>
	  <author>Tao He</author>
	  <pubDate>2021-02-20T22:00:00+08:00</pubDate>
	  <guid>//summary-of-using-booster</guid>
	  <description><![CDATA[
	     <p>使用Booster去修复SharedPreferences导致的ANR的版本已全量上架Google Play，SP导致的ANR几乎绝迹，但是随之全量版本的逐步铺开，firebase崩溃后台却出现了Booster所导致的两个比较多的崩溃:</p>

<p>一个是NPE，触发的基本环境如下:</p>

<p>System version 6.0.1</p>

<p>Java version 8</p>

<p>Gradle version 6.6.1</p>

<p>Android Gradle plugin version 4.0.0</p>

<p>Booster version 3.1.0</p>

<p>主要的崩溃机型:Galaxy J2 Prime(76%), Galaxy Grand Neo, Galaxy J3(2016), MAXTRON U22</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Fatal Exception: java.lang.NullPointerException
Attempt to invoke virtual method &#39;java.lang.String java.io.File.getParent()&#39; on a null object reference
com.didiglobal.booster.instrument.sharedpreferences.SharedPreferencesManager.&lt;init&gt; (SharedPreferencesManager.java:36)
com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.&lt;init&gt; (BoosterSharedPreferences.java:42)
com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.getSharedPreferences (BoosterSharedPreferences.java:58)
com.didiglobal.booster.instrument.ShadowSharedPreferences.getSharedPreferences (ShadowSharedPreferences.java:15)
com.google.android.gms.internal.ads.zzabb.initialize (zzabb.java:33)
com.google.android.gms.internal.ads.zzabf.zzi (zzabf.java:15)
com.google.android.gms.internal.ads.zzabe.get (zzabe.java)
com.google.android.gms.ads.internal.util.zzbu.zza (zzbu.java:13)
com.google.android.gms.internal.ads.zzabf.initialize (zzabf.java:1)
com.google.android.gms.internal.ads.zzanc.run (zzanc.java:2)
java.lang.Thread.run (Thread.java:818)
</code></pre></div>
<p>此问题已经在github上提issue给开源团队，经过几次沟通，确定是Booster的bug，开源团队响应极快，在3.3.1版本已修复此问题。</p>

<p>另一个问题Class Cast Exception，基本环境与上面相同，主要发生在 Samsung Android 4, 4.2.2 </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Caused by java.lang.ClassCastException
java.lang.Integer cannot be cast to java.lang.Boolean

com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.getBoolean (BoosterSharedPreferences.java:120)
cn.xiaochuankeji.zuiyouLite.common.instance.SelectGenderDlgManager.&lt;init&gt; (SelectGenderDlgManager.java:95)
cn.xiaochuankeji.zuiyouLite.common.instance.SelectGenderDlgManager.getInstance (SelectGenderDlgManager.java:71)
cn.xiaochuankeji.zuiyouLite.ui.main.MainActivity.onCreate (MainActivity.java:236)
android.app.Activity.performCreate (Activity.java:5112)
android.app.Instrumentation.callActivityOnCreate (Instrumentation.java:1080)
android.app.ActivityThread.performLaunchActivity (ActivityThread.java:2214)
android.app.ActivityThread.handleLaunchActivity (ActivityThread.java:2300)
android.app.ActivityThread.access$700 (ActivityThread.java:156)
android.app.ActivityThread$H.handleMessage (ActivityThread.java:1298)
android.os.Handler.dispatchMessage (Handler.java:99)
android.os.Looper.loop (Looper.java:137)
android.app.ActivityThread.main (ActivityThread.java:5211)
java.lang.reflect.Method.invokeNative (Method.java)
java.lang.reflect.Method.invoke (Method.java:511)
com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:815)
com.android.internal.os.ZygoteInit.main (ZygoteInit.java:582)
dalvik.system.NativeStart.main (NativeStart.java)
</code></pre></div>
<p>此问题目前还未被修复。除了这两个比较崩溃，目前Booster未引入新的问题，并且实实在在的解决了SP的ANR问题，使用线程池优化模块的版本也已上线，目前未发现问题，后续会统计对减少创建线程导致的OOM的贡献。引入Booster也是担着一定的风险，对于一个百万级日活的App，如果出现一个因为第三方工具导致的问题，很有可能导致线上事故，因此在引入前一定要对其做足了调研和评估。</p>

<p>Booster的这种解决问题的方式真的是可谓优雅，不需你更改一行代码，在你使用它提供的gradle插件构建你的工程后，它已默默的为你修复了诸多问题，并且可以根据你的实际情况选择使用不同的功能模块。使用booster以来真的给我很多启发:</p>

<ul>
<li>系统问题也不是不可解决，也许换个思路，就有了办法</li>
<li>开发工具，一定要让它易用，直观，易于理解</li>
<li>开发的功能一定要相对独立，模块化</li>
<li>引入第三方工具钱，一定要做足调研和评估</li>
<li>使用了以后也要做好权衡，如它带来的利是否远大于弊</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>使用Booster解决ANR的实践</title>
	  <link>//using-booster-fix-anr</link>
	  <author>Tao He</author>
	  <pubDate>2021-01-24T22:00:00+08:00</pubDate>
	  <guid>//using-booster-fix-anr</guid>
	  <description><![CDATA[
	     <p>SharedPreferences一直备受诟病，不论是因为开发者的不当使用还是其自身的问题，SharedPreferences都给开发者造成了不少困扰, 尤以ANR最甚。面对由SharedPreferences引起的ANR，我们通常的做法是引入MMKV来替代SP，规避SP本身的缺陷。但是MMKV虽然可以解决App自身由于使用SP导致的ANR，但是无法解决App中第三方库使用SP导致的ANR，因此，虽然MMKV性能优秀，可做数据迁移，久经验证，依然不能彻底解决SP的问题。因此需要考虑其他解决方案，后来找到了滴滴开源的Booster项目，算是找到一个相对彻底的解决方案。</p>

<p>Booster是什么? 请注意，和著名的C++库Boost没半毛钱关系，且看官方介绍:</p>

<blockquote>
<p>Booster 通过 Gradle Plugin 的形式为 Android 工程质量把控提供了一套完整的框架，无论是代码、资源、动态库、依赖关系、包体积、性能等监控，都可以通过 Booster 来完成</p>
</blockquote>

<p>简单理解，Booster就是一个Gradle插件，但它不是一个简单的plugin，而是一个框架，提供了诸多不同功能的模块，可按需在项目构建的时候注入不同的功能模块。下面就以使用Booster SharedPreferences功能模块解决SP相关ANR为例来介绍Booster的基本用法:</p>

<ol>
<li>添加依赖，apply插件:</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">allprojects { project -&gt;
    buildscript {
        ext.booster_version = &#39;3.1.0&#39;
        repositories {
            mavenLocal()
            google()
            mavenCentral()
            jcenter()
            maven { url &#39;https://oss.sonatype.org/content/repositories/public&#39; }
        }
        dependencies {
            classpath &quot;com.didiglobal.booster:booster-gradle-plugin:$booster_version&quot;
            // 使用SharedPreferences功能模块
            classpath &quot;com.didiglobal.booster:booster-transform-shared-preferences:$booster_version&quot;
        }
    }
    repositories {
        mavenLocal()
        google()
        mavenCentral()
        jcenter()
        maven { url &#39;https://oss.sonatype.org/content/repositories/public&#39; }
    }
    project.afterEvaluate {
        if (project.extensions.findByName(&#39;android&#39;) != null) {
            project.apply plugin: &#39;com.didiglobal.booster&#39;
        }
    }
}
</code></pre></div>
<ol>
<li>添加到项目的构建流程中去</li>
</ol>

<p>可以使用-I输入到构建流程中，也可将上述gradle脚本直接集成进project gradle文件，皆可达到目的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// init.gradle即为上面的这段gradle脚本
./gradlew -I init.gradle :app:assembleDebug
</code></pre></div>
<p>在项目构建的过程中输入这段脚本，输出的apk就已使用Booster的SP模块来解决ANR了。使用起来是不是感觉非常简洁，接入很优雅，因为想使用Booster任何一个功能模块，只要简单的添加一句依赖即可，如SP:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// 使用SharedPreferences功能模块
classpath &quot;com.didiglobal.booster:booster-transform-shared-preferences:$booster_version&quot;
</code></pre></div>
<p>如此优雅的框架，是什么原理呢? 还以SP为例来简单聊聊:</p>

<p>根本的原理就是Booster通过 SharedPreferencesTransformer 将所有调用 Context.getSharedPreferences(String, int) 的指令替换成 ShadowSharedPreferences.getSharedPreferences(Context, String, int)，代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class ShadowSharedPreferences {

    public static SharedPreferences getSharedPreferences(final Context context, String name, final int mode) {
        if (TextUtils.isEmpty(name)) {
            name = &quot;null&quot;;
        }
        return BoosterSharedPreferences.getSharedPreferences(name);
    }

    public static SharedPreferences getPreferences(final Activity activity, final int mode) {
        return getSharedPreferences(activity.getApplicationContext(), activity.getLocalClassName(), mode);
    }

}
</code></pre></div>
<p>通过自定义 SharedPreferences 避开 QueuedWork 在 onPause(), onDestroy() 等生命周期回调时在主线程中的同步操作。如果对Booster有基本了解，对Booster这种指令替换的操作应该不陌生。如Booster在解决系统Bug的办法也是通过自定义类来替换有问题的系统类。如果我们使用Android Studio Profiler来查看我们App的内存情况，就可以搜到ShadowSharedPreferences类，此类就是系统SharedPreferences的替换类。</p>

<p>Booster还有其他强大的功能模块有待探索和使用，后续用到后再来聊！</p>

	  ]]></description>
	</item>

	<item>
	  <title>在Android中定制Emoji的实现</title>
	  <link>//custom-emoji-in-android</link>
	  <author>Tao He</author>
	  <pubDate>2021-01-15T22:00:00+08:00</pubDate>
	  <guid>//custom-emoji-in-android</guid>
	  <description><![CDATA[
	     <p>最近公司产品在评论输入中要加入定制emoji面板，因此趟了emoji这个浑水，现以此文记录期间踩过的坑和一些心得。要实现一个相对比较完善的emoji输入和显示的功能，需要解决两个主要的问题: 键盘和emoji表情的平滑切换和emoji的正确显示。前者其实和emoji本身不相关，因此放在后面讨论。先来探究定制emoji的实现方案。 </p>

<p>我们团队内部想到的最快的实现方案是定制googlefonts的NotoColorEmojiCompat.ttf, 使用EmojiCompact加载定制的ttf文件来显示我们定制的emoji。Google官方提供的NotoColorEmojiCompat的使用方法只有两种，一种方式是将NotoColorEmojiCompat.ttf文件放在assets目录，打入apk中使用，另一种方式是不打入apk，而是通过动态查询ContentProvider去查询获得，好处是不用将ttf文件打入apk包，坏处是查询到的ttf文件还是未定制的NotoColorEmojiCompat.ttf文件，实现不了定制的目的。我们的目标是在不打入这样一个7M的ttf文件的情况下实现定制目的，因此官方提供的这两种使用方式都不可取。因此就只剩下一条路，那就是app启动时下载我们定制的ttf文件，在EmojiCompat初始化时自己实现ttf的load过程，从而实现动态加载定制的emoji表情。</p>

<p>创建一个EmojiHelpler类来管理EmojiCompat的初始化和定制ttf的加载:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class EmojiHelper {

    private static Context sContext;
    private static boolean sEmojiReady = false;

    public static void initCompat(Context context) {

        sContext = context;
        //EmojiCompat.Config config = new BundledEmojiCompatConfig(AppContext.get());
        EmojiCompat.Config config = new XLEmojiCompatConfig();

        config.setReplaceAll(true);
        config.registerInitCallback(new EmojiCompat.InitCallback() {
            @Override
            public void onInitialized() {
                super.onInitialized();
                Log.d(&quot;hetaod&quot;, &quot;onInitialized&quot;);
                //XLog.d(&quot;onInitialized&quot;);
            }

            @Override
            public void onFailed(@Nullable Throwable throwable) {
                super.onFailed(throwable);
                Log.d(&quot;hetaod&quot;, &quot;onFailed: &quot; + throwable.getMessage());
                //XLog.printStackTrace(throwable);
            }
        });


        EmojiCompat.init(config);
    }

    public static CharSequence process(CharSequence text) {
        if (sEmojiReady) {
            return EmojiCompat.get().process(text);
        }
        return text;
    }

    private static class XLEmojiCompatConfig extends EmojiCompat.Config {
        XLEmojiCompatConfig() {
            super(new XLMetadataRepoLoader());
        }
    }

    private static class XLMetadataRepoLoader implements EmojiCompat.MetadataRepoLoader {

        @Override
        public void load(@NonNull EmojiCompat.MetadataRepoLoaderCallback loaderCallback) {
            //String filePath = sContext.getCacheDir().getAbsolutePath() + &quot;/NotoColorrEmojiCompat.ttf&quot;;

            File file = new File(&quot;/sdcard/NotoColorEmojiCompat.ttf&quot;);
            FileInputStream fileInputStream = null;
            try {
                fileInputStream = new FileInputStream(file);
                loaderCallback.onLoaded(MetadataRepo.create(Typeface.createFromFile(file.getAbsolutePath()), fileInputStream));
            } catch (IOException e) {
                Log.d(&quot;hetaod&quot;, e.getMessage());
                //XLog.printStackTrace(e);
            } finally {
                //Util.safeClose(fileInputStream);
            }
        }
    }
}
</code></pre></div>
<p>加载定制ttf的关键是继承EmojiCompat和实现EmojiCompat.MetadataRepoLoader接口。在实现了初始化和加载定制ttf后，就剩最后一步，制作定制ttf文件，通过一些emoji的工具，可以轻松制作定制的emoji，我们的实现方式是使用未使用的unicode码来定义我们自己的emoji，在定制的ttf文件制作后以后，下载，初始化，加载，加载失败，卡在了加载这一步，我们定制的ttf文件加载失败，一直报如下的错误:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Cannot read metadata.
</code></pre></div>
<p>我们多次确认制作ttf的方法应该没有问题，但是仍旧加载失败，怀疑是Google做了限制，无法定制这个ttf文件，多次尝试无果后，我们放弃了这个方案。</p>

<p>放弃了上面这个方案后，我们选择了Github上的一个开源实现，简单易用，通过实现一个提供定制表情的provider就可以达到定制的目的。</p>

<p>Github地址: https://github.com/vanniktech/Emoji</p>

<p>使用方法：</p>

<ol>
<li>添加依赖：</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">implementation &#39;com.vanniktech:emoji:0.7.0&#39;
</code></pre></div>
<ol>
<li>实现EmojiProvider接口:</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">//实现EmojiProvider接口
public class CocoEmojiProvider implements EmojiProvider {
    @Override @NonNull
    public EmojiCategory[] getCategories() {
        return new EmojiCategory[] {
                new SimpleCategory()
        };
    }
}


//emoji分类
public class SimpleCategory implements EmojiCategory {
    private static final CocoEmoji[] EMOJIS = CategoryUtils.concatAll(SimpleCategoryChunk0.get());

    @Override @NonNull
    public CocoEmoji[] getEmojis() {
        return EMOJIS;
    }

    @Override @DrawableRes
    public int getIcon() {
        return 0;
    }

    @Override @StringRes
    public int getCategoryName() {
        return 0;
    }
}


// 定制emoji列表定义
final class SimpleCategoryChunk0 {
    @SuppressWarnings(&quot;PMD.ExcessiveMethodLength&quot;) static CocoEmoji[] get() {
        return new CocoEmoji[] {
                new CocoEmoji(0x1F580, new String[]{&quot;Hehe&quot;}, 0, 0, false),
                new CocoEmoji(0x1F581, new String[]{&quot;Mesume&quot;}, 0, 1, false),
                new CocoEmoji(0x1F582, new String[]{&quot;Ngenes&quot;}, 0, 2, false),
                new CocoEmoji(0x1F583, new String[]{&quot;Apaan sih&quot;}, 0, 3, false),
                new CocoEmoji(0x1F584, new String[]{&quot;Ngupil&quot;}, 0, 4, false),
                new CocoEmoji(0x1F585, new String[]{&quot;Bodo&quot;}, 0, 5, false),
                new CocoEmoji(0x1F586, new String[]{&quot;Berdoa&quot;}, 0, 6, false),
                new CocoEmoji(0x1F588, new String[]{&quot;Lempar tai&quot;}, 0, 7, false),
                new CocoEmoji(0x1F589, new String[]{&quot;Bengek&quot;}, 0, 8, false),
                new CocoEmoji(0x1F58E, new String[]{&quot;Jempol&quot;}, 0, 9, false),
                new CocoEmoji(0x1F58F, new String[]{&quot;tepuk tangan&quot;}, 0, 10, false),
                new CocoEmoji(0x1F591, new String[]{&quot;love&quot;}, 0, 11, false),
        };
    }

    private SimpleCategoryChunk0() {
        // No instances.
    }
}
</code></pre></div>
<ol>
<li>在布局中使用支持emoji的控件:</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:padding=&quot;10dp&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;com.vanniktech.emoji.EmojiTextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;30dp&quot;
        android:id=&quot;@+id/quick_textview&quot;
        android:textColor=&quot;@color/CO_T1&quot;
        android:textSize=&quot;25sp&quot;
        android:gravity=&quot;center_horizontal&quot;
        /&gt;

&lt;/RelativeLayout&gt;
</code></pre></div>
<p>在此方案中仍旧是使用未使用的unicode来定义我们定制的emoji，而不是去定一个固定形式的字符串来定义。因此存在兼容老版本的问题，因为我们app的老版本未使用任何定制emoji，这个问题我们目前是简单的通过服务端替换来解决。</p>

<p>解决了emoji的显示问题，就该着手解决emoji面板和键盘平滑切换的问题了。需要键盘和其他面板切换的输入场景下一般的解决方案是使用KPSwitch实现。但是KPSwitch切换界面在嵌入到一个单独的view里面后，切换时有跳闪，体验不是很好，所以这种方案虽然实现起来最快，但是不符合交互要求，所以首先pass，还有一个方案是把emoji面板，键盘都整体做到一个透明的Activity中，和app其他的业务逻辑分离，吊起键盘相当于启动一个透明的activity，和输入相关的功能逻辑都封装到activity中。这种方案虽然隔离性很好，也相对独立，但是需要管理生命周期的问题，对我们现有的输入功能改动较大，所以也pass。排除了两种可行的方案后，要想改动最小，又能实现平滑的体验，就需要做到两点:</p>

<ol>
<li>这个输入功能还是得实现为一个自定义View，而不是一个Activity，这样对现有代码改动最小，影响最小。</li>
<li>要在不使用KPSwitch的情况下实现平滑切换。</li>
</ol>

<p>第一个要求好实现，不在赘述。要实现第二个要求也不是那么难，关键点如下:</p>

<ol>
<li>自定义View的特殊布局</li>
<li>关键的几个布局控制方法</li>
</ol>

<p>先来看布局:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:orientation=&quot;vertical&quot;
        &gt;

        &lt;!--键盘弹起后上，屏幕剩余部分--&gt;
        &lt;View
            android:id=&quot;@+id/layout_input_empty&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;1&quot;
            /&gt;

        &lt;!--键盘及其他交互UI部分--&gt;
        &lt;LinearLayout
            android:id=&quot;@+id/ll_bottom&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:focusable=&quot;true&quot;
            android:clickable=&quot;true&quot;
            android:focusableInTouchMode=&quot;true&quot;
            android:gravity=&quot;center_vertical&quot;

            &gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:orientation=&quot;vertical&quot;
                &gt;

                &lt;cn.xiaochuankeji.zuiyouLite.widget.listener.FrameListenerLayout
                    android:id=&quot;@+id/publisher_top_listener&quot;
                    android:layout_width=&quot;match_parent&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_gravity=&quot;center_vertical&quot;
                    android:paddingLeft=&quot;15dp&quot;
                    android:paddingTop=&quot;5dp&quot;
                    android:paddingRight=&quot;15dp&quot;
                    android:background=&quot;@drawable/replay_comment_bg&quot;
                    &gt;

                    &lt;RelativeLayout
                        android:layout_width=&quot;match_parent&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:gravity=&quot;center_vertical&quot;&gt;

                        &lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.ReplaySomeoneTipView
                            android:id=&quot;@+id/replay_someone_tip_view&quot;
                            android:layout_width=&quot;match_parent&quot;
                            android:layout_height=&quot;wrap_content&quot;
                            android:layout_marginTop=&quot;14dp&quot;
                            android:layout_marginBottom=&quot;3dp&quot;
                            android:visibility=&quot;gone&quot; /&gt;


                        &lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.QuickReplayView
                            android:id=&quot;@+id/quick_replay_view&quot;
                            android:layout_width=&quot;match_parent&quot;
                            android:layout_height=&quot;wrap_content&quot;
                            android:layout_below=&quot;@+id/replay_someone_tip_view&quot;
                            android:layout_marginTop=&quot;11dp&quot; /&gt;

                        &lt;LinearLayout
                            android:id=&quot;@+id/edit_scroll&quot;
                            android:layout_width=&quot;match_parent&quot;
                            android:layout_height=&quot;wrap_content&quot;
                            android:orientation=&quot;vertical&quot;
                            android:background=&quot;@drawable/comment_edit_bg&quot;
                            android:padding=&quot;8dp&quot;
                            android:layout_below=&quot;@+id/quick_replay_view&quot;
                            android:layout_toLeftOf=&quot;@+id/publisher_send_new&quot;
                            android:layout_marginBottom=&quot;12dp&quot;
                            &gt;

                            &lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.PostCommentEditText
                                android:id=&quot;@+id/publisher_edit&quot;
                                android:layout_width=&quot;match_parent&quot;
                                android:layout_height=&quot;wrap_content&quot;
                                android:background=&quot;@color/CO_B3&quot;
                                android:hint=&quot;@string/comment_input_comment&quot;
                                android:lineSpacingExtra=&quot;2.4dp&quot;
                                android:maxLength=&quot;2000&quot;
                                android:maxLines=&quot;3&quot;
                                android:minLines=&quot;1&quot;
                                android:textColor=&quot;@color/CO_T1&quot;
                                android:textColorHint=&quot;@color/CO_T3&quot;
                                android:textCursorDrawable=&quot;@drawable/cursor_yellow&quot;
                                android:textSize=&quot;13sp&quot; /&gt;
                            &lt;!-- 选中的 视频/图片 文件列表 --&gt;
                            &lt;androidx.recyclerview.widget.RecyclerView
                                android:id=&quot;@+id/publisher_select_media_list&quot;
                                android:layout_below=&quot;@+id/publisher_edit&quot;
                                android:layout_width=&quot;wrap_content&quot;
                                android:layout_height=&quot;match_parent&quot;
                                android:layout_alignLeft=&quot;@+id/publisher_edit&quot;
                                android:layout_alignRight=&quot;@+id/publisher_edit&quot;
                                android:layout_marginTop=&quot;7dp&quot;
                                android:visibility=&quot;gone&quot; /&gt;
                        &lt;/LinearLayout&gt;


                        &lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&quot;@+id/publisher_send_new&quot;
                            android:layout_width=&quot;24dp&quot;
                            android:layout_height=&quot;24dp&quot;
                            android:layout_marginLeft=&quot;15dp&quot;
                            android:layout_alignBottom=&quot;@id/edit_scroll&quot;
                            android:layout_marginBottom=&quot;4dp&quot;
                            android:layout_alignParentRight=&quot;true&quot;
                            android:background=&quot;@drawable/selector_chat_send&quot; /&gt;


                        &lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&quot;@+id/publisher_image_new&quot;
                            android:layout_width=&quot;36dp&quot;
                            android:layout_height=&quot;36dp&quot;
                            android:paddingRight=&quot;12dp&quot;
                            android:paddingBottom=&quot;12dp&quot;
                            android:layout_below=&quot;@+id/edit_scroll&quot;
                            android:src=&quot;@drawable/ic_comment_select_image&quot; /&gt;

                        &lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&quot;@+id/publisher_emoji&quot;
                            android:layout_width=&quot;36dp&quot;
                            android:layout_height=&quot;36dp&quot;
                            android:layout_below=&quot;@+id/edit_scroll&quot;
                            android:layout_toRightOf=&quot;@id/publisher_image_new&quot;
                            android:paddingLeft=&quot;12dp&quot;
                            android:paddingBottom=&quot;12dp&quot;
                            android:src=&quot;@drawable/ic_comment_cocoemoji&quot; /&gt;

                        &lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&quot;@+id/publisher_at_new&quot;
                            android:layout_width=&quot;36dp&quot;
                            android:layout_height=&quot;36dp&quot;
                            android:layout_below=&quot;@id/edit_scroll&quot;
                            android:layout_toRightOf=&quot;@id/publisher_emoji&quot;
                            android:layout_marginLeft=&quot;12dp&quot;
                            android:paddingLeft=&quot;12dp&quot;
                            android:paddingBottom=&quot;12dp&quot;
                            android:src=&quot;@drawable/ic_comment_at&quot; /&gt;

                    &lt;/RelativeLayout&gt;


                &lt;/cn.xiaochuankeji.zuiyouLite.widget.listener.FrameListenerLayout&gt;


                &lt;!--emoji面板--&gt;
                &lt;FrameLayout
                    android:id=&quot;@+id/fl_bottom&quot;
                    android:layout_width=&quot;match_parent&quot;
                    android:layout_height=&quot;300dp&quot;
                    android:background=&quot;#f5f7fa&quot;
                    android:visibility=&quot;gone&quot;
                    &gt;

                    &lt;androidx.recyclerview.widget.RecyclerView
                        android:id=&quot;@+id/rv_emoji&quot;
                        android:layout_width=&quot;match_parent&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:paddingTop=&quot;5dp&quot;
                        android:paddingLeft=&quot;5dp&quot;
                        android:paddingRight=&quot;5dp&quot;
                        /&gt;

                    &lt;androidx.appcompat.widget.AppCompatImageView
                        android:id=&quot;@+id/iv_emoji_delete&quot;
                        android:layout_width=&quot;54dp&quot;
                        android:layout_height=&quot;40dp&quot;
                        android:src=&quot;@drawable/ic_comment_delete&quot;
                        android:scaleType=&quot;centerInside&quot;
                        android:layout_gravity=&quot;bottom|right&quot;
                        android:layout_marginRight=&quot;15dp&quot;
                        android:layout_marginBottom=&quot;15dp&quot;
                        android:shadowColor=&quot;#33000000&quot;
                        android:shadowDx=&quot;3.0&quot;
                        android:background=&quot;@drawable/emoji_delete_bg&quot;
                        /&gt;


                &lt;/FrameLayout&gt;

            &lt;/LinearLayout&gt;
        &lt;/LinearLayout&gt;
    &lt;/LinearLayout&gt;
</code></pre></div>
<p>动态代码中几个关键的方法:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
  * 锁定内容View以防止跳闪
  */
public void lockContentViewHeight() {
    LinearLayout.LayoutParams layoutParams =
            (LinearLayout.LayoutParams) layout_input_empty.getLayoutParams();
    layoutParams.height = layout_input_empty.getHeight();
    layoutParams.weight = 0;
    layout_input_empty.requestLayout();
}

/**
  * 释放锁定的内容View
  */
public void unlockContentViewHeight() {
    postDelayed(() -&gt; {
        LinearLayout.LayoutParams layoutParams =
                (LinearLayout.LayoutParams) layout_input_empty.getLayoutParams();
        layoutParams.height = 0;
        layoutParams.weight = 1;
        //rc_content.requestLayout();
        ll_bottom.requestLayout();
        //requestLayout();
    }, 200);
}


public void hideEmoji() {
    iv_emoji.setImageResource(R.drawable.ic_comment_cocoemoji);
    lockContentViewHeight();
    rv_emoji.setVisibility(View.GONE);
    fl_bottom.setVisibility(GONE);
    unlockContentViewHeight();
    presentStatus = PublisherStatus.文字编辑;
    emojiVisible = false;
}

public void showEmoji(boolean animate) {
    iv_emoji.setImageResource(R.drawable.ic_comment_keyboard);
    if (!animate) {
        lockContentViewHeight();
        rv_emoji.setVisibility(View.VISIBLE);
        fl_bottom.setVisibility(VISIBLE);
        unlockContentViewHeight();
    } else {
        rv_emoji.setVisibility(View.VISIBLE);
        fl_bottom.setVisibility(VISIBLE);
    }
    //UIUtils.hideSoftInput((Activity) getContext());
    AndroidPlatformUtil.hideSoftInput((Activity) getContext());
    presentStatus = PublisherStatus.EMOJI;
    emojiVisible = true;
}
</code></pre></div>
<p>如何调用：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void onEmojiClick() {
    if (rv_emoji.getVisibility() == View.VISIBLE) {
        lockContentViewHeight();
        hideEmoji();
        unlockContentViewHeight();
        //UIUtils.showSoftInput(et_comment, getContext());
        AndroidPlatformUtil.showSoftInput(et_comment, getContext());
    } else {
        showEmoji(false);
    }
}
</code></pre></div>
<p>其实实现这个方案后，我也有点惊讶，KPSwitch那么复杂的逻辑，竟然可以简单的以这种方式实现。说明做一切事情都不可拘泥于过去成功的方案，应该大胆尝试新的方法，说不定就能收获到惊喜呢！</p>

	  ]]></description>
	</item>

	<item>
	  <title>First Lesson of Machine Learning</title>
	  <link>//first-lesson-of-machine-learning</link>
	  <author>Tao He</author>
	  <pubDate>2020-12-01T04:54:12+08:00</pubDate>
	  <guid>//first-lesson-of-machine-learning</guid>
	  <description><![CDATA[
	     <p>Two months ago, I made a decision for my career: learning machine learning from scratch. Machine learning involves many stuff of math while math is difficult. But I didnot give up in half way this time. Books, Youtube lectures, blogs, I collect learning materials as much as I can and do my best to learning it. 60 days passed, I have had a clarity understanding about some important concepts of Machine learing. In this article, I will figure out these concepts and their relations through 2 figures.</p>

<p><strong>Figure 1</strong> </p>

<p>This figure seems simple, but it reveals the relations of some important concepts.</p>

<p><img src="/assets/images/scratch_ml.jpg" /></p>

<p><strong>Figure 2</strong> </p>

<p>This figure describes more detail.</p>

<p><img src="/assets/images/machine_learning.png" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>Review Matrix</title>
	  <link>//review-matrix</link>
	  <author>Tao He</author>
	  <pubDate>2020-11-23T04:54:12+08:00</pubDate>
	  <guid>//review-matrix</guid>
	  <description><![CDATA[
	     <p>Linear Algebra is prerequisite for Machine Learning while Matrix is the one of most important stuff in Linear Algebra. It is difficult to learn ML well in case of not 
familiar with Matrix. So it is time to review a few aspects of Matrix. Because of complexity of mathematical formula input, I will skip some details in main text, but attach them in three images(output from my Inkredible notes).</p>

<p><strong>Image 1</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201913.png" /></p>

<p>Image 1 involves:</p>

<ul>
<li><p>Matrix Definition</p></li>
<li><p>Matrix Addition and Multiplication</p></li>
</ul>

<p><strong>Image 2</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201928.png" /></p>

<p>Image 2 involves:</p>

<ul>
<li><p>Identity Matrix </p></li>
<li><p>Properties of Matrix:</p>

<ul>
<li>Not Commutative</li>
<li>Associativity</li>
<li>Distributivity</li>
</ul></li>
<li><p>Multiplication with the Identity Matrix</p></li>
<li><p>Inverse and Transpose</p></li>
</ul>

<p><strong>Image 3</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201950.png" /></p>

<p>Image 3 involves:</p>

<ul>
<li><p>Symetric Matrix</p></li>
<li><p>Multiplication by a Scalar</p></li>
<li><p>Compat Representation of System Linear Equation</p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Android module SDK化的实践</title>
	  <link>//using-maven-to-mananger-library</link>
	  <author>Tao He</author>
	  <pubDate>2020-11-21T04:54:12+08:00</pubDate>
	  <guid>//using-maven-to-mananger-library</guid>
	  <description><![CDATA[
	     <p>文章标题指的SDK化指的是将一个有多个module的Android工程中的特定module以aar的形式输出后被app模块依赖使用。那么如何在基本不改动代码的情况下实现这个要求，完成app模块对特定module的依赖呢?</p>

<p>最直接的想法就是把要SDK化的module输出为aar文件，然后在app模块添加对此aar文件的依赖。在解决完所有的编译错误以后，运行app后发生了crash，查看输出，是因为输出为aar的这个模块所依赖的一个类在运行时找不到，事实上就是这个远端依赖没有被打进apk包。很明显，直接输出aar然后依赖是不可行的。</p>

<p>远端依赖的类找不到，因为此module在输出为aar的时候并未将他的依赖打入aar包，那有没有办法将此module的所有依赖都打进aar包呢? 在线上搜索了一番后，还真找到了这样的一个gradle插件<a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a>来做这件事，接入到工程中很简单:</p>

<ol>
<li>应用插件</li>
</ol>

<p>在project build gradle文件中加入如下代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:xxx&#39;
        classpath &#39;com.kezong:fat-aar:1.2.20&#39;
    }
}
</code></pre></div>
<ol>
<li>使用插件关键字来嵌入依赖</li>
</ol>

<p>将需要嵌入的依赖，修改implementation或api为embed</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dependencies {
    implementation fileTree(dir: &#39;libs&#39;, include: &#39;*.jar&#39;)
    // java dependency
    embed project(path: &#39;:lib-java&#39;, configuration:&#39;default&#39;)
    // aar dependency
    embed project(path: &#39;:lib-aar&#39;, configuration:&#39;default&#39;)
    // aar dependency
    embed project(path: &#39;:lib-aar2&#39;, configuration:&#39;default&#39;)
    // local full aar dependency, just build in flavor1
    flavor1Embed project(path: &#39;:lib-aar-local&#39;, configuration:&#39;default&#39;)
    // local full aar dependency, just build in debug
    debugEmbed (name:&#39;lib-aar-local2&#39;,ext:&#39;aar&#39;)
    // remote jar dependency
    embed &#39;com.google.guava:guava:20.0&#39;
    // remote aar dependency
    embed &#39;com.facebook.fresco:fresco:1.11.0&#39;
    // don&#39;t want to embed in
    // implementation is not recommended because the dependency may be different with the version in application, resulting in the R class not found.
    compileOnly &#39;com.android.support:appcompat-v7:27.1.1&#39;
}
</code></pre></div>
<p>使用此插件除了会遇到资源冲突外，目前没有发现其他问题。但这个插件在github上的issue有点多，心里有点没底，所以还需要想其他的办法。</p>

<p>这两个方法被排除后，就想到用maven来管理依赖，更灵活，是更一般的做法。 将此module输出后上传到maven服务器，在app上添加对此module的远程依赖后，发现无法编译，找不到此module依赖中的类，这是因为没有在pom中添加依赖。将aar发布到maven和添加依赖配置的代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">afterEvaluate {
    publishing {
        publications {
            release(MavenPublication) {
                artifact(&quot;$buildDir/outputs/aar/live-debug.aar&quot;) {
                    builtBy tasks.getByName(&quot;assembleDebug&quot;)
                }

                groupId = &quot;com.overseas.android.live&quot;
                artifactId = &#39;live&#39;
                version = &#39;1.0.8&#39;

                pom.withXml {
                    def dependenciesNode = asNode().appendNode(&quot;dependencies&quot;)
                    configurations.compile.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;compile&quot;) }
                    configurations.api.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;compile&quot;) }
                    configurations.implementation.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;runtime&quot;) }
                }
            }
        }

        repositories {
            maven {
                url = uri(&quot;https://xxx/repository/android-release/&quot;)

                credentials {
                    username = &quot;hetao&quot;
                    password = &quot;hetao&quot;
                }
            }
        }
    }
}
</code></pre></div>
<p>在用maven管理依赖时需要注意一下几点:</p>

<ul>
<li><p>需要关注发布的module是不是有远程依赖，有的话需要添加依赖配置</p></li>
<li><p>需要发布的module输出为debug版本，统一由app模块去做混淆</p></li>
<li><p>需要发布的module的混淆规则不能被遗漏，需要添加此配置:</p></li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">defaultConfig {
    ...

    consumerProguardFiles &#39;proguard-rules.pro&#39;

    ...

}
</code></pre></div>
<p>不然会有因为混淆而找不到类的问题。</p>

	  ]]></description>
	</item>


</channel>
</rss>
