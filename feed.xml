<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>与机器，人，神共舞</title>
    <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
    <link>http://longlinht.github.io/</link>
    <atom:link href="http://longlinht.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>优化App网络连通性问题</title>
        <description>&lt;p&gt;最近遇到一个棘手的问题，我们开发的一款App在中东那边出现大量的&lt;code&gt;UnknownHostException&lt;/code&gt;, 导致App在中东那边体验很糟，很快这个问题就被抛给了我们技术优化组，我和另外一名同事就开始定位问题的原因并且试图提出一个可行的解决方案。一般理解，出现&lt;code&gt;UnkownHostException&lt;/code&gt;就是DNS失败了，在我们开始解决这个问题的时候，App的网络库已逐渐开始使用OkHttp，我们想到自定义DNS过程，在系统DNS失败的情况下再尝试其他DNS方式，降低&lt;code&gt;UnknownHostException&lt;/code&gt;出现的频率，优化App网络连通性。
为了实现我们的技术方案，我们针对OkHttp的DNS做了如下几件事:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建OkHttpClient时自定义DNS&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;OkHttpClient.Builder builder = new OkHttpClient.Builder()
    // 实现OKHttp DNS接口, 改变默认的DNS行为
    .dns(OkHttpDns.getInstance())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的OkHttpDns须实现Dns接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现自定义DNS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前我们的设计是使用责任链模式实现四层DNS的lookup: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第一层是本地DNS缓存(Local Cache)，整个缓存只是内存缓存，DNS过程开始时，先去本地缓存找，如果在缓存中没有命中，就走系统DNS， 系统DNS如果也失败，整个链条就继续往下，到GA，到Google DNS，如果到Google DNS还没有解析成功，仍旧抛出&lt;code&gt;UnknownHostException&lt;/code&gt;，DNS过程失败。基本的代码逻辑如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private OkHttpDns() {

  //使用责任链模式实现四层DNS的lookup: Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
  mDnsChain = new CacheDnsHandler();

  SystemDnsHandler okhttp = new SystemDnsHandler();
  GADnsHandler ga = new GADnsHandler();
  GoogleHttpDnsHandler google = new GoogleHttpDnsHandler();

  mDnsChain.setTarget(okhttp);
  okhttp.setTarget(ga);
  ga.setTarget(google);
}

@Override
public List&amp;lt;InetAddress&amp;gt; lookup(String hostname) throws UnknownHostException {
  // IP直连的情况,直接返回
  if (InetAddressValidator.isIPAddress(hostname)) {
      return Arrays.asList(InetAddress.getAllByName(hostname));
  }

  List&amp;lt;InetAddress&amp;gt; allDNSResult = new ArrayList&amp;lt;&amp;gt;();
  List&amp;lt;InetAddress&amp;gt; list = mDnsChain.lookup(hostname, allDNSResult);

  if (list == null) {

      // DNS完全失败后,清空黑名单,删除local cache相应的条目
      IPStatusCache.getInstance().clear();

      if (allDNSResult.isEmpty()) {
          throw new UnknownHostException(&amp;quot;Broken system behaviour for dns lookup of &amp;quot; + hostname);
      } else {
          return allDNSResult;
      }
  }
  return list;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加黑名单机制，进一步优化DNS
一次连接成功后缓存DNS结果，host+ip为key，IPStatus为value，连接失败后会更新DNS缓存的失败次数，超过5次则认为进入了黑名单，在每次DNS完全失败后清空本地DNS缓存，防止所有的缓存都进入黑名单，缓存失效。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理IP直连的情况
这种情况的处理很简单，检查传入的host是不是ip，如果是就直接返回。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过这样的优化以后，&lt;code&gt;UnknownHostException&lt;/code&gt;在请求失败中的比重和请求的总失败率大幅下降，验证了我们这个技术方案的合理性，可以说网络连通性大大提高，再次回顾这个方案，突然发现它其实一个通用的解决方案，虽然我们这次解决的是海外，如中东地区的连通性问题，其实这个方案完全可以移植到国内，只要将Google HttpDNS换成国内的HttpDNS即可，整体的DNS流程可以不做任何改动即可成为一个完整的App DNS解决方案。&lt;/p&gt;
</description>
        <pubDate>Wed, 29 May 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//connectivity-in-android</link>
        <guid isPermaLink="true">http://longlinht.github.io//connectivity-in-android</guid>
      </item>
    
      <item>
        <title>三星折叠屏适配小计</title>
        <description>&lt;p&gt;三星要在近期发布折叠屏手机，消息一出，我们就得抓紧做适配，也没有什么现成的经验作参考，尤其令人头疼的是还没有真机供我们测试。没办法，兵来将挡，水来土掩，进过一周多的调研和开发，终于做完了大部分App页面的适配工作，也因为做这个适配的过程踩了很多坑，特写下这篇小记。&lt;/p&gt;

&lt;p&gt;在我们开始做适配前，首先要解决没有真机可做测试的问题，无法验证适配的效果，还好三星也想到了这个问题，在官网提供了一个模拟器应用，Foldable Emulator， 通过这个模拟器App可以在Fold和Unfold模式之间自由切换，验证适配效果。当我们适配工作结束后在真机上测试时发现，这个模拟器的仿真度极高，基本没有出现和真机上效果有出入的地方。&lt;/p&gt;

&lt;p&gt;在解决了没有真机的问题之后，我们就开始着手真正的适配工作。首先遇到的问题就是折叠屏手机需要在Fold和Unfold之间频繁切换，而这种切换的效果和横竖屏切换是一样的，默认都会导致Activity重建，而Activity重建又会导致一系列的连锁反应，如需要恢复大量数据、重新建立网络连接或执行其他密集操作，因此在适配前就需要规划哪些页面(Activity)需要重建，哪些不需要重建，所以需要按Activity是否重建这两种情况来分析切屏的后果和应对方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重建Activity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。 此外，依靠系统通过onSaveInstanceState() 回调保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。当 Android 系统因配置变更而关闭 Activity 时，不会销毁已标记为要保留的 Activity 的片段。 可以将此类片段添加到 Activity 以保留有状态的对象。
要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;扩展 Fragment 类并声明对有状态对象的引用&lt;/li&gt;
&lt;li&gt;在创建片段后调用 setRetainInstance(boolean)&lt;/li&gt;
&lt;li&gt;将片段添加到 Activity&lt;/li&gt;
&lt;li&gt;重启 Activity 后，使用 FragmentManager 检索片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如，按如下方式定义片段：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class RetainedFragment extends Fragment {

    // 想要保存的数据
    private MyDataObject data;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 保存这个fragment
        setRetainInstance(true);
    }
    public void setData(MyDataObject data) {
        this.data = data;
    }

    public MyDataObject getData() {
        return data;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，使用 &lt;code&gt;FragmentManager&lt;/code&gt; 将片段添加到 &lt;code&gt;Activity&lt;/code&gt;。在运行时配置变更期间再次启动 &lt;code&gt;Activity&lt;/code&gt; 时，可以获得片段中的数据对象。 例如，按如下方式定义 Activity：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class MyActivity extends Activity {
    private RetainedFragment retainedFragment;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        // 在activity重启后，获取保留的fragment
        FragmentManager fm = getFragmentManager();
        retainedFragment = (RetainedFragment) fm.findFragmentByTag(“data”);
        // 首次创建
        if (retainedFragment == null) {
            // 添加fragment
            retainedFragment = new RetainedFragment();
            fm.beginTransaction().add(retainedFragment, “data”).commit();
            // 从网络获取data
            retainedFragment.setData(loadMyData());
        }
        // retainedFragment.getData()获取的数据可用
        ...
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        // store the data in the fragment
        retainedFragment.setData(collectMyLoadedData());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onCreate() 添加了一个片段或恢复了对它的引用。此外，onCreate() 还将有状态的对象存储在片段实例内部。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;尽管Fragment内部可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;不重建Activity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果想不重新启动的情况下处理配置更改，则需要在清单中添加一个android：configChanges属性，例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;activity
    android:name=&amp;quot;......CMVideoPlayerActivity&amp;quot;
    android:configChanges=&amp;quot;screenSize|smallestScreenSize|screenLayout&amp;quot;
/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要手动更新视图布局并在onConfigurationChaged（）中重新加载资源&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onConfigurationChanged(Configuration newConfig) {
   super.onConfigurationChanged(newConfig);
   if ((newConfig.screenLayout &amp;amp; Configuration.SCREENLAYOUT_LONG_MASK) == Configuration.SCREENLAYOUT_LONG_YES) {

   }
   if ((newConfig.screenLayout &amp;amp; Configuration.SCREENLAYOUT_LONG_MASK ) == Configuration.SCREENLAYOUT_LONG_NO) {

   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在遵循上述基本原则以后，就要应对实际的适配问题了，整个适配的工作主要涉及以下几个问题的解决:&lt;/p&gt;

&lt;h4&gt;检测设备是否可折叠,当前是Fold状态还是Unfold，并且能够在切屏时通知到需要对切屏事件作出处理的页面&lt;/h4&gt;

&lt;p&gt;为了统一解决这个问题，设计了一个单例类来统一管理&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class FoldObserable extends Observable {

    public static final int SCREEN_LARGE_WIDTH = 1536;

    public static final int SCREEN_LARGE = 0;
    public static final int SCREEN_SMALL = 1;

    private static class SINGLE {
        public static FoldObserable INSTANCE = new FoldObserable();
    }

    private FoldObserable() {
        String model = android.os.Build.MODEL;
        if (model.contains(&amp;quot;SM-F9000&amp;quot;)) {
            canFlod = true;
            if (isLargeScreen()) {
                screenType = SCREEN_LARGE;
            } else {
                screenType = SCREEN_SMALL;
            }
        }
    }
    //大屏无statusbar 小屏有statusbar，根据此来判断是是否减bar
    private int screenType;
    private boolean canFlod;

    public static FoldObserable getInstance() {
        return SINGLE.INSTANCE;
    }

    public void setScreenType(int screenType) {
        this.screenType = screenType;
        setChanged();
        notifyObservers();
    }

    public int getScreenType() {
        return screenType;
    }

    /**
     * 是否是折叠屏
     * @return
     */
    public boolean getCanFlod() {
        return canFlod;
    }

    private boolean isLargeScreen() {
        WindowManager wm = (WindowManager) BloodEyeApplication.getInstance().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point pp = new Point();
        display.getSize(pp);
        return pp.x == FoldObserable.SCREEN_LARGE_WIDTH;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为要通过这个单例还通知需要响应切屏事件的页面，所以需要在App的所有Activity基类的onConfigurationChanged中调用setScreenType来通知所有的观察者，这些观察者就是需要相应切屏事件的Activigty和Fragment。代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (FoldObserable.getInstance().getCanFlod()) {
        UiProcessTask.updateScreenSize();
        boolean isLargeScreen = isLargeScreen();
        if (isLargeScreen) {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_LARGE);
        } else {
            FoldObserable.getInstance().setScreenType(FoldObserable.SCREEN_SMALL);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将需要响应切屏的页面注册为观察者:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    FoldObserable.getInstance().addObserver(this);
}

@Override
public void onDestroy() {
  super.onDestroy();
  FoldObserable.getInstance().deleteObserver(this);
}

// 处理切屏事件
@Override
public void update(Observable o, Object arg) {
  if (o instanceof FoldObserable) {
      mAdapter.notifyDataSetChanged();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;处理实际的可能因为各种原因导致的适配问题&lt;/h4&gt;

&lt;p&gt;经过模拟器的测试发现App种有很多页面在Fold和Unfold切换后出现适配问题，总结起来有如下几种情况:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码中为了提高测量和绘制View的性能，缓存了屏幕的宽度，导致一些用了屏幕宽度的地方使用了切换前的屏幕宽度的旧值，导致宽度适配错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：在屏幕切换的时候更新缓存&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有些没有重建的页面，RecyclerView的Adapter在Fold和Unfold切换以后没有重新回调onBindView，导致Item的大小适配错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法: 在屏幕切换时手动调用Adapter的notifyDataSetChanged()去刷新列表&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;布局xml文件中写死了一些控件的宽度，导致适配问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：尽量不要使用写死的值，推荐使用match_parent + margin或padding来应对这种情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在切屏时未能及时更新与界面宽高相关的全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决办法: 在Application的onConfigurationChanged中更新相关变量&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static void updateScreenSize() {

}


// 在Application中调用
@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    updateScreenSize();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在适配的过程中具体的问题可能都不一样，但是都跑不出这几类，只要抓住本质，一般都能得到很好的解决。比较麻烦的适配工作可算搞完了，第二天就得到三星跳票的消息，也是服气！&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//sumsung-foldable-adapt</link>
        <guid isPermaLink="true">http://longlinht.github.io//sumsung-foldable-adapt</guid>
      </item>
    
      <item>
        <title>加速Gradle构建</title>
        <description>&lt;p&gt;最近刚换工作，来这家新公司没几天，还在熟悉和适应阶段，leader也没安排什么特别的事情，只是说有空可以看看我们工程Gradle Build速度慢的问题。总算接到一个方向比较明确的任务，正好可以从工程的构建流程入手，可以一窥整个工程的结构和依赖。因为Gradle构建速度慢这个问题，其实有一些常见的排查方法，解决问题第一步，还是用最快的排查法，首先排除一些最常见的造成构建速度缓慢的原因。但是要找出构建速度慢的问题也需要将问题分情况来看，分两种情况，一种是在开发过程中的构建和正式发版上线的构建，这两种构建通常是相同的，但有时为了节约开发过程中的构建时间，会做一些特殊的设置和开启关闭一些选项来加速开发过程中的构建，因此，这两种情况面临的问题其实是类似的，因为还不是很清楚leader更在意的是开发过程中的构建时间还是发布上线的构建，因此我决定把这两种情况合二为一，罗列出所有的加速建议:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查是否使用了最新的Android Gradle Plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然了，这个排查不是硬性的，得看实际情况，但是如果能升到最新的插件版本，建议升级，随着插件的逐步完善，性能也会有很大提升&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;尽量少用Module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有技术博文称Module的构建时间可能是jar和aar的4倍（有待验证）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Property选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在gradle.property文件中添加如下两行代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.configureondemand=true

// 这些值可以按实际情况设置
org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免在 minSdkVersion &amp;lt; 21 时使用Multidex&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Disable Multi-APK(限开发中的构建)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你没有使用ABI或者Density splits， 你可以略过，如果你使用了，可以通过在Gradle文件里添加如下代码关闭这个选项，可以节省开发中的很多构建时间:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android {
   if (project.hasProperty(‘devBuild’)){
      splits.abi.enable = false
      splits.density.enable = false
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;最小化打包资源(限开发中的构建)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在开发过程中，其实没必要打包所有App用到的资源，我们可以通过配置来控制开发构建中要打包的资源, 可在Gradle文件中加入如下代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;productFlavors {
  development {
    minSdkVersion 21
    //only package english translations, and xxhdpi resources   
    resConfigs (“en”, “xxhdpi”)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;别小看这点改动，可能节省你很多开发中的构建时间&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Disable PNG 优化 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PNG优化是默认开启的，但是在开发中的构建没什么必要，建议关闭 :&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android {
  if (project.hasProperty(‘devBuild’)){
    aaptOptions.cruncherEnabled = false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用Instant Run&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然这个功能有时会有一些问题，但是在加速构建方面还是很有用的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;避免很耗时的计算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def buildDateTime = new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种代码在开发构建种就不要出现了， 因为每次构建都要重新一次额外的处理和打包，可以改为这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def buildDateTime = project.hasProperty(‘devBuild’) ? 100 : new Date().format(‘yyMMddHHmm’).toInteger()
android {
  defaultConfig {
    versionCode buildDateTime
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个陷阱是Crashlytics build IDs, Crashlytics在每一次构建时都会产生一个新的id，一行代码就可将这个选项关闭:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;apply plugin: ‘io.fabric’
android {
  buildTypes {
    debug {
      ext.alwaysUpdateBuildId = false
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;避免使用动态的依赖版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用动态的依赖版本号会导致Gradle检查新的依赖版本，导致解析时间加长, 严重拖慢构建速度&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开启Gradle Cache&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;org.gradle.caching=true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在将这些建议和排查方法逐一的排查验证了一遍以后，发现这些Tips公司的工程都已采纳，一些坑也都完美的躲过，要想在这种情况下再去加速Gradle的构建速度，可就没那么容易了，必须通过一些方法，细化整个构建过程，找出一些耗时过长的操作，幸运的是，Gradle已经提供了这种功能，可以输出一个Gradle构建的profile报告，只要在苟建时添加一个参数即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew :android:assembleDebug --profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建结束后会在build的子目录下生成一个html文件的报告：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/7033bf1dly1g295fu83jyj20lz0ccabp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;整个报告里面会比较详细的列出构建过程中Configuration，Dependency Resolution， Task Execution的具体耗时，非常详细和直观，有助于分析构建每个阶段的耗时。建议在分析构建过程的时候用起来。我就用这个选项也为公司的工程打了这样一份报告出来，并没有什么特别的发现，主要的耗时还好在app模块。那这样下去还是不能解决问题，因为我们的发布和上线构建是在Jekins上打包，看了打包脚本也并没有太多特殊的地方，于是我想到用Gradle build scan插件来进一步审视构建内部的情况。&lt;/p&gt;

&lt;p&gt;为自己的工程创建build scan其实比较简单，具体步骤如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Project的build.gradle文件添加下面几行代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &amp;#39;com.android.tools.build:gradle:3.0.0&amp;#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

// 这7行是添加的
plugins {
    id &amp;#39;com.gradle.build-scan&amp;#39; version &amp;#39;1.16&amp;#39;
}
buildScan {                     
    licenseAgreementUrl = &amp;#39;https://gradle.com/terms-of-service&amp;#39;
    licenseAgree = &amp;#39;yes&amp;#39;
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在控制台执行命令 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew build --scan
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;命令执行完后会给出一个网址，打开网址根据提示就可以得到相应的构建审核内容，如下图:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/7033bf1dly1g297i2yza3j20zh0ff41e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;经过这个插件工具的分析，也仍旧没有发现什么异常，看来公司的工程就是因为太大了，每个版本的自然增长导致当前的构建比很早一个版本的慢，虽然这次的调研没有提升打包速度，但是整个调研的构成让我了解了很多与Gradle有关的东西，也算是收获不少, 没有白忙活。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Mar 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//speed-up-gradle-build</link>
        <guid isPermaLink="true">http://longlinht.github.io//speed-up-gradle-build</guid>
      </item>
    
      <item>
        <title>移动应用中的典型页面</title>
        <description>&lt;p&gt;今天这篇文章不做具体技术细节的探讨，而是来观察诸多移动应用中反复出现，具有典型特征和重要作用的一些页面来一窥一般移动应用的基本结构。这些反复出现的页面原型可以归纳为如下六类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录注册页面 - 但凡有账户系统的业务这种页面就不可或缺&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流式页面(内容，信息流) - 这种页面可能就是App主页，用户可以通过滑动页面中的列表去看到多余一屏的内容&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;详情页面 - 这个页面是对流式页面的补充，可能流式页面展示的信息只是缩略图或者摘要，用户想要看到更多详细的内容就需要跳转至此页面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建页面 - 是App承载的内容的来源页面，用户可通过此页面创建内容和资源&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户主页 - 用户账户信息的详情页&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置页面 - 这个页面几乎是每一个App都会有的，无论你的App有多简单，也是需要这个页面来允许用户对App做出配置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了这六种些典型的主要页面以外，还会经常遇到一些扩展的页面，或者说是子页面，包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;闪屏页面(Splash) &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新手引导&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;地图视图&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息(聊天)页面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日历&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;媒体播放页面&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有App，无论规模大小，其实都是这些典型页面的组合构建出来的，所以在开发过程中需要注意你所开发的页面是不是这些典型页面中的一种，如果不是，需要你反思这个页面是否需要，设计是否合理。虽然国内一些超级App已经变得非常巨大和复杂，但是也并没有标新立异，超出这些典型页面的范围，一来需要追求用户体验的一致性，二来这种做法已经成了一个大家默认遵守的规范。所以用户在使用不同的App时没有强烈的陌生感，就如同一个会开车的人，换辆其他品牌的车他仍旧会开，并不会产生疏离感。如果细细观察下来，一些扩展页面的情况会很多，但是主要的典型页面应该不会超过如上的六种。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Feb 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//typical-pages-in-mobile-app</link>
        <guid isPermaLink="true">http://longlinht.github.io//typical-pages-in-mobile-app</guid>
      </item>
    
      <item>
        <title>解决ScrollView内容显示不全</title>
        <description>&lt;p&gt;这个问题其实只要使用过&lt;code&gt;ScrollView&lt;/code&gt;，可能都有机会遇到，问题的表现就是&lt;code&gt;ScrollView&lt;/code&gt;包裹内容的高度超过&lt;code&gt;ScrollView&lt;/code&gt;可视高度的话，被包裹的内容就会显示不全，最底部的内容永远也看不到了，这种情况肯定是无法接受的， 解决这个问题比较简单，其实就是简单的一句设置语句:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;android:fillViewport=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然这样可以解决问题，但是还是心中还有疑惑，我放在&lt;code&gt;ScrollView&lt;/code&gt;中的&lt;code&gt;LinearLayout&lt;/code&gt;是的高度是设置了&lt;code&gt;mactch_parent&lt;/code&gt; 属性的，现在看来并没有生效，我猜测可能是&lt;code&gt;ScrollView&lt;/code&gt;重写了测量方法导致的，于是去看&lt;code&gt;ScrollView&lt;/code&gt;的&lt;code&gt;onMeasure&lt;/code&gt; 方法:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
  super.onMeasure(widthMeasureSpec, heightMeasureSpec);

  if (!mFillViewport) {
      return;
  }

  final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
  if (heightMode == MeasureSpec.UNSPECIFIED) {
      return;
  }

  if (getChildCount() &amp;gt; 0) {
      final View child = getChildAt(0);
      final int widthPadding;
      final int heightPadding;
      final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
      final FrameLayout.LayoutParams lp = (LayoutParams) child.getLayoutParams();
      if (targetSdkVersion &amp;gt;= VERSION_CODES.M) {
          widthPadding = mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin;
          heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
      } else {
          widthPadding = mPaddingLeft + mPaddingRight;
          heightPadding = mPaddingTop + mPaddingBottom;
      }

      final int desiredHeight = getMeasuredHeight() - heightPadding;
      if (child.getMeasuredHeight() &amp;lt; desiredHeight) {
          final int childWidthMeasureSpec = getChildMeasureSpec(
                  widthMeasureSpec, widthPadding, lp.width);
          final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(
                  desiredHeight, MeasureSpec.EXACTLY);
          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显，在没有设置fillViewport属性为true时，&lt;code&gt;ScrollView&lt;/code&gt;并没有去测量子View的高度，这就导致超过一屏内容的&lt;code&gt;View&lt;/code&gt;的高度无法正确测量。解决了这个问题以后PM又提了一个底部内容有一部分被遮挡，滑不出的问题，布局代码是这样的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;ScrollView
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:fillViewport=&amp;quot;true&amp;quot;
    android:layout_below=&amp;quot;@id/tv_title&amp;quot;
    android:layout_marginBottom=&amp;quot;84dp&amp;quot;
    &amp;gt;

  &amp;lt;com.zhy.view.flowlayout.TagFlowLayout
      android:id=&amp;quot;@+id/tfl_label&amp;quot;
      zhy:max_select=&amp;quot;-1&amp;quot;
      android:layout_width=&amp;quot;match_parent&amp;quot;
      android:layout_height=&amp;quot;wrap_content&amp;quot;
      android:layout_marginTop=&amp;quot;14dp&amp;quot;
      android:layout_marginStart=&amp;quot;12dp&amp;quot;
      android:layout_marginEnd=&amp;quot;12dp&amp;quot;
      &amp;gt;
  &amp;lt;/com.zhy.view.flowlayout.TagFlowLayout&amp;gt;

&amp;lt;/ScrollView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看了代码后发现被遮挡区域的高度差不多就是这个&lt;code&gt;TagFlowLayout&lt;/code&gt;的&lt;code&gt;layout_marginTop&lt;/code&gt;的值，当我去掉这个属性的设置后，遮挡的问题没有了，换作&lt;code&gt;paddingTop&lt;/code&gt;后也没有问题，就是不能用&lt;code&gt;marginTop&lt;/code&gt;，好吧，这个&lt;code&gt;ScrollView&lt;/code&gt;的默认设定也是很奇葩啊！&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Dec 2018 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//scrollview-can-not-display-whole-content</link>
        <guid isPermaLink="true">http://longlinht.github.io//scrollview-can-not-display-whole-content</guid>
      </item>
    
      <item>
        <title>解决闹人的can not found symbol BR问题</title>
        <description>&lt;p&gt;最近公司研发的这个App是我从零到一搭建的，在框架搭建时分别使用了Databinding和Room，今天在做新需求时需要向Room中的实体类新添加一个字段，在写完了所有相关的逻辑后，build工程，所有自动生成的Databinding类都报错，build log中并没有指向任何具体报错的Databinding类，这就令人很困惑，因为这个需求的添加并没有改动任何Databinding的类，在不知所以的情况下，那就尝试其他方法解决，之前我在一个技术博客上看到过一个Databinding类的Troubleshooting: &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Troubleshooting the Issues with Binding Class&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make sure you have the proper dataBinding.enabled = true in gradle and trigger &amp;quot;Sync with Gradle&amp;quot;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Open the layout file and ensure that the XML file is valid and is wrapped in a &lt;layout&gt; tag.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check the layout file for the correct name i.e activity_main.xml maps to ActivityMainBinding.java.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run File =&amp;gt; Invalidate Caches  Restart to clear the caches.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run Project =&amp;gt; Clean and Project =&amp;gt; Re-Build to regenerate the class file.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Restart Android Studio again and then try the above steps again.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对这几条Troubleshooting依次尝试后，报错依旧，这就非常恼人，然后我又怀疑是不是build log打印的信息不全，导致跑偏了定位问题的方向，因此在project Gradle中更改了错误信息的条数:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;allprojects {
    gradle.projectsEvaluated {
        tasks.withType(JavaCompile) {
            options.compilerArgs &amp;lt;&amp;lt; &amp;quot;-Xmaxerrs&amp;quot; &amp;lt;&amp;lt; &amp;quot;4000&amp;quot;
            options.compilerArgs &amp;lt;&amp;lt; &amp;quot;-Xmaxwarns&amp;quot; &amp;lt;&amp;lt; &amp;quot;4000&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在打印更多错误信息以后，仍旧看不出错误的源头在哪里。排查到这一步，可能就需要最笨的办法了，倒推法，在依次回退了可能导致这个错误的代码后，算是定位到了出错的修改， 就是Room的实体类添加了一个新的字段导致的，这就很奇怪，添加一个字段不是非常正常的操作吗？就算添加的字段不符合规范，那也应该是Room报错，关Databinding什么事，一开始真是一头雾水，但是我猜想可能是Room和Databinding这两类组件都自动生成了很多代码，在生成Room代码的时候的出错导致Databinding类生成失败，所以编译时表现为Databinding类找不到，这下问题变得清晰起来，问题的源头应该还是Room导致的，最后发现其实就是一个小的细节导致的，在给Room实体类添加字段的时候是private的，但是并没有提供getter和setter方法，因此导致编译失败，只是错误的表现误导了我的思路。白白浪费了几个小时排查这种因为违反了组件使用规范的问题，以后必须引以为戒，再次重申这个恼人的细节:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Entity(tableName = &amp;quot;messages&amp;quot;)
public class ChatMessageEntity {

    @NonNull
    @PrimaryKey(autoGenerate = true)
    //common field
    private int id;

    @SerializedName(&amp;quot;title&amp;quot;)
    private String title;

    @NonNull
    public int getId() {
        return id;
    }

    public void setId(@NonNull int id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;被注解为Entity的实体类添加字段，如果是private的必须提供getter和setter方法，或者修饰为public的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果违反了这个规则，变异错误信息不一定会指向这个错误&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 03 Dec 2018 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//br-not-found</link>
        <guid isPermaLink="true">http://longlinht.github.io//br-not-found</guid>
      </item>
    
      <item>
        <title>记一次看似困难的Debug</title>
        <description>&lt;p&gt;今年把自己的手机换成了Android，拿到新机后就想找到一款手写笔记的App，因为在iOS用过一款体验很好，还用那个写了一篇游记，在试用了十几款此类的Andorid App后最终找到了一款名为INKredible的手写笔记App，刚开始用的时候很不顺手，都想卸载了，但是经过一番摸索后找到了技巧，再去试用后有一种惊艳的感觉，今天在地铁通勤的时候竟然用它谢了一篇技术博文，并已图片的形式到了出来，全文如下:(字迹潦草，读者莫怪，其实如果以正楷的形式书写, 效率较差，体验会大打折扣).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/mw690/7033bf1dly1g0aqh53p3dj20m80zkdlh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Nov 2018 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//record-a-debug-process</link>
        <guid isPermaLink="true">http://longlinht.github.io//record-a-debug-process</guid>
      </item>
    
      <item>
        <title>使用VideoView实现视频开屏页</title>
        <description>&lt;p&gt;今天PM提了一个视频开屏页的需求，需要在用户第一次使用时播放一个开屏视频，乍一看，挺简单一需求，但是也或多或少碰到了一些坑，也发现了Android资源编译的一个问题，本着研发之事无小事的原则，还是要记录下踩坑经验和发现的问题。整个实现过程一共两三个小时，逐步解决了以下问题:&lt;/p&gt;

&lt;h4&gt;视频全屏&lt;/h4&gt;

&lt;p&gt;看到这个问题的第一反应就是把&lt;code&gt;VideoView&lt;/code&gt; 的宽高设置为&lt;code&gt;match_parent&lt;/code&gt;, 并且保证父容器也是&lt;code&gt;match_parent&lt;/code&gt; 根布局, 但是事实没那么简单，视频播放后并没有完全全屏，在我的开发机上视频底部有一条细细的白边，很明显视频没有完全全屏。后来又想到设置&lt;code&gt;MediaPlayer&lt;/code&gt;的视频缩放模式:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mPlayer.setVideoScalingMode(MediaPlayer.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置了两种模式以后都没有效果，这说明&lt;code&gt;VideoView&lt;/code&gt;本身没有全屏，没有铺满整个屏幕，所以需要根据屏幕大小动态设置&lt;code&gt;VideoView&lt;/code&gt;的尺寸，所以用自定义View实现。
自定义一个继承自&lt;code&gt;VideoView&lt;/code&gt;的类来满足要求，具体实现如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class FullScreenVideoView extends VideoView {
    public FullScreenVideoView(Context context) {
        super(context);
    }

    public FullScreenVideoView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public FullScreenVideoView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int width = getDefaultSize(0, widthMeasureSpec);
        int height = getDefaultSize(0, heightMeasureSpec);
        setMeasuredDimension(width, height);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样比较顺利的实现了全屏，接下来需要解决第二个问题:&lt;/p&gt;

&lt;h4&gt;循环播放&lt;/h4&gt;

&lt;p&gt;这个比较容易，几乎就是一行代码，是对播放器的设置:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mBinding.vvSplash.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
    @Override
    public void onPrepared(MediaPlayer mp) {
        mPlayer = mp;
        mPlayer.setLooping(true);
        mPlayer.setVideoScalingMode(MediaPlayer.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING);
        mPlayer.start();

        mPlayer.setVideoScalingMode();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三个问题:&lt;/p&gt;

&lt;h4&gt;音量切换&lt;/h4&gt;

&lt;p&gt;这个问题也比较简单，主要是对播放器的操作，虽然简单但是需要注意以下几个问题:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要保证操作的播放器一直是同一个&lt;/li&gt;
&lt;li&gt;调用setVolume以后不需要再调用start&lt;/li&gt;
&lt;li&gt;恢复音量时最好的方式是通过系统服务(AudioManager)去获取当前音量，但是这个需求只要设置为1就可以了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;到此，问题都逐一解决了，最后需要记录下一个Android资源编译的问题，问题如下:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我的工程目录res/drawable下有一个图片文件名为splash.png，开屏视频的MP4文件在res/raw下，名为splash.mp4，编译工程运行后一直报错：
&lt;code&gt;无法播放此视频&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时还以为我代码哪里写错了，检查发现没有错误，后来怀疑路径是不是错了，但断点调试也没问题，就很纳闷，后来拷贝了其它视频播放，发现是正常的，我才想到可能是资源文件名字冲突了，我给开屏视频文件重命名以后一切OK了，冲突在编译期间竟然没有报错，感觉有点坑，这样看来Android在编译资源时并没有区分res/drawable目录和res/raw目录，这个问题需要重视起来，不然会比较恼人。&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Nov 2018 01:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//play-video-in-raw-folder</link>
        <guid isPermaLink="true">http://longlinht.github.io//play-video-in-raw-folder</guid>
      </item>
    
      <item>
        <title>MultidexApplication相关的一个crash</title>
        <description>&lt;p&gt;最近在内测的一个App在内测开始后有用户反馈启动就crash的问题，后来拿到用户的信息后发现几个crash的机器都是4.4的机器，因为现在真实用户使用4.4系统的用户真的是不多了，就没怎么在意，但是在阿里云移动测试平台进行兼容性测试的时候，这个问题必现，并且都出现在4.4的机器上，查看兼容性测试报告，都是同一个crash，崩溃的堆栈记录了下来:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;FATAL EXCEPTION: main Process: com.ross.android, PID: 9282 java.lang.RuntimeException: Unable to get provider com.readystatesoftware.chuck.internal.data.ChuckContentProvider: 
java.lang.ClassNotFoundException: Didn&amp;#39;t find class &amp;quot;com.readystatesoftware.chuck.internal.data.ChuckContentProvider&amp;quot; on path: DexPathList[[zip file &amp;quot;/data/app/com.ross.android-1.apk&amp;quot;],nativeLibraryDirectories=[/data/app-lib/com.ross.android-1, /vendor/lib, /system/lib]] 
at android.app.ActivityThread.installProvider(ActivityThread.java:5060) 
at android.app.ActivityThread.installContentProviders(ActivityThread.java:4631) 
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4571) 
at android.app.ActivityThread.access$1500(ActivityThread.java:155) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1406) 
at android.os.Handler.dispatchMessage(Handler.java:110) 
at android.os.Looper.loop(Looper.java:193)
at android.app.ActivityThread.main(ActivityThread.java:5341) 
at java.lang.reflect.Method.invokeNative(Native Method) 
at java.lang.reflect.Method.invoke(Method.java:515) 
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:830) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:646) 
at dalvik.system.NativeStart.main(Native Method) Caused by: java.lang.ClassNotFoundException: Didn&amp;#39;t find class &amp;quot;com.readystatesoftware.chuck.internal.data.ChuckContentProvider&amp;quot; on path: DexPathList[[zip file &amp;quot;/data/app/com.ross.android-1.apk&amp;quot;],nativeLibraryDirectories=[/data/app-lib/com.ross.android-1, /vendor/lib, /system/lib]] at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56) 
at java.lang.ClassLoader.loadClass(ClassLoader.java:497) 
at java.lang.ClassLoader.loadClass(ClassLoader.java:457)
at android.app.ActivityThread.installProvider(ActivityThread.java:5045) 
at android.app.ActivityThread.installContentProviders(ActivityThread.java:4631)
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4571) 
at android.app.ActivityThread.access$1500(ActivityThread.java:155) 
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1406) 
at android.os.Handler.dispatchMessage(Handler.java:110) 
at android.os.Looper.loop(Looper.java:193) 
at android.app.ActivityThread.main(ActivityThread.java:5341) 
at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:515)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:830) 
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:646) 
at dalvik.system.NativeStart.main(Native Method)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这个崩溃的记录后，赶紧去查看到了build.gradle中multiDexEnabled选项，果然是true，处于打开状态，然后看了本App的Application竟然并没有继承自&lt;code&gt;MultiDexApplication&lt;/code&gt;，在&lt;code&gt;Application&lt;/code&gt;的onCreate的方法中也没有调用&lt;code&gt;MultiDex.install(this)&lt;/code&gt;, 这也就难怪在4.4中出现这个崩溃了，因为貌似这个崩溃只出现在 api&amp;lt;21 的情况下, 因为我平时的开发机都是8.0的系统，所以这个问题一直没有暴露出来, 直到将这个App安装在用户的机器上，崩溃出现了，这个问题解决起来其实很简单，要么将本App的Application继承自&lt;code&gt;MultiDexApplication&lt;/code&gt;, 要么在Application中的onCreate中调用&lt;code&gt;MultiDex.install(this)&lt;/code&gt;。就是这么简单,那这么简单的一个问题为什么要专写一篇来记录呢？其实也是因为这次这个内测阶段的crash的问题很典型，它就是在开发工程中被忽略，或者现有环境没有覆盖到，导致崩溃出现在了用户的机器上，其实这类问题是可以在发布版本前就能避免的，算是一次很好的教训。 解决方案再明确下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方法一 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;TestApplcation extends MultiDexApplication {


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;方法二&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;TestApplcation extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        MultiDex.install(this);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Mon, 26 Nov 2018 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//multidex-application-crash</link>
        <guid isPermaLink="true">http://longlinht.github.io//multidex-application-crash</guid>
      </item>
    
      <item>
        <title>读《决断力》</title>
        <description>&lt;p&gt;今年可能年景不好，运气不佳，再加上自己昏招频频，感觉今年非常不顺，也发现自己很不会决策，没有很好的决断力。于是就想找一本决断力相关的书来看看，找了一下，还果然有这个书名的一本书，而且豆瓣上评价不错，于是发送到Kindle，趁着地铁通勤的时间很快看完了，因为是中文版，看起来比较快，感觉正本书还是比较平实的，很多决策的方法可操作性强，因为这次使用了Kindle自带的标注功能，在看的过程中随手标注了重点和一些精彩的段落，整本书看完后，对标注和笔记做了整理，现记录出来：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正常情况下，你的思维几乎会对所有发生的事情做出直觉反应并形成某种看法。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在你的精神世界里，很显然，你极少被某个问题难住。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在尚未熟悉某个人之前，你已经产生了喜欢或厌恶的感觉；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当然，你也可能不知道为什么自己会信任或怀疑陌生人；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或是在未对某一公司做出任何分析评估的情况下就认定它一定会成功。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;聚光效应&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;卡尼曼认为，人们匆忙做出结论，是由于我们对眼前的信息关注过多，却对视线之外的信息不加考量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从本质上来讲，这又恰恰是决策的核心难题：灯光内的东西很少会是我们做出一个好的决定所需要的全部,但我们时常会忘了调整聚光灯的方向。 人们在决策时遇到的难题，即主观偏见和非逻辑性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;研究人员通过对比发现&amp;quot;决策流程更为重要——比分析重要 6倍&amp;quot;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;唯一被广泛采用的决策方法是列出利弊清单。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;影响决策的屏障&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;思维狭隘&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;限制你的选择范围&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;证实倾向&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当人们有机会从现实世界中搜集信息时，人们更可能去搜集那些支持他们已有的看法、信仰和行动的信息&lt;/p&gt;

&lt;p&gt;证实倾向令人感到些许恐惧的地方在于：当我们希望某件事情是真实的时候，便会关注支持这件事是真实性的信息，然后，当我们从中得出自己想要的结论时，还要庆幸自己做了一个非常理智的决定。天啊！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;短期情绪&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;过于自信&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为相对于自己存在的偏见，人们往往更容易发现他人的偏见。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;利弊清单法不能校正上述问题，但是 WRAP流程法可以做到&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;WRAP&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Widen your options（拓宽选择空间）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redlity- test your assumptions（把假设放到现实中检验）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Attain distance before deciding（在做出决策前，留出一段距离来考虑）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Prepare to be wrong（做好出错的准备）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;思维狭隘&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;青少年们易变得思维狭隘，这也就是阻碍决策的第一个因素。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事实证明，在做决定时，机构和组织的行为倒是跟青少年的很相像。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;青少年陷入思维狭隘之中。他们意识不到选项的存在。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可供我们选择的选项常常比预期的要丰富得多。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么我们会陷入思维狭隘之中？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;专注于目前的选择意味着对其他选项视而不见。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们如何避开思维狭隘？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;考虑机会成本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;试试“消失选项测试”：现有的选择消失后你会怎么做？&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;身在其外——作为一个决策顾问，更容易发现思维的狭隘。“是或否”决定应该引起重视。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;多目标追踪&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多目标追踪使我们时刻保持自省。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那些考虑多个选择的执行者能更快地做出决定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;极端的多目标追踪是有害的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最明智的决定可能是将预防心态的谨慎和进取心态的热情结合在一起&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当生活提供给我们“非此即彼”的选择时，我们应该勇敢地去探索是否存在一个“两者都选”的正确答案。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多目标追踪等于同时思考一个以上的选择。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当你同时考虑多个选择的时候，你认识到了问题的“形状”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑数个选择可能引起决策瘫痪，因此我们只可再多考虑一至两个选择。这样，得到的收益是巨大的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;警惕&amp;quot;虚假选择&amp;quot;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;当你需要更多选择，却感觉陷入僵局时，那就去寻找已经帮你解决了问题的人吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;寻找已经帮你解决了问题的人&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从外部寻找：竞争分析，基准衡量，最优方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从内部寻找：找到你的亮点。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为了变得主动，请将你的精细选择编入决策的&amp;quot;问题列表&amp;quot;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;审核清单阻止人们犯错误，问题列表刺激新思路的产生。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三个寻找创意的地方：着眼于远处。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设积极意图和写婚姻日记是被心理学家称作“考虑相反的情况”的两个例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三种对抗证实倾向的方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一，我们可以使他人更容易地提出反对意见&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二，我们可以提出更有可能使相反信息显现的问题&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三，我们可以通过考虑相反情况的方法来对自己进行核查&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;证实倾向指的是搜寻到的正是我们初步假设的信息（常常是有利于自己的）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;警告：在角色划分明确的情况下，探究性问题可能产生事与愿违的效果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;非证实倾向的极端形式：我们能否强迫自己考虑直觉的对立面？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们甚至可以通过故意犯错来测试自己的假设。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为我们会自然地去寻找自我证实的信息，所以我们需要训练自己从相反的原则考虑问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当我们依据评论做出决定时，我们便是在承认两件事情：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们自身搜集产品真实情况的能力是有限的，而且我们的判断还会受限于制造公司对产品信息的失真传达。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于上述原因，用他人的平均评价弥补自己印象的不足就是更明智的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;心理学家对同一情境中的“内视观点”和“外视观点”进行过如下区分。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内视观点是指在考虑决定时，从处于我们聚光灯内的信息——自己对情况的印象和评价——来获得结论。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相比之下，外视观点则能够忽略具体细节，从大局进行分析。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;适当的情绪恰是我们做出明智之选所必需的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们对&amp;quot;平均值&amp;quot;的信任常常会超过我们的直觉——但却做不到应该相信的程度。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内视观点等于对自身所在的特定环境的评价。外视观点等于在类似于我们这样的情况下，事情通常是如何呈现的。外视观点更为精确，但绝大多数人会向内视观点倾斜。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你无法为自己的选择找到“基本比率”，那就去找专家。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;专家们擅长评估基本比率，但在预测方面却不在行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特写”可以增添外视观点所缺少的内容。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了得到最好的信息，我们应该用缩小和放大法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我发现找到任何一个人类要表现明显优于粗略的外推算法的领域是不可能的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么专家知道的如此多，他们的预测能力却如此差劲？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尝试应该被当成一种加快搜集可靠信息的方法，而不是一种减缓我们做出值得全心投入的决策的方法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们已经接触到了三种对应策略。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一，我们必须勤于想出搜集信息的方法，提出反面问题和考虑相反的情况；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二，我们必须寻找正确的信息：用缩小法去寻找那些总结他人经验的基本比率，用放大法去获取对现实更加细微的印象；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三， 尝试（ ooching）就等于做小实验以测试我们的理论。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;尝试&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尝试的方法很有用，因为我们在预测未来方面做得很糟。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;企业家会很自然地尝试&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;警告：尝试在需要做出承诺的情形中，不能使我们达到预期效果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的聘用错误：我们试图通过面试对成功做出预测&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么我们要在可以了解的时候去猜测？在做出决策前，留出一段距离来考虑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用 10— 10— 10方法，就意味着我们要以三个不同的时间范围为基础对决定进行考量：从现在算起的 10分钟后，我们对这一决定会有什么样的感觉？再过 10个月后呢？ 10年后呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对某物的熟悉不会令人们产生轻视的情绪，它更可能使人们心满意足。几十年来，心理学家们一直在研究这一被称为“曝光效应”（ mere exposure）的现象&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发现看到刺激物的次数越多，人们对刺激物的好感度就越高。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这种对于现状的偏爱是另一种认知偏见。它被称为损失厌恶（ loss aversion），指的是人们发现相较于收益带来的快乐，损失带来的痛苦更大&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;组织内部的决策容易受到强有力的情感扭曲的支配。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;维持现状偏见（ Status- Quo Bias）也许在大型官僚制的组织中最为明显。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释水平理论”（ construal- level theory）的相对新型的心理学研究领域显示，距离我们面临的问题越远，我们就越能更清楚地看到问题最重要的方面。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;研究人员发现，从实质上讲，我们为他人提出的建议常取决于唯一一个最重要的因素，而我们自己的思绪却在各种变量中翻腾。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由此可知，我们给他人提出的建议具有两大优点：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它自然地会把最重要的因素放在决策中的优先位置进行考虑，&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而且它还弱化了短期情绪。 &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;瞬时的情绪诱使我们做出那些在长远看来是坏决定的决定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了克服使我们分心的短期情绪，我们要学会留出些距离。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10— 10— 10方法迫使我们像考虑当前情绪一样对未来情绪进行充分考虑，从而使“留出距离”得以实现。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们的决定常常被两种微妙的短期情绪改变：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;曝光效应：我们喜欢自己所熟悉的东西。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;损失厌恶：损失让人痛苦，收益让人愉快，而前者的程度要更大一些。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;损失厌恶与曝光效应相结合的结果是维持现状偏见。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过一个观察者的角度看自身所处的情况，我们可以留出这个距离。&lt;/p&gt;

&lt;p&gt;在个人做决策时，最有力的问题可能会是：“如果面临这种情况的是我最好的朋友，那我会告诉他/她如何去做？”&lt;/p&gt;

&lt;p&gt;《从优秀到卓越》（ Good to Great）一书的作者——会建议我们建立一个“停止做的事情”的清单。&lt;/p&gt;

&lt;p&gt;他的顾问让他思考，如果他接到了两个改变人生的电话，他会怎么做。&lt;/p&gt;

&lt;p&gt;在第一个电话中，他会得知自己继承了 2 000万美元，并且无任何附带条件。&lt;/p&gt;

&lt;p&gt;而第二个电话则是告知他患上了一个罕见而难以治愈的疾病，他只剩下 10年的寿命。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;平复短期情绪并不总能令一个决定变得容易。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;核心价值观&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个令人苦恼的决定常常是你的核心价值观遭遇冲突的时候。核心价值观：长期的情感价值、目标和志向。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将你的核心价值观视为神圣的东西，在解决现在以及未来遇到的困境时，就可以更容易一些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遗憾的是，建立你的优先顺序与遵守它们是不同的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;空出时间来实践我们的核心价值观，我们必须对次级优先的事情发起攻势。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;预想式&lt;/strong&gt;回顾似乎能鞭策我们产生更多的深刻见解，因为它迫使我们在今天以及一件确定发生的未来事件之间的空白处添上内容（截然不同于一个猜测某件事情是否会发生的更加难以明确的过程）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未来不是一个“点”——一个我们必须预测的简单场景，它是一个范围。&lt;/strong&gt;我们应该书档未来，对从非常坏到非常好的大范围内的结果进行考虑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事前验尸方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在为较矮的那片书档做准备时，我们需要进行事前验尸。“已经过去一年了。我们的决策彻底失败了。它失败的原因是什么？”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;预演&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为较高的那片书档做准备时，我们需要进行预演。“已经过去一年了。我们变成了英雄。我们准备好获得成功了吗？”&lt;/p&gt;

&lt;p&gt;为了应对无法预见的结果，我们可以采用一个“安全系数”。&lt;/p&gt;

&lt;p&gt;对问题做出预期能够帮助我们处理问题。 “真实工作预览”：预先揭示一份工作的缺点，给人们“注射了不满意疫苗”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过书档法——同时对逆境和成功做出预期和准备——我们预先做好了有利于自己决定的布局。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;绊网（tripwire）&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有个方法是设定最后期限，而这是绊网最为常见的形式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在设定最后期限和测量评估方法之外的另一个策略是，用一个“隔断”（partition）来充当绊网。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是隔断却在做一些不同的事情：它在设定界限。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在生活中，我们会自然地进入“自动驾驶”状态，将以前的决定搁置一旁，不对其进行检查。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个绊网可以令我们清醒过来，并使我们意识到自己有个选择。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在变化缓慢进行的时候，绊网特别有用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;受困于“自动驾驶状态”中的人们可以考虑最后期限和隔断。我们易于增加自己对糟糕决定的投入；隔断能帮助我们阻止这种做法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;实际上，绊网可以为冒险行为提供一个安全空间。它们：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;规定了冒险行为的上限；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使你的精神获得平静，直至碰到“触发器”。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;许多有力的绊网是被模式识别的，而非日期、度量和预算所触发。&lt;/p&gt;

&lt;p&gt;绊网可以提供一个宝贵的认识：我们有一个选择要做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;妥协就像是个老笑话：“骆驼乃是由委员会制作的一匹马。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;程序正义&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大量研究证实，在解释人们对一个决定的感受方面，程序正义非常重要。关键的不是结果，而是过程。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;群体做出的决定有一个额外的负担：它们必须被人们视为公正的决定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“讨价还价”——直至各方都可以接受最后的选择——有助于形成被人们视为公正的决定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们应该确保人们能感觉到判定过程是公正的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个可靠的方法可以帮助我们设法解决哪怕是最棘手的决定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“流程”并非富有魅力，但它所能提供的信心却是珍贵的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 16 Oct 2018 02:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//read-make-a-better-decision</link>
        <guid isPermaLink="true">http://longlinht.github.io//read-make-a-better-decision</guid>
      </item>
    
  </channel>
</rss>