<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>First Lesson of Machine Learning</title>
	  <link>//first-lesson-of-machine-learning</link>
	  <author>Tao He</author>
	  <pubDate>2020-12-01T04:54:12+08:00</pubDate>
	  <guid>//first-lesson-of-machine-learning</guid>
	  <description><![CDATA[
	     <p>Two months ago, I made a decision for my career: learning machine learning from scratch. Machine learning involves many stuff of math while math is difficult. But I didnot give up in half way this time. Books, Youtube lectures, blogs, I collect learning materials as much as I can and do my best to learning it. 60 days passed, I have had a clarity understanding about some important concepts of Machine learing. In this article, I will figure out these concepts and their relations through 2 figures.</p>

<p><strong>Figure 1</strong> </p>

<p>This figure seems simple, but it reveals the relations of some important concepts.</p>

<p><img src="/assets/images/scratch_ml.jpg" /></p>

<p><strong>Figure 2</strong> </p>

<p>This figure describes more detail.</p>

<p><img src="/assets/images/machine_learning.png" /></p>

	  ]]></description>
	</item>

	<item>
	  <title>Review Matrix</title>
	  <link>//review-matrix</link>
	  <author>Tao He</author>
	  <pubDate>2020-11-23T04:54:12+08:00</pubDate>
	  <guid>//review-matrix</guid>
	  <description><![CDATA[
	     <p>Linear Algebra is prerequisite for Machine Learning while Matrix is the one of most important stuff in Linear Algebra. It is difficult to learn ML well in case of not 
familiar with Matrix. So it is time to review a few aspects of Matrix. Because of complexity of mathematical formula input, I will skip some details in main text, but attach them in three images(output from my Inkredible notes).</p>

<p><strong>Image 1</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201913.png" /></p>

<p>Image 1 involves:</p>

<ul>
<li><p>Matrix Definition</p></li>
<li><p>Matrix Addition and Multiplication</p></li>
</ul>

<p><strong>Image 2</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201928.png" /></p>

<p>Image 2 involves:</p>

<ul>
<li><p>Identity Matrix </p></li>
<li><p>Properties of Matrix:</p>

<ul>
<li>Not Commutative</li>
<li>Associativity</li>
<li>Distributivity</li>
</ul></li>
<li><p>Multiplication with the Identity Matrix</p></li>
<li><p>Inverse and Transpose</p></li>
</ul>

<p><strong>Image 3</strong> (Learning notes output by Inkredible)</p>

<p><img src="/assets/images/IMG_20201203_201950.png" /></p>

<p>Image 3 involves:</p>

<ul>
<li><p>Symetric Matrix</p></li>
<li><p>Multiplication by a Scalar</p></li>
<li><p>Compat Representation of System Linear Equation</p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Android module SDK化的实践</title>
	  <link>//using-maven-to-mananger-library</link>
	  <author>Tao He</author>
	  <pubDate>2020-11-21T04:54:12+08:00</pubDate>
	  <guid>//using-maven-to-mananger-library</guid>
	  <description><![CDATA[
	     <p>文章标题指的SDK化指的是将一个有多个module的Android工程中的特定module以aar的形式输出后被app模块依赖使用。那么如何在基本不改动代码的情况下实现这个要求，完成app模块对特定module的依赖呢?</p>

<p>最直接的想法就是把要SDK化的module输出为aar文件，然后在app模块添加对此aar文件的依赖。在解决完所有的编译错误以后，运行app后发生了crash，查看输出，是因为输出为aar的这个模块所依赖的一个类在运行时找不到，事实上就是这个远端依赖没有被打进apk包。很明显，直接输出aar然后依赖是不可行的。</p>

<p>远端依赖的类找不到，因为此module在输出为aar的时候并未将他的依赖打入aar包，那有没有办法将此module的所有依赖都打进aar包呢? 在线上搜索了一番后，还真找到了这样的一个gradle插件<a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a>来做这件事，接入到工程中很简单:</p>

<ol>
<li>应用插件</li>
</ol>

<p>在project build gradle文件中加入如下代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:xxx&#39;
        classpath &#39;com.kezong:fat-aar:1.2.20&#39;
    }
}
</code></pre></div>
<ol>
<li>使用插件关键字来嵌入依赖</li>
</ol>

<p>将需要嵌入的依赖，修改implementation或api为embed</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dependencies {
    implementation fileTree(dir: &#39;libs&#39;, include: &#39;*.jar&#39;)
    // java dependency
    embed project(path: &#39;:lib-java&#39;, configuration:&#39;default&#39;)
    // aar dependency
    embed project(path: &#39;:lib-aar&#39;, configuration:&#39;default&#39;)
    // aar dependency
    embed project(path: &#39;:lib-aar2&#39;, configuration:&#39;default&#39;)
    // local full aar dependency, just build in flavor1
    flavor1Embed project(path: &#39;:lib-aar-local&#39;, configuration:&#39;default&#39;)
    // local full aar dependency, just build in debug
    debugEmbed (name:&#39;lib-aar-local2&#39;,ext:&#39;aar&#39;)
    // remote jar dependency
    embed &#39;com.google.guava:guava:20.0&#39;
    // remote aar dependency
    embed &#39;com.facebook.fresco:fresco:1.11.0&#39;
    // don&#39;t want to embed in
    // implementation is not recommended because the dependency may be different with the version in application, resulting in the R class not found.
    compileOnly &#39;com.android.support:appcompat-v7:27.1.1&#39;
}
</code></pre></div>
<p>使用此插件除了会遇到资源冲突外，目前没有发现其他问题。但这个插件在github上的issue有点多，心里有点没底，所以还需要想其他的办法。</p>

<p>这两个方法被排除后，就想到用maven来管理依赖，更灵活，是更一般的做法。 将此module输出后上传到maven服务器，在app上添加对此module的远程依赖后，发现无法编译，找不到此module依赖中的类，这是因为没有在pom中添加依赖。将aar发布到maven和添加依赖配置的代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">afterEvaluate {
    publishing {
        publications {
            release(MavenPublication) {
                artifact(&quot;$buildDir/outputs/aar/live-debug.aar&quot;) {
                    builtBy tasks.getByName(&quot;assembleDebug&quot;)
                }

                groupId = &quot;com.overseas.android.live&quot;
                artifactId = &#39;live&#39;
                version = &#39;1.0.8&#39;

                pom.withXml {
                    def dependenciesNode = asNode().appendNode(&quot;dependencies&quot;)
                    configurations.compile.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;compile&quot;) }
                    configurations.api.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;compile&quot;) }
                    configurations.implementation.dependencies.forEach { dep -&gt; addDependency(dependenciesNode, dep, &quot;runtime&quot;) }
                }
            }
        }

        repositories {
            maven {
                url = uri(&quot;https://xxx/repository/android-release/&quot;)

                credentials {
                    username = &quot;hetao&quot;
                    password = &quot;hetao&quot;
                }
            }
        }
    }
}
</code></pre></div>
<p>在用maven管理依赖时需要注意一下几点:</p>

<ul>
<li><p>需要关注发布的module是不是有远程依赖，有的话需要添加依赖配置</p></li>
<li><p>需要发布的module输出为debug版本，统一由app模块去做混淆</p></li>
<li><p>需要发布的module的混淆规则不能被遗漏，需要添加此配置:</p></li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">defaultConfig {
    ...

    consumerProguardFiles &#39;proguard-rules.pro&#39;

    ...

}
</code></pre></div>
<p>不然会有因为混淆而找不到类的问题。</p>

	  ]]></description>
	</item>

	<item>
	  <title>用python脚本优雅的整理Kindle的标注和笔记</title>
	  <link>//using-python-parse-kindle-notes</link>
	  <author>Tao He</author>
	  <pubDate>2020-11-12T04:54:12+08:00</pubDate>
	  <guid>//using-python-parse-kindle-notes</guid>
	  <description><![CDATA[
	     <p>我是重度Kindle使用者，Kindle里面存满了各类书籍，经常会同时读两三本书，时间一长，多本书的标注和笔记都交叉记录在My Clippings.txt文本文件里，现在这个文件已经有几万行，每次手动去整理特定的一本书的标注和笔记时都极为头疼，还容易错漏，终于有一天实在忍不了了，就去网上找有没有整理kindle标注和笔记的服务，还真让我给找到了，clipping.io，在线服务，马上使用，上传My Clippings.txt文件，一切顺利，文件上传后开始分析整理文本，看到几本书的标注已经出来了，等全部整理结束后发现少了好几本书的，再次重新上传文件重试整理，问题依旧，空欢喜一场，依旧不能解决我的痛点，最近在读的两本书的标注和笔记恰好没有被整理出来，一怒之下，决定自己用python脚本来写一个这样的整理工具，还以为得花费一两天的时间，一不小心，两个小时不到的功夫写完了，调试了一番，完全满足我的需求，现在只需一条命令，传入书名就可以整理出指定的一本书的所有标注和笔记，脚本如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># coding=utf-8

import os
import sys

def main():
   filepath = sys.argv[1]
   bookName = sys.argv[2]

   if not os.path.isfile(filepath):
       print(&quot;File path {} does not exist. Exiting...&quot;.format(filepath))
       sys.exit()

   DELIMITER = &quot;==========&quot;
   TIME_MAKR = &quot;- 您在第&quot;
   lineNum = 0
   books = {}

   bag_of_words = {}
   with open(filepath) as fp:
       encounter = False
       delimiterCount = 0
       curBookName = &quot;&quot;
       for line in fp:
           if lineNum == 0:
               books[line] = []
               curBookName = line
               delimiterCount += 1
           else:
               if line.startswith(DELIMITER):
                   delimiterCount += 1
                   encounter = True
               else:
                   if encounter == True:
                       if line in books:
                           curBookName = line
                       else:
                           books[line] = []
                       encounter = False
                       curBookName = line
                   else:
                       books[curBookName].append(line)
           lineNum += 1
           #print(line)

       fp.close()            

   outFile = open(&quot;MyClippingOutput.txt&quot;, &quot;w&quot;)
   for k in books:
       if k.startswith(bookName) :
           outFile.writelines(k)
           lines = books[k]
           for l in lines:
               if l.startswith(TIME_MAKR):
                   continue
               if l.startswith(bookName):
                   continue
               outFile.writelines(l)
   outFile.close()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre></div>
<p>目前这个脚本我只是自用，满足我个人的需求，我想肯定也有很多kindle的重度使用者有类似的需求，后续我准备把这个工具也做成在在线服务，使用方式类似clipping.io，做到比clipping.io的可定制型更强，能够适应更多的异常情况，因为我发现clipping.io对一些不规范的书名的容错性很差。期待这个服务上线！</p>

	  ]]></description>
	</item>

	<item>
	  <title>在Flutter中实现一个类似Android中的BottomSheetDialog</title>
	  <link>//bottom-sheet-dialog-in-flutter</link>
	  <author>Tao He</author>
	  <pubDate>2020-10-12T02:20:12+08:00</pubDate>
	  <guid>//bottom-sheet-dialog-in-flutter</guid>
	  <description><![CDATA[
	     <p>从屏幕底部滑出的这种弹窗实在是太普遍的需求了，所以Flutter不可能不提供，一查文档，果然有一个API直接就可以调出Dialog: showModalBottomSheet, 这个API有很多入参，但是如果不需要对Dialog的外观和行为有特殊的定制需求的话，值传递前两个参数就可以了。 API看起来非常简单，但是我看到网上有些blog文章对这个API的使用是错误的，所以我贴出我实现了上方圆角dialog的代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">void openBottomSheet(context) {
  showModalBottomSheet(
    backgroundColor: Colors.white,
    context: context,
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.only(topLeft: Radius.circular(18), topRight: Radius.circular(18))
  ),

  builder: (builder) {
      return new Container(
        child: Wrap(
          children: &lt;Widget&gt;[
            getListTile(Icons.more, Colors.black45, &quot;More&quot;, context),
            getListTile(Icons.favorite, Colors.pink, &quot;Favourites&quot;, context),
            getListTile(Icons.account_box, Colors.blue, &quot;Profile&quot;, context),
            new Divider(
              thickness: 2.0,
              height: 10.0,
            ),
            getListTile(Icons.exit_to_app, null, &quot;Logout&quot;, context),
          ],
        ),
      );
    },
  );
}
</code></pre></div>
<p>这个圆角的实现，其实可以直接传入<code>backgroundColorback</code>和<code>shape</code>参数，不用额外去添加一层i<code>Container</code>，如果想实现圆角背景，通过<code>Container</code>也可以实现，就是把<code>backgroundColor</code>设置成透明，多了一道工序，没必要。背景阴影的效果通过<code>barrierColor</code>来设置。很简单的一api，如果错误使用，不但不能优雅的实现功能，反而额外做了很多工作，却不能实现预期。看到的几个demo都没有正确使用这个API，所以特意为这个问题做此小记。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin synthetic binding view is null in Fragment</title>
	  <link>//kotlin-synthetic-view-binding-view-is-null-in-fragment</link>
	  <author>Tao He</author>
	  <pubDate>2020-09-09T02:20:12+08:00</pubDate>
	  <guid>//kotlin-synthetic-view-binding-view-is-null-in-fragment</guid>
	  <description><![CDATA[
	     <p>Kotlin provide a handy and concise way to access views in xml layout from code, it works well, but When I create a subclass of <code>DialogFragment</code>, in its method <code>onCreateView</code>, I access synthetic binding view, it seems all is fine, but when run these code, app crash. In logcat, I got this <code>NullPointerException</code>:</p>

<blockquote>
<p>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &#39;android.view.View android.view.View.findViewById(int)&#39; on a null object reference</p>
</blockquote>

<p>I&#39;m sure synthetic statement is imported and view id is right, it confused me a bit. So I Google Kotlin synthetic binding view related web pages, finally I found a solution:</p>

<p>Just move accessing syntheic binding view statement from <code>onCreateView</code> to <code>onViewCreated</code>.</p>

<p>The problem is that I am accessing it too soon, When I delay the chance to access view, all works well. Magic! But it’s nothing magical, if you decompile the bytecode (By going toTools -&gt; Kotlin -&gt; Show Kotlin Bytecode and then selecting Decompile in the pane) and take a look at the generated java class, you’ll see that all it does is call findViewById() for us. Although this is a simple problem, but it is useful to record it.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin中的"静态" 方法和域</title>
	  <link>//static-method-in-kotlin</link>
	  <author>Tao He</author>
	  <pubDate>2020-09-03T04:54:12+08:00</pubDate>
	  <guid>//static-method-in-kotlin</guid>
	  <description><![CDATA[
	     <p>最近开始尝试在现有的工程中使用Kotlin，刚开始使用时感觉语法简洁，代码量也少了很多，语法层面的防空，可以直接访问布局控件这些特性，都让人耳目一新，但是当我要定义静态方法和静态类时，不爽的体验一下子就上来了，所以通过此文来一探Kotlin&quot;静态&quot; 的究竟。
  先来看静态方法， 很遗憾，Kotlin中没有<code>static</code>关键字，需要将静态方法放在<code>companion object</code>中的代码块中，因此：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  public static int a() { return 1; }
}
</code></pre></div>
<p>就变成了这样:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
     fun a() : Int = 1
  }
}
</code></pre></div>
<p>可以在Kotlin代码中这样使用该类:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.a();
</code></pre></div>
<p>在Java代码中:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.Companion.a();
</code></pre></div>
<p>如果你不喜欢使用<code>Companion</code>, 你可以对该静态方法添加<code>@JvmStatic</code>注解:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
    @JvmStatic
    fun a() : Int = 1;
  }
}
</code></pre></div>
<p>也可以命名你的<code>companion</code>类:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object Blah {
    fun a() : Int = 1;
  }
}
</code></pre></div>
<p>然后可以这样调用:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.Blah.a() 
</code></pre></div>
<p>然后来看静态域， 比起静态方法，静态域的情况有所不同，虽然也可以这样定义:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Foo {
  companion object {
    val MY_CONSTANT = &quot;MY_CONSTANT&quot;
  }
}
</code></pre></div>
<p>但是会自动为<code>MY_CONSTANT</code>生成getter和setter方法，相当于实例域访问，开销会比静态方法大，不推荐此种定义方法。可以这样定义:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">object Foo {
    const val MY_CONSTANT = &quot;MY_CONSTANT&quot;
}
</code></pre></div>
<p>上面定义的object Foo可以全局访问:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Foo.MY_CONSTANT
</code></pre></div>
<p>而companion object中定义的<code>const var MY_CONSTANT</code>是不可以全局访问的。 当然了，静态域为了避免访问时的Companion，也可以在定义时添加<code>@StaticField</code>.</p>

<p>到此Kotlin中<code>静态</code>相关的部分基本已经覆盖到了，个人觉得这个companion object不是什么好的设计，远没有Java的static关键字来的简洁和表达力。</p>

	  ]]></description>
	</item>

	<item>
	  <title>基于DrawerLayout实现直播抽屉</title>
	  <link>//implement-live-drawer</link>
	  <author>Tao He</author>
	  <pubDate>2020-07-29T04:54:12+08:00</pubDate>
	  <guid>//implement-live-drawer</guid>
	  <description><![CDATA[
	     <p>直播间里右侧的滑出抽屉现在几乎成了主流直播的标配，无论是映客还是Bigo，都很早就上线了抽屉。我所在的这个产品最近也要上同样的功能，因此需要简单实现一个。
  要实现一个简单的侧滑抽屉，最先想到的就是直接使用<code>DrawerLayout</code>，但是无法满足产品的一个手势要求: 在屏幕任何位置都可以调出和收起抽屉。<code>DrawerLayout</code> 的默认行为是只能从屏幕边缘调出。因此需要改变DrawerLayout的默认行为，使期能够从屏幕任何位置调出，这就需要通过反射修改drawerlayout的edgesize属性，因为drawerlayout还可以通过长按调出，我们的产品需求并不需要这个行为，因此也需要屏蔽掉，通过一个静态方法来统一实现：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public static void setDrawerLeftEdgeSize(DrawerLayout drawerLayout,
                                             float percent) {
    if (drawerLayout == null)
        return;
    try {
        //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小
        Field rightDraggerField = drawerLayout.getClass().getSuperclass().getDeclaredField(&quot;mRightDragger&quot;);
        rightDraggerField.setAccessible(true);
        ViewDragHelper rightDragger = (ViewDragHelper) rightDraggerField.get(drawerLayout);

        Field edgeSizeField = rightDragger.getClass().getDeclaredField(&quot;mEdgeSize&quot;);
        edgeSizeField.setAccessible(true);
        int edgeSize = edgeSizeField.getInt(rightDragger);

        edgeSizeField.setInt(rightDragger, Math.max(edgeSize, (int)(UIUtils.getScreenWidth() * percent)));

        //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”
        //更改其属性 mPeekRunnable
        Field rightCallbackField = drawerLayout.getClass().getSuperclass().getDeclaredField(&quot;mRightCallback&quot;);
        rightCallbackField.setAccessible(true);

        //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例
        ViewDragHelper.Callback leftCallback = (ViewDragHelper.Callback) rightCallbackField.get(drawerLayout);

        Field peekRunnableField = leftCallback.getClass().getDeclaredField(&quot;mPeekRunnable&quot;);
        peekRunnableField.setAccessible(true);
        Runnable nullRunnable = new Runnable() {
            @Override
            public void run() {

            }
        };
        peekRunnableField.set(leftCallback, nullRunnable);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre></div>
<p>解决了edgsize和长按的问题后，马上又面临一个净屏页和抽屉的手势滑动冲突问题，并且还要注意两个UI元素的层级，基本的解决思路是根据滑动的方向和净屏页的状态在<code>DrawerLayout</code>子类的onInterceptTouchEvent里来处理事件拦截，改变<code>DrawerLayout</code>的默认行为，净屏页的逻辑不变，只向<code>DrawerLayout</code>提供状态的get方法，具体实现如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
public boolean onInterceptTouchEvent(MotionEvent ev){
    Log.d(&quot;drawerLayout&quot;, &quot;onInterceptTouchEvent, action: &quot;
            + ev.getAction() + &quot; x= &quot; + ev.getX() + &quot; y=&quot; + ev.getY());

    boolean drawerOpen = this.isDrawerOpen(Gravity.RIGHT);
    boolean pureMode = contentView.isPureMode();

    switch(ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mLastX = ev.getX();
            mLastY = ev.getY();

            /*
            final View touchedView = findTopChildUnder((int) mLastX, (int) mLastY);
            boolean isContent = isContentView(touchedView);


            if (!drawerOpen &amp;&amp; isContent) {
                return false;
            }
              */

            break;
        case MotionEvent.ACTION_MOVE:
            float dx = ev.getX() - mLastX;
            float dy = ev.getY() - mLastY;

            boolean horizontal = Math.abs(dx) &gt; Math.abs(dy);

            if (!pureMode &amp;&amp; dx &lt; 0 &amp;&amp; horizontal) {

            } else if(!pureMode &amp;&amp; dx &gt; 0 &amp;&amp; drawerOpen &amp;&amp; horizontal){

            } else {
                return false;
            }

            break;
        default:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre></div>
<p>这样用最小的开发成本完成了产品的需求，实现了主流直播产品的抽屉功能。唯一的小瑕疵是直播间上下滑动时不能自动收起抽屉，这个因为并不是产品很在意的点，再加上产品需求紧急，就没有深究。当然了，这个抽屉功能其实可以抽取出来做成一个通用的抽屉，提供不同的接口来满足定制要求。</p>

<p>tips：<code>DrawerLayout</code>显示区域穿透的问题可以这样解决：
将显示区域的clickable属性设置为true。</p>

	  ]]></description>
	</item>

	<item>
	  <title>为什么学习设计模式</title>
	  <link>//why-learn-design-pattern</link>
	  <author>Tao He</author>
	  <pubDate>2020-05-08T04:54:12+08:00</pubDate>
	  <guid>//why-learn-design-pattern</guid>
	  <description><![CDATA[
	     <p>设计模式，可能是每一个程序员都绕不过去的话题，有人认为特别重要，有人对其嗤之以鼻，也有人并不是很确定它的重要性。为什么要学习设计模式，这么多年以来其实我也没有看到一个很好的回答，前一阵在Youtube看到一个讲Android系统开发的youtuber的主页，发现他的一篇很短的文章探讨了这个问题，看完后感觉醍醐灌顶，因此有冲动翻译并记录下其主要的观点。</p>

<p>编程如下棋，一个新手刚开始接触时，首先要了解能够正常下棋的要素，如棋子，棋盘，要熟悉棋子移动，吃子，将军的规则，等这些都了解了以后，就可以正常下棋了，虽然可能下的不好，但是渐渐的，开始领会一些这个游戏的基本规律，如何占取优势，如何使用策略，通过一次次的棋局，逐步的识别出一些可能是很愚蠢的错误，并在以后的棋局中尽量避免，一个新手也可能下棋下的越来越好。</p>

<p>但是一个人如果想成为下棋的大师，却需要学习大师们所下过的棋局。隐藏在这些棋局中的模式必须通过理解，记忆，反复应用，最后成为一个人的本能。这些模式可能是成千上万的，开放模式更是繁多，以至于有很多关于其变化的书籍。 游戏中模式和结束模式也很普遍，作为大师们必须熟悉它们。</p>

<p>编程也一样，首先学习规则，学习算法，数据结构，熟悉了这些后就可以编程了，尽管所写的代码会比较蹩脚。之后，开始学习软件设计的原则，如结构化编程，模块化编程，面向对象编程，如高内聚低耦合的重要性，如信息隐藏和依赖管理。等这些都学习了以后，一个人要想成为真正的编程大师，还是需要学习大师们的设计，并深入这些设计，举一反三，这些模式必须被理解，记忆，反复应用，最后成为一个人的本能。</p>

<p>这篇文章本来就很短，但是我依旧要提炼出本文要划重点的句子:</p>

<blockquote>
<p>一个人要想成为真正的编程大师，还是需要学习大师们的设计，并深入这些设计，举一反三，这些模式必须被理解，记忆，反复应用，最后成为一个人的本能。</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>解决TextView中emoji被截断的问题</title>
	  <link>//fix-textview-emoji-problem</link>
	  <author>Tao He</author>
	  <pubDate>2020-04-22T04:54:12+08:00</pubDate>
	  <guid>//fix-textview-emoji-problem</guid>
	  <description><![CDATA[
	     <p>理论上TextView中包含emoji显示是没有问题的，问题出在如果TextView限制了宽度，且末尾包含了emoji字符，但是又不够显示，则会出现乱码的情况，原因是单个emoji由两个字符组成，TextView在截断字符时按单个字符截断，所以就有emoji的两个字符被截断后显示的情况，TexView自然无法正常显示。网上有很多解决办法，思路都是通过改变TextView的行为来规避这个问题，但都不理想，在一些特殊情况下仍然有问题。后来我改变了思路，不对TextView做任何更改，而是通过保证emoji本身不被截断来解决问题。</p>

<p>考虑这样一个场景，直播间顶部主播区域的主播昵称，肯定是有字数限制的，如果昵称中包含emoji，如何保证emoji不被截断，并且不丧失在昵称过长后需要...的功能?</p>

<p>代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void setAnchorName(String nick) {
    if (TextUtils.isEmpty(nick)) {
        labelUserName.setText(&quot;&quot;);
        return;
    }
    int len = TextCharUtils.getCurLength(nick);
    if (len &lt;= 8) {
        labelUserName.setText(nick);
        return;
    }
    String newNick = TextCharUtils.substring(nick, 6) + &quot;...&quot;;
    labelUserName.setText(newNick);
}
</code></pre></div>
<p>思路很好理解，就是预先算出String的长度，来决定要不要做处理。 准确计算字符长度的工具类如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class TextCharUtils {
    /**
     * 获取字符串中个数（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @return
     */
    public static int getCurLength(String source) {
        if (TextUtils.isEmpty(source)) {
            return 0;
        }
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (&quot;&quot;.equals(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            temp = index;
        }
        return size;
    }

    /**
     * 截取字符串（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @param end
     * @return
     */
    public static String substring(String source, int end) {
        if (TextUtils.isEmpty(source)) {
            return source;
        }
        StringBuffer sb = new StringBuffer();
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (TextUtils.isEmpty(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            if (size &gt; end) {
                break;
            }
            sb.append(sub);
            temp = index;
        }
        return sb.toString();
    }

    public static int getCharSize(char word) {
        return (isChineseChar(word) || isEmojiCharacter(word)) ? 2 : 1;
    }

    /**
     * 计算中文字符与表情字符
     */
    public static Pair&lt;Integer, Integer&gt; getSpecialCharNum(CharSequence sequence) {
        if (TextUtils.isEmpty(sequence)) {
            return new Pair&lt;&gt;(0, 0);
        }
        int chineseNum = 0, emojiNum = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {//中文
                chineseNum++;
            }

            if (isEmojiCharacter(word)) {
                emojiNum++;
            }
        }
        return new Pair&lt;&gt;(chineseNum, emojiNum / 2);
    }

    public static CharSequence getSubString(CharSequence sequence, int maxChar) {
        if (TextUtils.isEmpty(sequence)) {
            return sequence;
        }

        int size = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {
                size += 2;
            } else {
                size++;
            }

            if (size &gt;= maxChar) {
                return sequence.subSequence(0, i + 1);
            }
        }

        return sequence;
    }

    /**
     * 判断是否是中文
     */
    public static boolean isChineseChar(char c) {
        Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);
        return ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B
                || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS
                || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION;
    }

    public static boolean isEmojiCharacter(char codePoint) {
        return !(codePoint == 0x0 || codePoint == 0x9 || codePoint == 0xA ||
                codePoint == 0xD || codePoint &gt;= 0x20 &amp;&amp; codePoint &lt;= 0xD7FF);
    }
}
</code></pre></div>
	  ]]></description>
	</item>


</channel>
</rss>
