<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>解决TextView中emoji被截断的问题</title>
	  <link>//fix-textview-emoji-problem</link>
	  <author>Tao He</author>
	  <pubDate>2020-04-22T04:54:12+08:00</pubDate>
	  <guid>//fix-textview-emoji-problem</guid>
	  <description><![CDATA[
	     <p>理论上TextView中包含emoji显示是没有问题的，问题出在如果TextView限制了宽度，且末尾包含了emoji字符，但是又不够显示，则会出现乱码的情况，原因是单个emoji由两个字符组成，TextView在截断字符时按单个字符截断，所以就有emoji的两个字符被截断后显示的情况，TexView自然无法正常显示。网上有很多解决办法，思路都是通过改变TextView的行为来规避这个问题，但都不理想，在一些特殊情况下仍然有问题。后来我改变了思路，不对TextView做任何更改，而是通过保证emoji本身不被截断来解决问题。</p>

<p>考虑这样一个场景，直播间顶部主播区域的主播昵称，肯定是有字数限制的，如果昵称中包含emoji，如何保证emoji不被截断，并且不丧失在昵称过长后需要...的功能?</p>

<p>代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void setAnchorName(String nick) {
    if (TextUtils.isEmpty(nick)) {
        labelUserName.setText(&quot;&quot;);
        return;
    }
    int len = TextCharUtils.getCurLength(nick);
    if (len &lt;= 8) {
        labelUserName.setText(nick);
        return;
    }
    String newNick = TextCharUtils.substring(nick, 6) + &quot;...&quot;;
    labelUserName.setText(newNick);
}
</code></pre></div>
<p>思路很好理解，就是预先算出String的长度，来决定要不要做处理。 准确计算字符长度的工具类如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class TextCharUtils {
    /**
     * 获取字符串中个数（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @return
     */
    public static int getCurLength(String source) {
        if (TextUtils.isEmpty(source)) {
            return 0;
        }
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (&quot;&quot;.equals(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            temp = index;
        }
        return size;
    }

    /**
     * 截取字符串（汉字、emoji算2个长度，数字、英文算一个）
     *
     * @param source
     * @param end
     * @return
     */
    public static String substring(String source, int end) {
        if (TextUtils.isEmpty(source)) {
            return source;
        }
        StringBuffer sb = new StringBuffer();
        int codePointCount = source.codePointCount(0, source.length());
        int temp = 0;
        int size = 0;
        for (int i = 1; i &lt;= codePointCount; i++) {
            int index = source.offsetByCodePoints(0, i);
            String sub = source.substring(temp, index);
            if (TextUtils.isEmpty(sub)) {
                continue;
            }
            size += getCharSize(sub.charAt(0));
            if (size &gt; end) {
                break;
            }
            sb.append(sub);
            temp = index;
        }
        return sb.toString();
    }

    public static int getCharSize(char word) {
        return (isChineseChar(word) || isEmojiCharacter(word)) ? 2 : 1;
    }

    /**
     * 计算中文字符与表情字符
     */
    public static Pair&lt;Integer, Integer&gt; getSpecialCharNum(CharSequence sequence) {
        if (TextUtils.isEmpty(sequence)) {
            return new Pair&lt;&gt;(0, 0);
        }
        int chineseNum = 0, emojiNum = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {//中文
                chineseNum++;
            }

            if (isEmojiCharacter(word)) {
                emojiNum++;
            }
        }
        return new Pair&lt;&gt;(chineseNum, emojiNum / 2);
    }

    public static CharSequence getSubString(CharSequence sequence, int maxChar) {
        if (TextUtils.isEmpty(sequence)) {
            return sequence;
        }

        int size = 0;
        for (int i = 0; i &lt; sequence.length(); i++) {
            char word = sequence.charAt(i);
            if (isChineseChar(word)) {
                size += 2;
            } else {
                size++;
            }

            if (size &gt;= maxChar) {
                return sequence.subSequence(0, i + 1);
            }
        }

        return sequence;
    }

    /**
     * 判断是否是中文
     */
    public static boolean isChineseChar(char c) {
        Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);
        return ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B
                || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS
                || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION;
    }

    public static boolean isEmojiCharacter(char codePoint) {
        return !(codePoint == 0x0 || codePoint == 0x9 || codePoint == 0xA ||
                codePoint == 0xD || codePoint &gt;= 0x20 &amp;&amp; codePoint &lt;= 0xD7FF);
    }
}
</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>最简LeakCanary原理解析</title>
	  <link>//most-simple-leakcanary-principle</link>
	  <author>Tao He</author>
	  <pubDate>2019-11-11T04:54:12+08:00</pubDate>
	  <guid>//most-simple-leakcanary-principle</guid>
	  <description><![CDATA[
	     <p>LeakCanary现在几乎成了Android开发过程中的一个标配，使用起来非常简单，能够帮助开发者发现和规避大部分的内存泄露问题。虽然大部分的开发者都或多或少，或深或浅的接触过LeakCanary，说起来是比较熟悉的一个第三方框架了，但是谈到LeakCanary的原理可能就会陌生很多。虽然网上也有非常多的讲解LeakCanary的文章，但是很多博文要么陷入无止境的代码细节中，要么就泛泛而谈，都不能很清楚的将LeakCanary的原理讲清楚。这篇文章尽力规避前两种文章的问题，用最小的篇幅把LeakCanary的原理讲清楚。</p>

<h4>LeakCanary到底是怎么工作的?</h4>

<p>LeakCanary能够准确，及时地检测到内存泄露，有以下几个关键点</p>

<ul>
<li>检测保留的实例</li>
</ul>

<p>LeakCanary能够工作的基石是一个叫做ObjectWatcher的库，它hook了Android中Activity和Fragment的生命周期，能够自动检测到Activity和Fragment的销毁和将要被GC，这些被检测到的Activity和Fragment的实例被传给了<code>ObjectWatcher</code>，<code>ObjectWatcher</code>以WeakReference持有他们。如果这些WeakReference在5秒后或者一次GC周期以后还没有被清理，那么LeakCanary认为这些实例被保留了，没有被回收，泄露发生了。检测没有被回收的实例是LeakCanary能够工作起来的基石，也是后续处理的基础，这一点非常重要。</p>

<ul>
<li>Dump 堆</li>
</ul>

<p>这一步需要对检测到的泄露进行处理，当然也不是检测到一个实例就会触发dump，而是有一个阈值，当达到一定数量实例的泄露后就会触发LeakCanary将Java堆内存dump到<code>.hprof</code>文件中去，当然了，这个文件存储在Android文件系统中。这个触发dump的阈值是如何确定的呢？如果App还可见，那这个阈值默认是5，如果App不可见，阈值默认是1。</p>

<ul>
<li>分析Java 堆</li>
</ul>

<p>LeakCanary使用<code>Shark</code>来分析<code>.hprof</code>文件，找出阻止实例被回收的引用链:leak trace.其实leak trace的另一个名字是GC Root到被引用实例的最短强引用路径。一旦leak trace确定了，LeakCanary会根据内置的对Android的知识库来推断出leak trace上哪个实例泄露了。</p>

<ul>
<li>Leak分组</li>
</ul>

<p>LeakCanary使用泄露的状态信息，将引用链缩小为可能引起泄露的子引用链，并且在界面上显示出来，也就是我们在LeakCanary界面上看到的信息。有的泄露可能不相关，但是引用链相同，也会被认为是同一个引用链，所以泄露会根据相同的子引用链分组。</p>

<p>以上就是LeakCanary基本原理的关键点，相信也是最简单的对LeakCanary原理的描述了吧!</p>

	  ]]></description>
	</item>

	<item>
	  <title>ImageSpan的定制使用</title>
	  <link>//custom-image-span</link>
	  <author>Tao He</author>
	  <pubDate>2019-10-19T04:54:12+08:00</pubDate>
	  <guid>//custom-image-span</guid>
	  <description><![CDATA[
	     <p>最近在做一个具体业务需求时，为了实现UI设计的要求，需要实现在同一段文字中，有一段文字是需要有形状的背景色，有一段文字中还有网络图片的插入，如果要达到这两个要求，简单的使用SpannableStringBuilder肯定是达不到要求的，虽然SpannableStringBuilder可以设置背景色，但是并不能绘制形状，说白了就是只能设置颜色，不能设置文字的背景图片。想要在文字中插入图片，可以直接使用ImageSpan，但是ImageSpan并不能加载网络图片。因此这种简单的使用方式都是行不通的，需要考虑去定制ImageSpan实现我们特殊的要求。</p>

<ul>
<li>实现给同一段文字的一部分文字区域设置背景图片</li>
</ul>

<p>这个功能的实现还是要继承ImageSpan，将我们的背景图片传进去，并且override ImageSpan的draw方法，根据对文字区域的测量，分别绘制出背景和文字。实现代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// BgImageSpan

public class BgImageSpan extends ImageSpan {

    private int textSize = 20;
    private int color = Color.GRAY;
    private TextView mTextView;
    static float textboundhight;
    static float textY;
    String mText;

    public BgImageSpan(Drawable d, TextView tv, String text) {
        super(d);
        mTextView = tv;
        mText = text;
        textSize = (int) mTextView.getTextSize();
    }


    @Override
    public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y,
                     int bottom, Paint paint) {

        String str = mText;
        Rect bounds = new Rect();
        paint.setTextSize(textSize);
        paint.getTextBounds(str, 0, str.length(), bounds);
        int textHeight = bounds.height();
        int textWidth = bounds.width();

        getDrawable().setBounds(0, top, (int)(bounds.width() * 1.3) , bottom);
        super.draw(canvas, str, start, end, x, top, y, bottom, paint);
        paint.setColor(mTextView.getTextColors().getDefaultColor());
        paint.setTypeface(Typeface.create(&quot;normal&quot;, Typeface.NORMAL));

        Rect bounds1 = getDrawable().getBounds();

        float textX = x + bounds1.width() / 2 - bounds.width() / 2;
        if (textboundhight == 0) {
            textboundhight = bounds.height();
            textY = (bounds1.height()) / 2 + textboundhight / 2;
        }
        canvas.drawText(str, textX, textY, paint);
    }
}
</code></pre></div>
<p>使用方法和ImageSpan并没有什么区别:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">String username = &quot;用户名：&quot;;
String message = &quot;哈哈，我是一个天才&quot;;

SpannableStringBuilder ssb = new SpannableStringBuilder(username);
ssb.append(message);

Rect bounds = new Rect();
Paint paint = mContent.getPaint();
paint.getTextBounds(username, 0, username.length(), bounds);

Drawable bgDrawable = getDrawable(R.drawable.round_rect);
bgDrawable.setBounds(0, 0, (int)(bounds.width() * 1.3), bounds.height());

ImageSpan nameBgSpan = new BgImageSpan(bgDrawable, mContent, username);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

ForegroundColorSpan contentColorSpan = new ForegroundColorSpan(Color.parseColor(&quot;#ffc800&quot;));
ssb.setSpan(contentColorSpan, username.length(), username.length() + message.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

mContent.setText(ssb);
mContent.postInvalidate();
</code></pre></div>
<p>使用代码需要注意一下几点:</p>

<ol>
<li>传给BgImageSpan的Drawable需要设置Bounds，然后再传进去，否则可能会出现字符重叠的问题。</li>
<li>如果设置了Bounds还有字符重叠错乱的问题，可以调用TextView的postInvalidate重绘。</li>
</ol>

<ul>
<li>第二种实现同一段文字的一部分文字区域设置背景图片</li>
</ul>

<p>这种实现的思路很简单，就是通过inflate一个单独的布局，然后用这个inflate好的view生成图片，然后传给一个ImageSpan，即可完成，代码如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">View view = LayoutInflater.from(this).inflate(R.layout.container, null);
TextView textView = view.findViewById(R.id.tv_value);
textView.setText(username);

view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),
        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
view.buildDrawingCache();
Bitmap bitmap = view.getDrawingCache();

ImageSpan nameBgSpan = new ImageSpan(this, bitmap);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
</code></pre></div>
<ul>
<li>实现一段文字中插入网络图片</li>
</ul>

<p>插入网络图片和插入本地图片其实没有本质区别，要插入网络图片，就得先获取到网络图片后再设置到ImageSpan中去。代码如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">String url = &quot;http://img2.imgtn.bdimg.com/it/u=1467875646,1039972052&amp;fm=26&amp;gp=0.jpg&quot;;
RequestOptions options = new RequestOptions()
        .dontAnimate()
        .diskCacheStrategy(DiskCacheStrategy.NONE);

Glide.with(this)
        .load(url)
        .apply(options)
        .into(new CustomTarget&lt;Drawable&gt;() {
            @Override
            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) {
                if (resource instanceof BitmapDrawable) {
                    resource.setBounds(0, 0, 50, 50);

                    ImageSpan iconSpan = new ImageSpan(resource);
                    ssb.setSpan(iconSpan, username.length(), username.length() + 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

                    mContent.setText(ssb);
                    mContent.postInvalidate();
                }
            }

            @Override
            public void onLoadCleared(@Nullable Drawable placeholder) {

            }
        });
</code></pre></div>
<p>使用起来需要注意的问题和上面的BgImageSpan相同，也是先要设置Drawable的Bounds。</p>

<p>虽然这两个实现看起来也没有什么难度，但是还是需要把这种解决过的，不那么常规的方法记录下来，以后遇到同样的问题可节省很多调研和调试的事件。</p>

	  ]]></description>
	</item>

	<item>
	  <title>修复VideoView引起的内存泄露小计</title>
	  <link>//fix-video-view-leak</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-21T02:30:12+08:00</pubDate>
	  <guid>//fix-video-view-leak</guid>
	  <description><![CDATA[
	     <p>最近写了非常简单的新手引导视频页面，逻辑很简单，就是新手用户在第一次使用App时可以点击引导视频入口，然后进入一个视频播放页面，为了快速实现功能，就直接使用了VideoView，从需求开发到交付也都没什么问题，需求上线后我打开LeakCanary，想观察下最近有没有新增的内存泄露，竟然发现这个视频页面竟然泄露了。排查了一圈也没有发现有什么会阻止Activity销毁。但是LeakCanary打出了引用链，发现和VideoView有关，通过Google发现，竟然是VideoView自身的bug！这种情况也不是第一次遇见，那也得解决啊，所以开始想办法。</p>

<p>首先显明确是谁导致了Activity的销毁，通过查看VideoView的源码，发现罪魁祸首是AudioManager，它可能会长期持有Context(即泄露的Activity)。很明显是因为生命周期不一致导致的泄露，因此最先想到的就是在创建VideoView时不要传Activity的Context，传给它ApplicationContext。当然了，在布局中创建的VideoView传入的就是Activity的Context，所以需要用代码动态创建:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">mVideoView = new VideoView(getApplicationContext());
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);

layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
mContainer.addView(mVideoView, layoutParams);
</code></pre></div>
<p>这样修改后还是会有内存泄露，只是引用链变了，需要在Activity的onDestroy回调中做一些处理</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@Override
protected void onDestroy() {
  super.onDestroy();

  if (mVideoView != null) {
      mVideoView.stopPlayback();
      mVideoView.setOnCompletionListener(null);
      mVideoView.setOnPreparedListener(null);
      mVideoView.setOnErrorListener(null);
      mVideoView = null;
  }

  if (mContainer != null) {
      mContainer.removeAllViews();
  }
</code></pre></div>
<p>以上解决办法需要注意三点：</p>

<ul>
<li>给VideoView设置的Listener都要分别置空，否则仍然会泄露</li>
<li>VideoView的父容器要删掉VideoView，光置空VideoView不够</li>
<li>需设置VideoView的OnErrorListener且返回true，防止弹出弹窗使用ApplicationContext导致崩溃 </li>
</ul>

<p>传递ApplicationContext还有人提出另一种方法，但是我test发现没有效果，这种方法我也贴出来:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// Override Activity的attachBaseContext的行为
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new ContextWrapper(newBase){
        @Override
        public Object getSystemService(String name) {
            if(Context.AUDIO_SERVICE.equals(name)){
                return getApplicationContext().getSystemService(name);
            }
            return super.getSystemService(name);
        }
    });
}
</code></pre></div>
<p>去规避系统API的bug真是很烦人的一件事，既不优雅，也不安全！</p>

	  ]]></description>
	</item>

	<item>
	  <title>Parcelable vs Serializable</title>
	  <link>//serializable-vs-parcelable</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-19T02:30:12+08:00</pubDate>
	  <guid>//serializable-vs-parcelable</guid>
	  <description><![CDATA[
	     <p>在实际的Android开发中Serializable和Parcelable我们都会用到，只是需要区分使用场景。刚开始遇到这两个接口的时候比较疑惑，貌似都是用来做序列化的，虽然能分得清什么时候用哪个，但是对这两个接口并没有清晰的认识，要是冷不丁的问我这俩有什么区别，可能还无法清晰的界定和阐述。因此有必要用一篇文章来彻底捋清这些东西。</p>

<h3>相同点</h3>

<p>相同点其实很明显，主要有如下两点:</p>

<ul>
<li><p>都可以序列化反序列化</p></li>
<li><p>都可以通过Intent传递</p></li>
</ul>

<h3>区别</h3>

<ul>
<li><p>Serializable是Java API，Parcelable是Android SDK API，设计目的不同。Serializable是一个通用的序列化机制，通过将文件保存到本地文件、网络流等实现便数据的传递，这种数据传递不仅可以在单个程序中进行，也可以在两个不同的程序中进行；Parcelable是Android SDK API,为了在同个程序的不同组件之间和不同程序（AIDL）之间高效的传输数据，是通过IBinder通信的消息的载体。从设计目的上可以看出Parcelable就是为了Android高效传输数据而生的。</p></li>
<li><p>Serializable序列化过程使用反射机制，速度慢，且产生很多临时对象，容易触发GC；Parcelable是直接在内存中读写的，自已实现封送和解封（marshalled &amp;unmarshalled）操作，将一个完整的对象分解成Intent所支持的数据类型，不需要使用反射，所以Parcelable具有效率高，内存开销小的优点。</p></li>
<li><p>Serializable是通用的序列化机制，将数据存储在磁盘，可以做到有限持久化保存，文件的生命周期不受程序影响，Parcelable的序列化操作完全由底层实现，不同版本的Android是实现方式可能不相同，所以不能进行持久化存储。</p></li>
<li><p>使用场景不同。Parcelable 是 Android 中的序列化方式，因此更适合于 Android 平台上，它的缺点是使用起来稍微麻烦点，但它的效率很高，这是 Android 推荐的序列化方式，因此我们要首选 Parcelable。但 Serializable 也不是在 Android 上无用武之地，下面两种情况就发日常适合 Serializable：</p>

<ol>
<li>需要将对象序列化到设备；</li>
<li>对象序列化后需要网络传输。</li>
</ol></li>
</ul>

<p>这样一一列举了两者的相同点和区别，对两者的认识清晰了很多！积跬步，共勉！</p>

	  ]]></description>
	</item>

	<item>
	  <title>修复崩溃ANR小记</title>
	  <link>//fix-crash-and-anr</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-11T02:30:12+08:00</pubDate>
	  <guid>//fix-crash-and-anr</guid>
	  <description><![CDATA[
	     <p>最近一直在集中精力解决Bugly的崩溃，到现在基本上把可以解决的已经都解决完了，剩下的都是一些特定系统版本和特定机型的崩溃，暂时没有太好的思路去排查，其中系统4.4版本的崩溃尤为特殊，有几个崩溃几乎都只出现在4.4版本的机器上，这些特定版本和特定机型的问题暂不谈论，下面来小结一下最近成功解决过的一些崩溃和ANR。</p>

<ul>
<li>复写父类方法要当心，注意父类的方法约定(崩溃)</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text"># main(1)
java.lang.NullPointerException
Attempt to invoke virtual method &#39;android.graphics.Rect android.graphics.drawable.Drawable.getBounds()&#39; on a null object reference
1 android.text.style.DynamicDrawableSpan.getSize(DynamicDrawableSpan.java:78)
2 android.text.TextLine.handleReplacement(TextLine.java:813)
3 android.text.TextLine.handleRun(TextLine.java:908)
4 android.text.TextLine.measureRun(TextLine.java:387)
5 android.text.TextLine.measure(TextLine.java:277)

...

暂略
</code></pre></div>
<p>堆栈太长，底下的暂略，这个崩溃乍一看，没啥线索，崩到了系统类DynamicDrawableSpan，然后就看工程中有没有用到DynamicDrawableSpan，果然发现我们的类EmojiTextSpan继承了这个类，那可以缩小问题范围了，从崩溃处逆推调用栈，可以发现我们的类复写了：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private Drawable getCachedDrawable() {
    if (mDrawableRef == null || mDrawableRef.get() == null) {
        mDrawableRef = new WeakReference&lt;Drawable&gt;(getDrawable());
    }
    return mDrawableRef.get();
}
</code></pre></div>
<p>而DynamicDrawableSpan的方法实现如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private Drawable getCachedDrawable() {
    WeakReference&lt;Drawable&gt; wr = mDrawableRef;
    Drawable d = null;

    if (wr != null) {
        d = wr.get();
    }

    if (d == null) {
        d = getDrawable();
        mDrawableRef = new WeakReference&lt;Drawable&gt;(d);
    }

    return d;
}
</code></pre></div>
<p>很明显我们的类做了一个蠢事，其实不用去复写父类的方法，反而不会有问题，这个问题的根本原因是我们没有详细了解这个类，至少是没有了解这个方法的约定。只要删除我们的复写方法即可解决问题。当然，系统代码也不严谨，drawable在调用getBounds方法时没有判空。</p>

<ul>
<li>主线程切不可进行IO操作(ANR)</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class GameBgmService extends Service {

    ...
    ...

    @Override
    public void onCreate() {
        super.onCreate();
        ...
        ...

        PathUtil.findAllKV(BGM_PATH, mBgmMap);
    }
}
</code></pre></div>
<p>根据ANR的堆栈，可以追踪到是</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">PathUtil.findAllKV(BGM_PATH, mBgmMap);
</code></pre></div>
<p>的调用导致了ANR，而这个方法是一个典型的IO操作，而这种操作不应该在系统组件的生命周期方法里调用。解决方法也很简单，就是将这种操作放到子线程去。</p>

<ul>
<li>有时需要频繁IO操作，可考虑建立内存缓存，避免ANR</li>
</ul>

<p>这个ANR和上面的类似，也是要进行一个IO操作，并且和上面不一样的是，这个操作需要同步进行，不能异步，因此我们采取建立内存缓存的方式来解决。这个IO操作其实是通过解析文件中的json，创建出一个对象列表返回，而这个操作在App进入首页的时候就在子线程中操作过一次，但是并没有在这个时机去建立内存缓存，因此这个问题的最简单解决方式就是建立内存缓存，在之前需要IO操作的地方直接操作内存，并且保证文件和内存的内容一致即可。</p>

<ul>
<li>使用RxJava需要注意Backpressure(崩溃)</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text"># main(1)

io.reactivex.exceptions.MissingBackpressureException

Can&#39;t deliver value 9440 due to lack of requests

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | io.reactivex.exceptions.MissingBackpressureException: Can&#39;t deliver value 9440 due to lack of requests
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 io.reactivex.exceptions.MissingBackpressureException:Can&#39;t deliver value 9440 due to lack of requests
6 io.reactivex.internal.operators.flowable.FlowableIntervalRange$IntervalRangeSubscriber.run(FlowableIntervalRange.java:117)
7 io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:38)
8 java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:458)
9 java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307)
10 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302)
11 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
12 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
13 java.lang.Thread.run(Thread.java:784)
</code></pre></div>
<p>这个崩溃根据堆栈可追溯到RxJava中的intervalRange操作符，工程中有多处使用，找到一个典型使用:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private void startCountDown(String order, String text, long time) {
    if (time &gt; 0) {
        if (mDisposable != null &amp;&amp; !mDisposable.isDisposed()) {
            mDisposable.dispose();
            mDisposable = null;
        }
        mDisposable = Flowable.intervalRange(0, time + 1, 0, 1, TimeUnit.SECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&lt;Long&gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        if (mKillerAreaTop != null) {
                            if (aLong == time) {
                                mKillerAreaTop.setText(String.format(&quot;【%s号】%s&quot;, order, text));
                            } else {
                                mKillerAreaTop.setText(String.format(Locale.CHINA,
                                        &quot;【%s号】%s(%d)&quot;, order, text, time - aLong));
                            }
                        }
                    }
                });

    }
}
</code></pre></div>
<p>这个问题RxJava在GitHub上的issue已解决，添加流量控制，在调用intervalRange后紧接着调用onBackpressDrop即可。</p>

<ul>
<li>RxJava和ButterKnife混用时先clear disposable后unbind</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text"># main(1)

java.lang.NullPointerException

Attempt to invoke virtual method &#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&#39; on a null object reference

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:java.lang.NullPointerException: Attempt to invoke virtual method &#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&#39; on a null object reference
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 java.lang.NullPointerException:Attempt to invoke virtual method &#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&#39; on a null object reference
6 io.liuliu.music.hall.hall.widget.UserInfoView$1.onStartDownload(UserInfoView.java:159)
7 io.liuliu.music.resource.GoodsResProvider.lambda$startEffect$3(GoodsResProvider.java:121)
8 io.liuliu.music.resource.-$$Lambda$GoodsResProvider$o_C6H-o_OQTCEa45A-3wRHNQygg.accept(Unknown Source:10)
9 io.reactivex.internal.observers.ConsumerSingleObserver.onSuccess(ConsumerSingleObserver.java:62)

......
</code></pre></div>
<p>看似一个很普通的一个崩溃，对这个View对象使用前判空就完事了，但是实际问题没那么简单，很多页面使用了这个机制，难道要每个页面的每个View在使用前都要判空吗？必须从机制上保证在RxJava的异步回调中View对象不为空，检查代码后发现的确是有这个保证的，就是在View要销毁时clear掉RxJava的异步回调，问题出在先后顺序上，写代码时并没有注意到这个先后顺序，unbind都在clear disposable之前，导致了这种崩溃有概率发生。</p>

<ul>
<li>Fragment has not been attached yet 崩溃</li>
</ul>

<p>这个崩溃时因为Fragmegnt还没有Attach到Activity就调用了getChildFragmnetManager()导致，可通过添加isAdded判断，或在attach和detach时加一个标志来判断当前fragment的状态。</p>

<ul>
<li>多线程没有同步导致的崩溃</li>
</ul>

<p>这种问题比较常见了，虽然一个移动端App不需要很大量的并发，但是多个线程同时存在，并且操作共享变量的情况也不少，在这次修复崩溃的过程中就遇到很多例，都是因为对共享变量没有保护，导致其中一个线程已经把变量置空，而其他线程还在dereference这个变量而导致崩溃。这类问题，可根据实际情况采取不同的同步策略。</p>

<ul>
<li>在UI线程中start，reset，release MediaPlayer导致的ANR</li>
</ul>

<p>只要用到MediaPlayer的工程可能都避免不了这个问题吧，最好的解决办法就是将这些操作都放在一个非UI线程里，而把一些事件回调调度回UI线程，这样既不会有ANR，也将MediaPlayer的使用变得比较简单。典型的做法是对MediaPlayer进行封装，使用两个Handler和一个HandlerThread，将对MediaPlayer的操作都放在HandlerThread中，事件回调都通过其中一个Handler调度回主线程。</p>

<p>以上就是最近解决的一些典型的崩溃和ANR，作此小计，积跬步。</p>

	  ]]></description>
	</item>

	<item>
	  <title>Android防空指南</title>
	  <link>//guide-to-prevent-null-in-android-project</link>
	  <author>Tao He</author>
	  <pubDate>2019-09-07T04:20:12+08:00</pubDate>
	  <guid>//guide-to-prevent-null-in-android-project</guid>
	  <description><![CDATA[
	     <p>最近集中进行了一段时间降低公司App崩溃率的工作，现在App的崩溃率控制在了万一与万三之间，整体来说还比较顺利，有必要将其中的方法和经验做一个沉淀。由于空指针异常导致的崩溃对App整体的崩溃率贡献巨大，日常的崩溃修复总是少不了几个空指针异常，虽然明显的空指针异常修复很容易，但是发出去的版本会持续崩溃，影响留存和体验，因此在积极修复空指针崩溃的同时也需要未雨绸缪，在开发阶段就把空指针拒之门外，对于事前防空的讨论非常多，也有大量的文章总结和分析这件事情，此文可能会提及这些讨论，但是主要还是总结我实践过的一些防空措施：</p>

<h3>编写不空的代码</h3>

<p>这个是基础，也是第一道防线，如果这一步没有做好，后面的一些措施可能负担更重。编写不空的代码其实就是要求我们在编写具体的方法和接口时尽量保证不返回null值，以及一些编程语言特性来避免空指针，也就是从根源上杜绝client代码不经意间去dereference一个空对象，具体的办法，或者说一些规约如下：</p>

<ul>
<li>对于数组，比如Point，返回空对象，return new Point[0];</li>
<li>对于容器，比如ArraryList,返回空对象。如果需要泛型支持，retrun Collections.emptyList(); 如果不需要泛型支持，则 return Collections.EMPTY_LIST;</li>
<li>对于字符串String,返回空对象， return “”; 而不是return null;</li>
<li>这一条用语言不好表达，直接看代码</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">// wrong way - may cause NullPointerException
if (unknownObj.equals(&quot;unknownObj&quot;)) {
}
// right way - avoid NPE even if unknownObj is null
if (&quot;unknownObj&quot;.equals(unknownObj) {
}
</code></pre></div>
<ul>
<li>更加偏好使用valueOf()，而不是toString()</li>
<li>避免没有必要的boxing和unboxing</li>
<li>遵守约定，定义有意义的default(初始)对象</li>
<li>如果必须返回null值，则用@Nullable注解标注，并在Android Studio中打开此类注解的警告开关，如遇警告，积极修复此类警告后再继续编码。</li>
<li>进行双重入参校验</li>
<li>使用Java8新特性，Optional</li>
</ul>

<p>以上这些措施需要在代码编写时真正去遵守和实践，长期坚持下来会有不错的效果。如果以上措施是事前，那下面的措施就算是事后防空屏障了。</p>

<h3>通过静态检测工具检查编译阶段代码</h3>

<p>在不胜其烦的修复了很多Bugly上的空指针以后，我决定一定要找出一个能在编译阶段就能发现空指针风险的办法，于是就想到了通过静态代码检测工具来做这个事情。最先想到的就是findbugs，还找到了一个叫SpotBug的插件，但是这两个插件都没有针对性，毕竟我最优先要解决的是空指针异常的问题。又开始重新找寻，最后找到了由Uber公司研发的Nullaway检查器，它需要配合ErrorProne插件一起使用。因为Nullaway在Gradle里的配置，github上的README有点语焉不详，至少下面两个问题就很让人疑惑:
* 那些配置语句到底写在project的build.gradle文件里还是app下的build.gradle？ （当然如果你的工程只有一个app模块的话不存在这个问题)
* 在多模块的情况下是否可以统一在project的build.gradle文件里配置，还是需要在每个模块里配置一遍？</p>

<p>所以我决定记录下我的采坑过程:  </p>

<h4>配置ErrorProne插件和Nullaway检查器</h4>
<div class="highlight"><pre><code class="language-text" data-lang="text">//build.gradle

buildscript {
    dependencies {
        classpath deps.gradlePlugin
        classpath deps.butterKnife
        classpath deps.wallePlugin
        classpath deps.sensorsPlugin

        classpath deps.realmPlugin

        // 配置ErrorProne插件和Nullaway检查器
        classpath deps.spotBugPlugin
        classpath deps.errorPronePlugin
    }
    repositories {
        google()
        jcenter()
    }
}


// check.gradle

apply plugin: &#39;net.ltgt.errorprone&#39;
tasks.withType(JavaCompile) {
    // remove the if condition if you want to run NullAway on test code
    if (!name.toLowerCase().contains(&quot;test&quot;)) {
        // remove &quot;-Xep:NullAway:ERROR&quot; to have NullAway only emit warnings
        options.compilerArgs += [&quot;-Xep:NullAway:WARN&quot;,
                                 //&quot;-XepAllErrorsAsWarnings&quot;,
                                 &quot;-XepExcludedPaths:.*/build/generated/.*&quot;,
                                 &quot;-Xep:UnusedVariable:OFF&quot;,
                                 &quot;-Xep:UnusedMethod:OFF&quot;,
                                 &quot;-Xep:UnnecessaryParentheses:OFF&quot;,
                                 &quot;-Xep:CatchAndPrintStackTrace:OFF&quot;,
                                 &quot;-Xep:DefaultCharset:OFF&quot;,
                                 &quot;-Xep:JdkObsolete:OFF&quot;,
                                 &quot;-Xep:ClassCanBeStatic:OFF&quot;,
                                 &quot;-Xep:MissingOverride:OFF&quot;,
                                 &quot;-Xep:FragmentNotInstantiable:OFF&quot;,
                                 &quot;-Xep:VariableNameSameAsType:OFF&quot;,
                                 &quot;-Xep:FallThrough:OFF&quot;,
                                 &quot;-Xep:FutureReturnValueIgnored:OFF&quot;,
                                 &quot;-Xep:OperatorPrecedence:OFF&quot;,
                                 &quot;-Xep:UndefinedEquals:OFF&quot;,
                                 &quot;-Xep:RxReturnValueIgnored:OFF&quot;,
                                 &quot;-Xep:StringSplitter:OFF&quot;,
                                 &quot;-Xep:EqualsHashCode:OFF&quot;,
                                 &quot;-Xep:EqualsGetClass:OFF&quot;,
                                 &quot;-Xep:ComplexBooleanConstant:OFF&quot;,
                                 &quot;-Xep:DoubleBraceInitialization:OFF&quot;,
                                 &quot;-Xep:InconsistentCapitalization:OFF&quot;,
                                 &quot;-Xep:HidingField:OFF&quot;,
                                 &quot;-Xep:EqualsUnsafeCast:OFF&quot;,
                                 &quot;-XepOpt:NullAway:AnnotatedPackages=com.inyuapp,io.liuliu&quot;]
    }
}

// 因为我们的工程有很多个模块，因此我在每个module的build.gradle如下配置:

apply plugin: &#39;com.android.library&#39;
apply from: &#39;../../check.gradle&#39;
</code></pre></div>
<p>这个配置之后基本就可以正常使用了，但是还是需要特别注意几个问题，也是我在集成的过程中踩过的坑:</p>

<ul>
<li>在project的build.gradle中统一配置的方式会报Nullaway找不到的问题，这个目前无解，就只能通过在每个module分别配置，不过可以通过统一写一个check.gradle，在每个module的build.gradle中apply，如上</li>
<li>可以配置ErrorProne每个检查器的编译错误级别，分别有ERROR，WARN，OFF，如果某个检查器配置为ERROR级别，那么此检查器如果在代码中发现此类问题，就会导致整个build失败，如果对特定的错误很关注，可设为ERROR级别，限制处理完此类问题才能build成功。</li>
<li>Nullaway检查器需要配置要检查的包，多个源代码包可通过”,&quot;分割</li>
<li>Nullaway的检查都是基于@Nullable注解，因此在类中的字段，方法返回值，入参上适当使用@Nullable才能使Nullaway检查器很好工作</li>
<li>此类代码不会通过Nullaway检查</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (ControllerHelper.getTopLineModel() != null) {
    ControllerHelper.getTopLineModel().setUserLifeShow(false);
    ControllerHelper.getTopLineModel().setCoinNumberShow(true);
}
</code></pre></div>
<p>在开启了ErrorProne和Nullable检查器后，公司的工程出现了大量无法通过检查器的代码，出现问题最多的错误如下：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">dereferenced expression is @Nullable
</code></pre></div>
<p>而此类错误就是很多Bugly上空指针异常的罪魁祸首，需重点排查。</p>

<p>实际上Nullaway可以检查很多情况的问题，Nullaway的文档显示有诸如以下致空的情况：</p>

<ul>
<li>dereferenced expression is @Nullable</li>
<li>returning @Nullable expression from method with @NonNull return type</li>
<li>passing @Nullable parameter where @NonNull is required</li>
<li>assigning @Nullable expression to @NonNull field</li>
<li>method returns @Nullable, but superclass method returns @NonNull</li>
<li>referenced method returns @Nullable, but functional interface method returns @NonNull</li>
<li>parameter is @NonNull, but parameter in superclass method is @Nullable</li>
<li>parameter is @NonNull, but parameter in functional interface method is @Nullable</li>
<li>unbound instance method reference cannot be used, as first parameter of functional interface method is @Nullable</li>
<li>initializer method does not guarantee @NonNull field is initialized / @NonNull field not initialized</li>
<li>read of @NonNull field before initialization</li>
</ul>

<p>现在公司的工程只开启了两个module作为试点，如果能有好的防空效果，会逐步应用到整个工程。目前的主要防空措施就是这些，当然在调研的过程中也引入了一个类似findbugs的工具SpotBug，此插件也已集成好，只要通过一个简单的命令即可开始一次检查</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">./gradlew check
</code></pre></div>
<p>检查的结果可以通过输出的本地html文件查看</p>

<p>用了这么多工具，又是插件，又是检查器，又是注解，说以前道一万，这些都是辅助措施，要真正减少空指针，降低崩溃率，还是要通过编写高质量的代码来实现，上面提到的那个代码片段，实在不能容忍，肯定要喷，必须要改，共勉！</p>

	  ]]></description>
	</item>

	<item>
	  <title>在WebView中支持视频全屏</title>
	  <link>//h5-video-fullscreen-in-webview</link>
	  <author>Tao He</author>
	  <pubDate>2019-07-11T04:20:12+08:00</pubDate>
	  <guid>//h5-video-fullscreen-in-webview</guid>
	  <description><![CDATA[
	     <p>最近感觉和WebView杠上了，刚解决完在WebView中使用Android相机拍照和录像的问题，又遇到在WebView中视频无法全屏，和之前相机拍照和视频的问题一样，iOS和其他浏览器都没有问题，独WebView出错。通过网上查阅一些资料，最终顺利解决，虽不是什么难搞的东西，但是真要弄起来，也需要一些心力，所以通过此篇记录下整个过程。</p>

<p>解决整个问题其实很程式化，先按部就班保证视频能够正常播放:</p>

<ol>
<li>在AndroidManifest.xml中声明hardwareAccelerate属性</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text"> &lt;application android:hardwareAccelerated =&quot;true&quot;&gt;
</code></pre></div>
<ol>
<li>在Activity中声明</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;activity android:hardwareAccelerated=&quot;true&quot; &gt;
</code></pre></div>
<ol>
<li>在代码中设置</li>
</ol>
<div class="highlight"><pre><code class="language-text" data-lang="text">getWindow.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
</code></pre></div>
<p>然后来实现全屏, 而能够全屏的关键在于重写WebChromeClient的onShowCustomView()和onHideCustomView()方法, 在Activity中实现自定义的WebChromeClient，在onShowCustomView中横屏，隐藏WebView,并将得到的View添加到FrameLayout中显示。在onHideCustomView中隐藏View，显示WebView，并竖屏.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">private View mCustomView;
private WebChromeClient.CustomViewCallback mCustomViewCallback;

@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    if (mCustomView != null) {
        callback.onCustomViewHidden();
        return;
    }
    mCustomView = view;
    webViewContainer.addView(mCustomView);
    mCustomViewCallback = callback;
    mWebView.setVisibility(View.GONE);
    mTitle.setVisibility(View.GONE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
}

@Override
public void onHideCustomView() {
    mWebView.setVisibility(View.VISIBLE);
    mTitle.setVisibility(View.VISIBLE);
    if (mCustomView == null) {
        return;
    }
    mCustomView.setVisibility(View.GONE);
    webViewContainer.removeView(mCustomView);
    mCustomViewCallback.onCustomViewHidden();
    mCustomView = null;
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
}
</code></pre></div>
<p>代码中mCustomView和 mCustomViewCallback 需要保存下来，WebView的父容器在实现中也很重要。</p>

<p>需要注意的问题</p>

<p>如果H5工程师在html中使用了iframe, 那需要H5工程师配合在其中中加入一些属性才能对视频进行操作，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">allowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot;
</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>解决SharedPreferences导致的ANR</title>
	  <link>//fix-anr-related-sharedpreferences</link>
	  <author>Tao He</author>
	  <pubDate>2019-07-10T04:20:12+08:00</pubDate>
	  <guid>//fix-anr-related-sharedpreferences</guid>
	  <description><![CDATA[
	     <p>这几天在Google Play的ANR实时报告中看到很多貌似与SharedPreferences相关的ANR，看了历史版本后发现，这个已经是一个老问题了，在历次版班的ANR中居高不下。今天实在忍不了，决定对这个问题一探究竟。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"> at java.lang.Object.wait! (Native method)
- waiting on &lt;0x0a351954&gt; (a java.lang.Object)
  at java.lang.Thread.parkFor$ (Thread.java:1220)
- locked &lt;0x0a351954&gt; (a java.lang.Object)
  at sun.misc.Unsafe.park (Unsafe.java:299)
  at java.util.concurrent.locks.LockSupport.park (LockSupport.java:158)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt (AbstractQueuedSynchronizer.java:810)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly (AbstractQueuedSynchronizer.java:970)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly (AbstractQueuedSynchronizer.java:1278)
  at java.util.concurrent.CountDownLatch.await (CountDownLatch.java:203)
  at android.app.SharedPreferencesImpl$EditorImpl$1.run (SharedPreferencesImpl.java:366)
  at android.app.QueuedWork.waitToFinish (QueuedWork.java:88)
  at android.app.ActivityThread.handleServiceArgs (ActivityThread.java:3029)
  at android.app.ActivityThread.access$2200 (ActivityThread.java:155)
  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1450)
  at android.os.Handler.dispatchMessage (Handler.java:102)
  at android.os.Looper.loop (Looper.java:175)
  at android.app.ActivityThread.main (ActivityThread.java:5430)
  at java.lang.reflect.Method.invoke! (Native method)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:726)
  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:616)
</code></pre></div>
<p>这事Google Play提供的堆栈信息，信息非常有限，但是还是能观察到SharedPreferences的身影的，这个 <code>waitToFinish</code> 非常可疑，追踪到代码:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&#39;s onPause(), after
 * BroadcastReceiver&#39;s onReceive, after Service command handling,
 * etc. (so async work is never lost)
 */
public static void waitToFinish() {
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) {
        toFinish.run();
    }
}
</code></pre></div>
<p>这个方法的注释已经很清楚了，如果我们使用SharedPreference的apply方法, 虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity, BroadcastReceiver和Service的一些回调方法被调用时，会等待写入到文件系统的任务完成，如果写入比较慢，主线程就会出现ANR问题。</p>

<p>另外，SharedPreference除了提供apply外还提供commit方法，源码如下所示，该方法直接在调用线程中执行，不会转入后台，但如果我们在UI线程commit，且磁盘写入较慢的情况下，ANR依然会发生。行文至此，问题应该描述的比较清楚了，可以理解为SharedPreferences的机制导致系统组件回调过程中的阻塞，触发了ANR。可以将这个问题视为Android一个bug，也可以将问题归咎于为使用SharedPreferences不当(在SharedPreferences里读写数据量太大), 但是问题终究要解决，所以下面提出解决方案，并且记录下解决过程中的实践经验。</p>

<ul>
<li>方案一</li>
</ul>

<p>考虑启动一个线程commit，不使用apply</p>

<ul>
<li>方案二</li>
</ul>

<p>Hook ActivityThread，拿到Handler变量，在调用QueuedWork.waitToFinish()之前，将其中保存的队列清空，防止ANR的发生</p>

<ul>
<li>方案三</li>
</ul>

<p>使用MMKV替代SharedPrferences</p>

<p>最后我们选用了第三种方案，对于我们现有的代码改动量最小。第一种方案可行，但是也有问题，会有线程同步，仍然需要管理其他线程，保证读写的一致性。第二种方案不好验证它的副作用，因此也没有采纳。</p>

<p>选用MMKV后也有一个问题需要解决，那就是数据迁移，因为不可能针对之前所有使用SharedPreferences的地方逐一进行迁移，因此写了一个MMKV的封装类来统一对外提供数据迁移和读写的接口，可以实现对现已代码最小改动的情况下完成替换和迁移。封装类如下:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public class SharedPreferencesStore {
    public static final String TAG = SharedPreferencesStore.class.getSimpleName();

    private MMKV mMMKV;

    private SharedPreferencesStore(MMKV mmkv) {
        mMMKV = mmkv;
    }

    // 初始化，必须在使用前调用
    public static void initialize(Context context) {
        String rootDir = MMKV.initialize(context);
        ApplicationDelegate.log(TAG + &quot; MMKV root directory=&quot; + rootDir);
    }

    // 获取全局SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobal() {
        MMKV mmkv = MMKV.defaultMMKV();
        return new SharedPreferencesStore(mmkv);
    }

    // 获取全局SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobalWithMigration(Context context) {
        MMKV mmkv = MMKV.defaultMMKV();
        importFromDefaultSharePreferences(mmkv, context);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        importFromSharePreferences(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        importFromSharePreferencesMultiProcess(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    public void put(final String key, boolean value) {
        mMMKV.encode(key, value);
    }

    public boolean getBoolean(final String key, boolean defValue) {
        return mMMKV.decodeBool(key, defValue);
    }

    public void put(final String key, int value) {
        mMMKV.encode(key, value);
    }

    public int getInt(final String key, int defValue) {
        return mMMKV.decodeInt(key, defValue);
    }

    public void put(final String key, long value) {
        mMMKV.encode(key, value);
    }

    public long getLong(final String key, long defValue) {
        return mMMKV.decodeLong(key, defValue);
    }

    public void put(final String key, float value) {
        mMMKV.encode(key, value);
    }

    public float getFloat(final String key, float defValue) {
        return mMMKV.decodeFloat(key, defValue);
    }

    public void put(final String key, double value) {
        mMMKV.encode(key, value);
    }

    public double getDouble(final String key, double defValue) {
        return mMMKV.decodeDouble(key, defValue);
    }

    public void put(final String key, final String value) {
        mMMKV.encode(key, value);
    }

    public String getString(final String key, final String defValue) {
        return mMMKV.decodeString(key, defValue);
    }

    public void put(final String key, final byte[] value) {
        mMMKV.encode(key, value);
    }

    public byte[] getBytes(final String key) {
        return mMMKV.decodeBytes(key);
    }

    public Map&lt;String, ?&gt; getAll() {
        return mMMKV.getAll();
    }

    public void remove(final String key) {
        mMMKV.remove(key);
    }

    public void removeForKey(final String key) {
        mMMKV.removeValueForKey(key);
    }

    public void removeForKeys(final String[] keys) {
        mMMKV.removeValuesForKeys(keys);
    }

    public boolean contains(final String key) {
        return mMMKV.contains(key);
    }

    public boolean containsKey(final String key) {
        return mMMKV.containsKey(key);
    }

    public SharedPreferences.Editor edit() {
        return mMMKV.edit();
    }

    public static void importFromSharePreferences(MMKV mmkv, final Context context, final String name) {
        if (null == context) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_PRIVATE);
        doImport(mmkv, sp, name);
    }

    public static void importFromSharePreferencesMultiProcess(MMKV mmkv, final Context context, final String name) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_MULTI_PROCESS);
        doImport(mmkv, sp, name);
    }

    public static void importFromDefaultSharePreferences(MMKV mmkv, final Context context) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
        doImport(mmkv, sp, context.getPackageName() + &quot;_preferences&quot;);
    }

    private static void doImport(MMKV mmkv, SharedPreferences sp, final String name) {
        ApplicationDelegate.log(TAG + &quot; ------&quot; + name + &quot;-----SharedPreferences迁移开始-----------&quot;);
        if (sp.getAll() == null || sp.getAll().size() == 0) {
            ApplicationDelegate.log(TAG + &quot; &quot; + name + &quot; SharedPreferences 为空，不需要迁移&quot;);
            return;
        }

        int oldSize = sp.getAll().size();
        ApplicationDelegate.log(TAG + &quot; old size: &quot; + oldSize);

        Map&lt;String, ?&gt; map = sp.getAll();

        Map&lt;String, String&gt; keyTypes = new HashMap&lt;&gt;();

        ApplicationDelegate.log(TAG + &quot; ---old data: &quot;);
        for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) {
            Object obj = entry.getValue();
            if (obj instanceof Boolean) {
                keyTypes.put(entry.getKey(), &quot;Boolean&quot;);
            } else if (obj instanceof Integer) {
                keyTypes.put(entry.getKey(), &quot;Integer&quot;);
            } else if (obj instanceof Long) {
                keyTypes.put(entry.getKey(), &quot;Long&quot;);
            } else if (obj instanceof Float) {
                keyTypes.put(entry.getKey(), &quot;Float&quot;);
            } else if (obj instanceof Double) {
                keyTypes.put(entry.getKey(), &quot;Double&quot;);
            } else if (obj instanceof String) {
                keyTypes.put(entry.getKey(), &quot;String&quot;);
            }
            ApplicationDelegate.log(TAG + &quot; key: &quot; + entry.getKey() + &quot; value: &quot; + entry.getValue());
        }


        int imported = mmkv.importFromSharedPreferences(sp);
        ApplicationDelegate.log(TAG + &quot; imported size: &quot; + imported);

        if (BuildConfig.DEBUG) {
            ApplicationDelegate.log(TAG +  &quot; ---imported data: &quot;);

            String[] keys = mmkv.allKeys();
            for (int i = 0; i &lt; keys.length; i++) {

                String type = keyTypes.get(keys[i]);
                if (type == null) {
                    continue;
                }

                switch (type) {
                    case &quot;Boolean&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeBool(keys[i]));
                        break;
                    case &quot;Integer&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeInt(keys[i]));
                        break;
                    case &quot;Long&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeLong(keys[i]));
                        break;
                    case &quot;Float&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeFloat(keys[i]));
                        break;
                    case &quot;Double&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeDouble(keys[i]));
                        break;
                    case &quot;String&quot;:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: &quot; + mmkv.decodeString(keys[i]));
                        break;
                    default:
                        ApplicationDelegate.log(TAG + &quot; key: &quot; + keys[i] + &quot; value: unknown type&quot;);
                        break;
                }
            }
        }


        if (imported &gt; 0 &amp;&amp; oldSize == imported) {
            sp.edit().clear().apply();
        }

        if (oldSize != imported) {
            ApplicationDelegate.log(TAG + &quot; SharedPreferences 迁移失败, name=&quot; + name);
            ApplicationDelegate.bugTrace(ApplicationDelegate.MAIN_CODE_MMKV_IMPORT_FAIL, 0,
                    &quot;name=&quot; + name + &quot;, old size=&quot; + oldSize + &quot;, import size=&quot; + imported);
        }
        ApplicationDelegate.log(TAG +  &quot; ------&quot; + name + &quot;-----SharedPreferences迁移结束-----------&quot;);
    }
}
</code></pre></div>
<p>这次替换和迁移目前已经上线验证 ，目前只发现在API 19的机器上出现崩溃，报java.lang.UnsatisfiedLinkError，MMKV的官网上有次问题的解答，可以参考解决。</p>

	  ]]></description>
	</item>

	<item>
	  <title>在WebView中调用Android相机拍照录像</title>
	  <link>//operate-camera-in-webview</link>
	  <author>Tao He</author>
	  <pubDate>2019-06-29T04:20:12+08:00</pubDate>
	  <guid>//operate-camera-in-webview</guid>
	  <description><![CDATA[
	     <p>最近公司App需要以H5的方式接入七鱼客服，根据他们的开发文档接入起来还是很容易，成本很低。理论上如果以native的方式接入的话，用户体验会更好，但是接入后增加的包体积是无法接受的，遂改用H5的方式，整个接入过程还算顺利，有相对详尽的接入文档和demo，只是在最后接入完成后，因为沟通不畅，忽略了客服聊天界面在Android上无法发图片和发视频的问题。同一份html，iOS就是正常的，Android上就死活没反应。后来才恍然大悟，WebView是不支持JS去直接操作Android相机的，必须通过回调到native，由native完成照片的选择，拍摄和录像后将数据返回给JS才能完成一次照片和视频的发送。清楚了问题所在，就需要实现WebView的标准接口来实现这个回调到native的功能，在代码实现前，需要先厘清一些WebView的基本概念和原理。</p>

<p>像发送图片和视频这样的操作，涉及到了定制WebView的一些默认行为，理论上如果要做定制，就需要了解WebSettings、JavaScriptInterface、WebViewClient以及WebChromeClient，一般而言，通过配置WebSettings，使用JavasScriptInterface，重写WebViewClient和WebChromeClient对象的相关方法，就可以实现一些我们想要的行为。发图片和发视频就是通过重写WebChromeClient对象的几个方法来实现的。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">// 重写WebChromeClient的特定方法来实现图片和视频的发送
mWebView.setWebChromeClient(new WebChromeClient() {
    // For Android &gt;=3.0
    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) {
        if(acceptType.equals(&quot;image/*&quot;)) {
            if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(null);
                return;
            }
            mUploadMessage = uploadMsg;
            selectImage();
        } else {
            onReceiveValue();
        }
    }

    // For Android &lt; 3.0
    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) {
        openFileChooser(uploadMsg, &quot;image/*&quot;);
    }

    // For Android  &gt;= 4.1.1
    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) {
        openFileChooser(uploadMsg, acceptType);
    }

    // For Android  &gt;= 5.0
    @Override
    @SuppressLint(&quot;NewApi&quot;)
    public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) {
        if (fileChooserParams != null &amp;&amp; fileChooserParams.getAcceptTypes() != null
                &amp;&amp; fileChooserParams.getAcceptTypes().length &gt; 0 &amp;&amp; fileChooserParams.getAcceptTypes()[0].equals(&quot;image/*&quot;)) {
            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            selectImage();
        } else if (fileChooserParams != null &amp;&amp; fileChooserParams.getAcceptTypes() != null
                &amp;&amp; fileChooserParams.getAcceptTypes().length &gt; 0 &amp;&amp; fileChooserParams.getAcceptTypes()[0].equals(&quot;video/*&quot;)){

            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            PermissionUtil.requestPermission(QiyuWebViewActivity.this, PermissionUtil.PERMISSIONS_CAMERA_RECORD_AUDIO, PermissionUtil.REQUEST_CAMERA_RECORD_AUDIO);
        } else {
            onReceiveValue();
        }
        return true;
    }
});
</code></pre></div>
<p>需要注意的是，这几个回调方法，需要针对不同Android版本分别做处理，在onShowFileChooser方法中需要区分是图片还是视频，并且无论是在相册中选取还是拍摄照片，录像都需要申请相应的权限，这个一定不能少，网上很多的demo都是没有权限申请环节的，代码根本不可用。</p>

<p>在正确的回调到onShowFileChooser后，就要区分图片和视频的情况下走正常的选取，拍照，录像的流程，并且把获取到的图片，视频数据回传给JS调用，这样就完成了桥接调用。虽然现在看起来挺简单的，但是还是有些点容易成为坑点，让人走很多弯路:</p>

<ul>
<li>需要的配置一定要设定</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">mWebView.getSettings().setJavaScriptEnabled(true);
mWebView.getSettings().setDomStorageEnabled(true);
</code></pre></div>
<ul>
<li><p>动态权限申请一定不能少</p></li>
<li><p>正确区分图片和视频</p></li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">// &quot;video/* 为视频&quot;
fileChooserParams.getAcceptTypes()[0].equals(&quot;image/*&quot;)
</code></pre></div>
<p>总结一下，在WebView的JS调用系统相机的关键是重写WebChromeClient的特定方法来实现的。</p>

	  ]]></description>
	</item>


</channel>
</rss>
