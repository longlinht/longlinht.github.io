<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>http://longlinht.github.io/</link>
   <description>World is complex,confusing and wonderful,I will talk about machine,human and god to known it, to reveal it.</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Java References</title>
	  <link>//java-references</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-10T00:00:00+08:00</pubDate>
	  <guid>//java-references</guid>
	  <description><![CDATA[
	     <p>Before JDK 1.2, if a object isn&#39;t referenced by any variable, it can&#39;t be used any more.Since JDK 1.2, Java has four reference types.In order from strongest to weakest these references are: Strong, Soft, Weak, Phantom. </p>

<h4>Strong reference</h4>

<p>Below code is regular object reference:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Sample</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Sample</span><span class="o">();</span>
</code></pre></div>
<p>The variable <code>sample</code> holds a strong reference to a Sample object. Before you stop reading there is a point to this: objects that are reachable through any chain of strong references are not eligible for garbage collection. Even JVM throw <code>OutOfMemoryError</code> to terminate the program, it will not to reclaim the memory that strong reference hold.</p>

<h4>Soft reference</h4>

<p>Soft references are cleared at the discretion of the garbage collector in response to memory demand. The virtual machine guarantees that all soft references to softly-reachable objects will have been cleared before it would ever throw an <code>OutOfMemoryError</code>.</p>

<h4>Weak reference</h4>

<p>This code snippets is regular weak reference:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Cacheable</span><span class="o">&gt;</span> <span class="n">weakData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Cacheable</span><span class="o">&gt;(</span><span class="n">data</span><span class="o">);</span>
</code></pre></div>
<p>To access data call weakData.get(). This call to get may return <code>null</code> if the weak reference was garbage collected: you must check the returned value to avoid <code>NullPointerException</code>s.</p>

<p>An object that is identified as only weakly reachable will be collected at the next GC cycle.</p>

<p>If you pass a <code>ReferenceQueue</code> into the constructor for a weak reference then the garbage collector will append that weak reference to the <code>ReferenceQueue</code> when it is no longer needed. You can periodically process this queue and deal with dead references.</p>

<p>The difference between <code>SoftReference</code> and <code>WeakReference</code> is:</p>

<ul>
<li><p>A soft reference is exactly like a weak reference, except that it is less eager to throw away the object to which it refers. </p></li>
<li><p>An object which is only weakly reachable (the strongest references to it are WeakReferences) will be discarded at the next garbage collection cycle, but an object which is softly reachable will generally stick around for a while.</p></li>
<li><p><code>SoftReferences</code> aren&#39;t required to behave any differently than <code>WeakReferences</code>, but in practice softly reachable objects are generally retained as long as memory is in plentiful supply. This makes them an excellent foundation for a cache, such as the image cache described above, since you can let the garbage collector worry about both how reachable the objects are (a strongly reachable object will never be removed from the cache) and how badly it needs the memory they are consuming.</p></li>
<li><p>Garbage collector uses algorithms to decide whether or not to reclaim a softly reachable object, but always reclaims a weakly reachable object.</p></li>
</ul>

<h4>Phantom reference</h4>

<p>Phantom references are the most tenuous of all reference types: calling get will always return null.
When you construct a phantom reference you must always pass in a <code>ReferenceQueue</code>. </p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ReferenceQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ReferenceQueue</span> <span class="o">();</span>
<span class="n">PhantomReference</span> <span class="n">pr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PhantomReference</span> <span class="o">(</span><span class="n">object</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</code></pre></div>
<p>This indicates that you can use a phantom reference to see when your object is GC’d. The phantom reference is enqueued after it has been physically removed from memory — as opposed to weak references which are enqueued before they’re finalized or GC’d.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Android Thread Related Stuff</title>
	  <link>//thread-looper-handler-in-android</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-06T03:00:00+08:00</pubDate>
	  <guid>//thread-looper-handler-in-android</guid>
	  <description><![CDATA[
	     <p>It&#39;s widely known that it&#39;s illegal to update UI components directly from threads other than main thread in android. This a rule in Android world, we can&#39;t violate it. But, so many situations we need 
update UI when we finish something in separated thread. This is a basic problem, it will refer more important concepts related thread.</p>

<h4><code>Looper</code></h4>

<ul>
<li><p>Class used to run a message loop for a thread.</p></li>
<li><p>The <code>Looper</code> class maintains a synchronized <code>MessageQueue</code>, which contains a list messages.It reads and processes items from a <code>MessageQueue</code>.</p></li>
<li><p>Threads by default do not have a message loop associated with them, to create one, call <code>prepare()</code> in the thread that is to run the loop, and then <code>loop()</code> to have it process messages until the loop is stopped.</p></li>
<li><p>It&#39;s associated with the thread within which the <code>Looper</code> is created. This association is kept forever and can&#39;t be broken nor changed. Also note that a thread can&#39;t be associated with more than one Looper. </p></li>
<li><p>The <code>Looper</code> class is usually used in conjunction with a <code>HandlerThread</code> (a subclass of Thread).</p></li>
<li><p>There are 2 methods to terminate a Looper:</p>

<ul>
<li>Looper.quit()</li>
<li>Looper.quitSafely() </li>
</ul></li>
<li><p>Most interaction with a message loop is through the <code>Handler</code> class.</p></li>
</ul>

<h4><code>Handler</code></h4>

<ul>
<li><p>Allow you send and process <code>Message</code> and <code>Runnable</code> objects associated with a thread&#39;s <code>MessageQueue</code>. </p></li>
<li><p>Each <code>Handler</code> instance is associated with a single thread and that thread&#39;s message queue. Multiple Handler instances can be bound to the same thread.</p></li>
<li><p>It is bound to the thread / message queue of the thread that is creating it.</p></li>
<li><p>There are two main uses for a Handler: </p>

<ul>
<li>To schedule messages and runnables to be executed as some point in the future. </li>
<li>To enqueue an action to be performed on a different thread than your own.</li>
</ul></li>
</ul>

<h4><code>Message</code></h4>

<ul>
<li><p>Defines a message containing a description and arbitrary data object that can be sent to a Handler. This object contains two extra int fields and an extra object field that allow you to not do allocations in many cases.</p></li>
<li><p>While the constructor of Message is public, the best way to get one of these is to call <code>Message.obtain()</code> or one of the <code>Handler.obtainMessage()</code> methods, which will pull them from a pool of recycled objects.</p></li>
</ul>

<h4><code>HandlerThread</code></h4>

<ul>
<li><p><code>HandlerThread</code> is a handy class for starting a new thread that has a Looper.prepare(), Looper. </p></li>
<li><p>You generally need a thread attached with a Looper when you want sequential execution of tasks without race conditions and keep a thread alive even after a particular task is completed so that it can be reused so that you don’t have to create new thread instances.</p></li>
</ul>

<p>Once a HandlerThread is started, it sets up queuing through a Looper and MessageQueue and waits for incoming messages to process:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">HandlerThread</span> <span class="n">handlerThread</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">HandlerThread</span><span class="o">(</span><span class="s">&quot;HandlerThread&quot;</span><span class="o">);</span>
<span class="n">handlerThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

<span class="c1">// Create a handler attached to the HandlerThread&#39;s Looper</span>
<span class="n">mHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Handler</span><span class="o">(</span><span class="n">handlerThread</span><span class="o">.</span><span class="na">getLooper</span><span class="o">())</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Process messages here</span>
    <span class="o">}</span>
<span class="o">};</span>
 
<span class="c1">// Now send messages using mHandler.sendMessage()</span>
</code></pre></div>
	  ]]></description>
	</item>

	<item>
	  <title>Understanding Java Garbage Collection</title>
	  <link>//java-garbage-collection</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-05T00:00:00+08:00</pubDate>
	  <guid>//java-garbage-collection</guid>
	  <description><![CDATA[
	     <p><strong>stop-the-world</strong> Stop-the-world means that the JVM is stopping the application from running to execute a GC. When stop-the-world occurs, every thread except for the threads needed for the GC will stop their tasks. The interrupted tasks will resume only after the GC task has completed. GC tuning often means reducing this stop-the-world time.</p>

<h4>Generational Garbage Collection</h4>

<p>Java does not explicitly specify a memory and remove it in the program code.Maybe there is to way to remove the memory explicitly :</p>

<ul>
<li><p>Sets the relevant object to null</p></li>
<li><p>Use System.gc() method to remove the memory - will affect the system performance drastically</p></li>
</ul>

<p>But nobody do that. GC responsible to finds the unnecessary objects to remove them. GC created based on the following two preconditions:</p>

<ul>
<li><p>Most objects soon become unreachable.</p></li>
<li><p>References from old objects to young objects only exist in small numbers.</p></li>
</ul>

<h5>Young generation</h5>

<p>Most of the newly created objects are located here. Since most objects soon become unreachable, many objects are created in the young generation, then disappear. When objects disappear from this area, we say a &quot;minor GC&quot; has occurred.</p>

<h5>Old generation</h5>

<p>The objects that did not become unreachable and survived from the young generation are copied here. It is generally larger than the young generation. As it is bigger in size, the GC occurs less frequently than in the young generation. When objects disappear from the old generation, we say a &quot;major GC&quot; (or a &quot;full GC&quot;) has occurred.</p>

<h5>Permanent generation</h5>

<p>It stores classes or interned character strings. So, this area is definitely not for objects that survived from the old generation to stay permanently. A GC may occur in this area. The GC that took place here is still counted as a major GC.</p>

<h4>Composition of the Young Generation</h4>

<p>The young generation is divided into 3 spaces. </p>

<ul>
<li><p>One Eden space</p></li>
<li><p>Two Survivor spaces</p></li>
</ul>

<p>There are 3 spaces in total, two of which are Survivor spaces. The order of execution process of each space is as below:</p>

<ul>
<li><p>The majority of newly created objects are located in the Eden space.</p></li>
<li><p>After one GC in the Eden space, the surviving objects are moved to one of the Survivor spaces. </p></li>
<li><p>After a GC in the Eden space, the objects are piled up into the Survivor space, where other surviving objects already exist.</p></li>
<li><p>Once a Survivor space is full, surviving objects are moved to the other Survivor space. Then, the Survivor space that is full will be changed to a state where there is no data at all.</p></li>
<li><p>The objects that survived these steps that have been repeated a number of times are moved to the old generation.</p></li>
</ul>

<h5>GC for the Old Generation</h5>

<p>The old generation basically performs a GC when the data is full. The execution procedure varies by the GC type, so it would be easier to understand if you know different types of GC.
According to JDK 7, there are 5 GC types.</p>

<ul>
<li><p>Serial GC</p></li>
<li><p>Parallel GC</p></li>
<li><p>Parallel Old GC (Parallel Compacting GC)</p></li>
<li><p>Concurrent Mark &amp; Sweep GC (or &quot;CMS&quot;)</p></li>
<li><p>Garbage First (G1) GC</p></li>
</ul>

<p>This article will not introduce 5 GCs, if you interested in, please google it.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Android Binder Mechanism</title>
	  <link>//android-binder-mechanism</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-03T03:00:00+08:00</pubDate>
	  <guid>//android-binder-mechanism</guid>
	  <description><![CDATA[
	     <h4>What is Binder</h4>

<ul>
<li>The Binder mechanism has started from a simple idea. </li>
</ul>

<blockquote>
<p>&quot;Let requests and responses be written in an area where all processes can share and let each process refer to the memory address.&quot; </p>
</blockquote>

<ul>
<li><p>Binder is a IPC mechanism.</p></li>
<li><p>Binder implementation is based on <strong>OpenBinder</strong>.</p></li>
<li><p>Binder refers to a kernel memory which is shared between all processes to minimize the overhead caused by memory copy. </p></li>
<li><p>It provides the Remote Procedure Call (RPC) framework written in C++ for high productivity.</p></li>
</ul>

<h4>Why need Binder</h4>

<ul>
<li><p>Android need IPC mechanism because of its loosely coupled component design. Every application in Android is comprised of some components ,like Activity or Service, they maybe in same process or not. If they are in different process, they need communicate each other.</p></li>
<li><p>All of the default system functions of Android are provided as the <strong>server process</strong> type. In other words, to use the functions such as <code>SurfaceFlinger</code> or <code>AudioFlinger</code>, a request should be made as a separate process that runs on the user mode. As all system services are provided as a <strong>server process</strong>, a mechanism to send requests and responses to other processes is necessary. In Android it is called the Binder. Android uses functions provided by other processes through Binder.</p></li>
<li><p>Android is based on Linux, Linux has a lot of IPC mechanism. But, Android didn&#39;t adopted it. Maybe because of performance and low memory of Android device.</p></li>
</ul>

<h4>The Benefits of Using Binder Mechanism</h4>

<ul>
<li><p>Easy to expand or remove functions: It is easy to add a new system service or remove an existing function.</p></li>
<li><p>Easy to port: Porting to a new processor requires few changes. A toolchain for porting is provided.</p></li>
<li><p>Easy to test: Tests are limited by the component unit, so it is not necessary to test the entire services, and more strict tests are available.</p></li>
<li><p>Support for distribution system: Process communication is based on the Binder, so it guarantees transparency in location between components.</p></li>
</ul>

<h4>Binder Driver</h4>

<p>A Binder Driver is implemented to use the kernel space. The role of the Binder driver is to convert the memory address that each process has mapped with the memory address of the kernel space for reference.</p>

<h4>Understanding Binder Mechanism through Media Service</h4>

<h5><code>ServiceManager</code></h5>

<p>ServiceManager is a system manager which manages all services in Android.</p>

<h5>What is Media Service</h5>

<ul>
<li><p>Media Service is a general C++ application, is core of android media.</p></li>
<li><p>Media Service is a general service Android supplied.</p></li>
<li><p>Source code location: <em>frameworks/base/media/mediaserver/main_mediaserver.cpp</em></p></li>
<li><p>Entry point:</p></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Require a ServiceManager proxy</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">proc</span><span class="p">(</span><span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">());</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">defaultServiceManager</span><span class="p">();</span>
    <span class="n">LOGI</span><span class="p">(</span><span class="s">&quot;ServiceManager: %p&quot;</span><span class="p">,</span> <span class="n">sm</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="n">AudioFlinger</span><span class="o">::</span><span class="n">instantiate</span><span class="p">();</span>
    <span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">();</span>
    <span class="n">CameraService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">();</span>
    <span class="n">AudioPolicyService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">();</span>

    <span class="c1">// Forever process messages sent from Binder.</span>
    <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">startThreadPool</span><span class="p">();</span>
    <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">joinThreadPool</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p>Media server service has four sub-module.</p>

<ul>
<li><code>AudioFlinger</code></li>
<li><code>MediaPlayerService</code></li>
<li><code>CameraService</code></li>
<li><code>AudioPolicyService</code></li>
</ul></li>
</ul>

<h5><code>ProcessState</code></h5>

<ul>
<li><p>Source code location: <em>frameworks/base/libs/binder/ProcessState.cpp</em></p></li>
<li><p>Media Service first call <code>ProcessState::self()</code></p></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">sp</span><span class="o">&lt;</span><span class="n">ProcessState</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gProcess</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">gProcess</span><span class="p">;</span>

    <span class="n">AutoMutex</span> <span class="nf">_l</span><span class="p">(</span><span class="n">gProcessMutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">gProcess</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProcessState</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">gProcess</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Then <code>ProcessState::self()</code> call ProcessState constructor</li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">ProcessState</span><span class="o">::</span><span class="n">ProcessState</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">mDriverFD</span><span class="p">(</span><span class="n">open_driver</span><span class="p">())</span>
    <span class="p">,</span> <span class="n">mVMStart</span><span class="p">(</span><span class="n">MAP_FAILED</span><span class="p">)</span> <span class="c1">// Map the memory start address</span>
    <span class="p">,</span> <span class="n">mManagesContexts</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mBinderContextCheckFunc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mBinderContextUserData</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadPoolStarted</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mThreadPoolSeq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mDriverFD</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// XXX Ideally, there should be a specific define for whether we</span>
        <span class="c1">// have mmap (or whether we could possibly have the kernel module</span>
        <span class="c1">// availabla).</span>
<span class="cp">#if !defined(HAVE_WIN32_IPC)</span>
        <span class="c1">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span>
        <span class="n">mVMStart</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BINDER_VM_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_NORESERVE</span><span class="p">,</span> <span class="n">mDriverFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mVMStart</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// *sigh*</span>
            <span class="n">LOGE</span><span class="p">(</span><span class="s">&quot;Using /dev/binder failed: unable to mmap transaction memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">mDriverFD</span><span class="p">);</span>
            <span class="n">mDriverFD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#else</span>
        <span class="n">mDriverFD</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mDriverFD</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Need to run without the driver, starting our own thread pool.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p><code>open_driver()</code> function</p>

<ul>
<li>Very important function call to open a virtual device for communication.</li>
<li>This functon will open this device <strong>/dev/binder</strong>.</li>
</ul></li>
<li><p>When <code>ProcessState::self()</code> complete, it had do two important jobs:</p>

<ul>
<li>Open the virtual device <strong>/dev/binder</strong>, so there has been a channel to communicate with kernel.</li>
<li>Map <strong>/dev/binder</strong> device&#39;s fd to memory.<br></li>
</ul></li>
</ul>

<h5><code>defaultServiceManager()</code></h5>

<ul>
<li><p>Source code location: <em>frameworks/base/libs/binder/IServiceManager.cpp</em></p></li>
<li><p>Trace the source code call path, finally find that this call <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> equals <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code>.</p></li>
<li><p>BpBinder</p>

<ul>
<li>Source code location: <em>frameworks/base/libs/binder/BpBinder.cpp</em></li>
<li>BpBinder constructor:</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">BpBinder</span><span class="o">::</span><span class="n">BpBinder</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mAlive</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mObitsSent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">mObituaries</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LOGV</span><span class="p">(</span><span class="s">&quot;Creating BpBinder %p handle %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">mHandle</span><span class="p">);</span>

    <span class="n">extendObjectLifetime</span><span class="p">(</span><span class="n">OBJECT_LIFETIME_WEAK</span><span class="p">);</span>
    <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incWeakHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p>What did <code>interface_cast</code> do?</p>

<ul>
<li><code>interface_cast</code> defined in <em>/home/tao/android_source/frameworks/base/include/binder/IInterface.h</em></li>
<li><code>interface_cast</code> defination</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">INTERFACE</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">INTERFACE</span><span class="o">&gt;</span> <span class="n">interface_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">INTERFACE</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>So <code>gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement call <code>interface_cast</code> will equals:</li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kr">inline</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">interface_cast</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">IServiceManager</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p>We need find clue in <code>IServiceManager</code></p>

<ul>
<li>Source code location: <em>frameworks/base/include/binder/IInterface.h</em></li>
<li><code>IServiceManager</code> defination</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">IServiceManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IInterface</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DECLARE_META_INTERFACE</span><span class="p">(</span><span class="n">ServiceManager</span><span class="p">);</span>

    <span class="cm">/**</span>
<span class="cm">     * Retrieve an existing service, blocking for a few seconds</span>
<span class="cm">     * if it doesn&#39;t yet exist.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span>         <span class="n">getService</span><span class="p">(</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Retrieve an existing service, non-blocking.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span>         <span class="n">checkService</span><span class="p">(</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Register a service.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="kt">status_t</span>            <span class="n">addService</span><span class="p">(</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">service</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Return list of all existing services.</span>
<span class="cm">     */</span>
    <span class="k">virtual</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String16</span><span class="o">&gt;</span>    <span class="n">listServices</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">enum</span> <span class="p">{</span>
        <span class="n">GET_SERVICE_TRANSACTION</span> <span class="o">=</span> <span class="n">IBinder</span><span class="o">::</span><span class="n">FIRST_CALL_TRANSACTION</span><span class="p">,</span>
        <span class="n">CHECK_SERVICE_TRANSACTION</span><span class="p">,</span>
        <span class="n">ADD_SERVICE_TRANSACTION</span><span class="p">,</span>
        <span class="n">LIST_SERVICES_TRANSACTION</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">* We need trace this macro `DECLARE_META_INTERFACE(ServiceManager)` 
</code></pre></div><div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="cp">#define DECLARE_META_INTERFACE(INTERFACE)                             </span>
    <span class="k">static</span> <span class="k">const</span> <span class="n">String16</span> <span class="n">descriptor</span><span class="p">;</span>                                 
    <span class="k">static</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">&gt;</span> <span class="n">asInterface</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">);</span>      
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">getInterfaceDescriptor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>           
    <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="p">();</span>                                                   
    <span class="k">virtual</span> <span class="o">~</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="p">();</span>                                          


<span class="cp">#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                     </span>
    <span class="k">const</span> <span class="n">String16</span> <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">descriptor</span><span class="p">(</span><span class="n">NAME</span><span class="p">);</span>                    
    <span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">getInterfaceDescriptor</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>    
        <span class="k">return</span> <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">descriptor</span><span class="p">;</span>                              
    <span class="p">}</span>                                                                 
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">&gt;</span> <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">asInterface</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">{</span>                                                                 
        <span class="n">sp</span><span class="o">&lt;</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">&gt;</span> <span class="n">intr</span><span class="p">;</span>                                        
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>                                            
            <span class="n">intr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">*&gt;</span><span class="p">(</span>                        
                <span class="n">obj</span><span class="o">-&gt;</span><span class="n">queryLocalInterface</span><span class="p">(</span>                             
                        <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">descriptor</span><span class="p">).</span><span class="n">get</span><span class="p">());</span>             
            <span class="k">if</span> <span class="p">(</span><span class="n">intr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>                                       
                <span class="n">intr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bp</span><span class="err">##</span><span class="n">INTERFACE</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>                        
            <span class="p">}</span>                                                         
        <span class="p">}</span>                                                             
        <span class="k">return</span> <span class="n">intr</span><span class="p">;</span>                                                  
    <span class="p">}</span>                                                                 
    <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>                                  
    <span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="o">::~</span><span class="n">I</span><span class="err">##</span><span class="n">INTERFACE</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>                                 
</code></pre></div>
<ul>
<li>Finally, we find that <code>interface_cast&lt;IServiceManager&gt;(new BpBinder(0))</code> statement actually return a <code>BpServiceManager</code> object. It means <code>sp&lt;IServiceManager&gt; sm = defaultServiceManager()</code> acquired a <code>BpServiceManager</code> object.</li>
</ul>

<h5><code>BpServiceManager</code></h5>

<ul>
<li>Bp stands for Binder proxy, it means <code>BpServiceManager</code> is <code>ServiceManager</code>&#39;s proxy to Binder.</li>
</ul>

<h5><code>MediaPlayerService</code></h5>

<ul>
<li><p>Source code location: <em>frameworks/base/media/libmediaplayerservice/MediaPlayerService.cpp</em></p></li>
<li><p>Defination and instantiation </p></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">instantiate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">defaultServiceManager</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addService</span><span class="p">(</span>
            <span class="n">String16</span><span class="p">(</span><span class="s">&quot;media.player&quot;</span><span class="p">),</span> <span class="k">new</span> <span class="n">MediaPlayerService</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">MediaPlayerService</span><span class="o">::</span><span class="n">MediaPlayerService</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LOGV</span><span class="p">(</span><span class="s">&quot;MediaPlayerService created&quot;</span><span class="p">);</span>
    <span class="n">mNextConnId</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MediaPlayerService</span><span class="o">::~</span><span class="n">MediaPlayerService</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LOGV</span><span class="p">(</span><span class="s">&quot;MediaPlayerService destroyed&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p><code>MediaPlayerService</code> derivatived from <code>BnMediaPlayerService</code></p></li>
<li><p>Bn stands for Binder native.</p></li>
<li><p>Add <code>MediaPlayerService</code> to <code>ServiceManager</code></p></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="k">virtual</span> <span class="kt">status_t</span> <span class="nf">addService</span><span class="p">(</span><span class="k">const</span> <span class="n">String16</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="n">service</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Parcel</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">;</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeInterfaceToken</span><span class="p">(</span><span class="n">IServiceManager</span><span class="o">::</span><span class="n">getInterfaceDescriptor</span><span class="p">());</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeString16</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">data</span><span class="p">.</span><span class="n">writeStrongBinder</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
    <span class="c1">// remote() return BpBinder object</span>
    <span class="kt">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">remote</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span><span class="n">ADD_SERVICE_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reply</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span> <span class="o">?</span> <span class="n">reply</span><span class="p">.</span><span class="n">readInt32</span><span class="p">()</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><code>remote()</code> return BpBinder</li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">status_t</span> <span class="n">BpBinder</span><span class="o">::</span><span class="n">transact</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">code</span><span class="p">,</span> <span class="k">const</span> <span class="n">Parcel</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Once a binder has died, it will never come back to life.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mAlive</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">status_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span>
            <span class="n">mHandle</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DEAD_OBJECT</span><span class="p">)</span> <span class="n">mAlive</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">DEAD_OBJECT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><p><code>IPCThreadState</code> do with transaction, write add service command and wait for response.</p></li>
<li><p><code>BpServiceManager</code> had sent a add service message, but who receive and process it?</p></li>
<li><p><code>BnServiceManager</code>? unfortunately it doesn&#39;t exist. service do same job.</p></li>
<li><p>service</p>

<ul>
<li>service is a general c++ applcation.</li>
<li>Source code location: <em>frameworks/base/cmds/servicemanager/service_manager.c</em></li>
<li>Entry point:</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
    <span class="c1">//  BINDER_SERVICE_MANAGER is NULL, is a magic number</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">svcmgr</span> <span class="o">=</span> <span class="n">BINDER_SERVICE_MANAGER</span><span class="p">;</span>

    <span class="n">bs</span> <span class="o">=</span> <span class="n">binder_open</span><span class="p">(</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">binder_become_context_manager</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">LOGE</span><span class="p">(</span><span class="s">&quot;cannot become context manager (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">svcmgr_handle</span> <span class="o">=</span> <span class="n">svcmgr</span><span class="p">;</span>
    <span class="n">binder_loop</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">svcmgr_handler</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4>Conclusion</h4>

<p>Through tracing so many codes, the MediaPlayerService example maybe reveal the Binder&#39;s mysterious veil. We need write down some important conclusions:</p>

<ul>
<li><p>If two processes need communicate each other, one as Client, the other is Server, Server need registered to <code>ServiceManager</code>, if Client want request to Server, it need query Server&#39;s info from <code>ServiceManager</code>, based the qureid info, Client and Server can communicate each other. </p></li>
<li><p>Client, Server, <code>ServiceManager</code> are implemented in use space, Binder is implemented in kernel space.</p></li>
<li><p><code>ServiceManager</code> and Binder is implemented by Android, developers need implemente their Client and Server.</p></li>
<li><p>Binder supplied device file <strong>/dev/binder</strong> communicate to user space. Client, Server and <code>ServiceManager</code> communicated to Binder through <code>open</code> and <code>ioctl</code> file operation function.</p></li>
<li><p>Client and Server communicate each other immediately through Binder.</p></li>
<li><p><code>ServiceManager</code> is a daemon process, it manages Server, supply interface to qurey Server function.</p></li>
</ul>

<p>If want to learn Android IPC mechanism deeply, a lot of Android source code need be read. Linus said:</p>

<blockquote>
<p>Read The Fucking Source Code.</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Memory Leak in Android Development</title>
	  <link>//memory-leak-in-android-development</link>
	  <author>Tao He</author>
	  <pubDate>2016-08-01T22:00:00+08:00</pubDate>
	  <guid>//memory-leak-in-android-development</guid>
	  <description><![CDATA[
	     <p>When programming Android, although java has GC mechanism, some our wrong code way and personal habits still cause memory leak, GC also can&#39;t fix it.</p>

<h4>Senario 1: When programming a single instance</h4>

<ul>
<li>Error way:</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sample</span><span class="o">{</span>      
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Sample</span> <span class="n">sample</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Context</span> <span class="n">mContext</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="nf">Sample</span><span class="o">(</span><span class="n">Context</span> <span class="n">mContext</span><span class="o">){</span>
         <span class="k">this</span><span class="o">.</span><span class="na">mContext</span> <span class="o">=</span> <span class="n">mContext</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Sample</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">Context</span> <span class="n">mContext</span><span class="o">){</span>
         <span class="k">if</span><span class="o">(</span><span class="n">sample</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
              <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Sample</span><span class="o">(</span><span class="n">mContext</span><span class="o">);</span>
         <span class="k">return</span> <span class="n">sample</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">otherAction</span><span class="o">(){</span>
         <span class="n">mContext</span><span class="o">.</span><span class="na">act</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<ul>
<li>Error reason:</li>
</ul>

<p>If we use <code>Sample.getInstance()</code> in Acitivity A, pass <code>this</code> to Sample&#39;s <code>getInstatnce</code> static method, because Sample is static single instance, it exists untill application exit. But Sample&#39;s member variable still hold reference to Activity A, it causes Activity A can&#39;t be destroied. If we pass applicationContext, it doesn&#39;t cause this problem.</p>

<ul>
<li>Right way:</li>
</ul>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Sample</span><span class="o">{</span>
     <span class="kd">private</span> <span class="kd">static</span> <span class="n">Sample</span> <span class="n">sample</span><span class="o">;</span>
     <span class="kd">private</span> <span class="n">Context</span> <span class="n">mContext</span><span class="o">;</span>
     <span class="kd">private</span> <span class="nf">Sample</span><span class="o">(</span><span class="n">Context</span> <span class="n">mContext</span><span class="o">){</span>
          <span class="k">this</span><span class="o">.</span><span class="na">mContext</span> <span class="o">=</span> <span class="n">mContext</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kd">static</span> <span class="n">Sample</span> <span class="nf">getInstance</span><span class="o">(</span><span class="n">Context</span> <span class="n">mContext</span><span class="o">){</span>
          <span class="k">if</span><span class="o">(</span><span class="n">sample</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
               <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Sample</span><span class="o">(</span><span class="n">mContext</span><span class="o">.</span><span class="na">getApplicationContext</span><span class="o">());</span>
          <span class="k">return</span> <span class="n">sample</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">otherAction</span><span class="o">(){</span>
          <span class="n">mContext</span><span class="o">.</span><span class="na">act</span><span class="o">();</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>     </p>

<h4>Senario 2: When use anonymous inner class</h4>

<ul>
<li>Error way:
```java
public class SampleActivity extends Activity{
     private TextView textView;          
     private Handler handler = new Handler(){
          @override
          public void handlerMessage(Message msg){</li>
</ul>

<p>          }
     };</p>

<p>     @override
     public void onCreate(Bundle bundle){
          super.onCreate(bundle);
          setContextView(R.layout.activity<em>sample</em>layout);
          textView = (TextView)findViewById(R.id.textView);
          handler.postDelayed(new Runnable(){</p>

<p>               @override
               public void run(){
                    textView.setText(&quot;ok&quot;);
               };</p>

<p>          },1000 * 60 * 10);
     }
}
```</p>

<ul>
<li>Error reason:</li>
</ul>

<p>When execute the <code>SampleAcitvity</code>&#39;s <code>finish</code> method, the delayed messages will exist in main thread for 10 minutes before be processed, while this message contains reference to Handler, Handler is a anonymous inner class, it hold reference to external SampleAcivity, so cause SampleAcivity can&#39;t be recycled. Above <code>Runnable</code> also is a anonymous inner class, it also prevent SampleActivity to be recycled.</p>

<ul>
<li>Right way:</li>
</ul>

<p><strong>A static anonymous inner class instance will not hold reference to external class.</strong></p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span><span class="o">{</span>
     <span class="kd">private</span> <span class="n">TextView</span> <span class="n">textView</span><span class="o">;</span>
     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">extends</span> <span class="n">Handler</span> <span class="o">{</span>

     <span class="kd">private</span> <span class="kd">final</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SampleActivity</span><span class="o">&gt;</span> <span class="n">mActivity</span><span class="o">;</span>
     <span class="kd">public</span> <span class="nf">MyHandler</span><span class="o">(</span><span class="n">SampleActivity</span> <span class="n">activity</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">mActivity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">SampleActivity</span><span class="o">&gt;(</span><span class="n">activity</span><span class="o">);</span>
     <span class="o">}</span>

     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleMessage</span><span class="o">(</span><span class="n">Message</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">SampleActivity</span> <span class="n">activity</span> <span class="o">=</span> <span class="n">mActivity</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
               <span class="k">if</span> <span class="o">(</span><span class="n">activity</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

               <span class="o">}</span>
          <span class="o">}</span>
     <span class="o">}</span>

     <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MyHandler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

     <span class="nd">@override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">bundle</span><span class="o">){</span>
          <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">bundle</span><span class="o">);</span>
          <span class="n">setContextView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_sample_layout</span><span class="o">);</span>
          <span class="n">textView</span> <span class="o">=</span> <span class="o">(</span><span class="n">TextView</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">);</span>
          <span class="n">handler</span><span class="o">.</span><span class="na">postDelayed</span><span class="o">(</span><span class="k">new</span> <span class="nf">MyRunnable</span><span class="o">(</span><span class="n">textView</span><span class="o">),</span><span class="mi">1000</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">10</span><span class="o">);</span>
     <span class="o">}</span>

     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>

        <span class="c1">// use WeakReference to hold external class&#39;s member variables.</span>
        <span class="kd">private</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">TextView</span><span class="o">&gt;</span> <span class="n">textViewWeakReference</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">MyRunnable</span><span class="o">(</span><span class="n">TextView</span> <span class="n">textView</span><span class="o">){</span>
             <span class="n">textViewWeakReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">TextView</span><span class="o">&gt;(</span><span class="n">textView</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
              <span class="kd">final</span> <span class="n">TextView</span> <span class="n">textView</span> <span class="o">=</span> <span class="n">textViewWeakReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
              <span class="k">if</span><span class="o">(</span><span class="n">textView</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                   <span class="n">textView</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">&quot;OK&quot;</span><span class="o">);</span>
              <span class="o">}</span>

        <span class="o">};</span>
     <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4>Senario 3: Forgot call removeCallbacksAndMessages after use handler</h4>

<ul>
<li>Right way:</li>
</ul>

<p>In onDestroy call this method:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java">     <span class="n">handler</span><span class="o">.</span><span class="na">removeCallbacksAndMessages</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</code></pre></div>
<p>This call passed null will destroy all Runnable and Message related to handler.</p>

<h4>Conclude</h4>

<ul>
<li><p>Don&#39;t let object whose lifecycle longer then Acivity hold reference to Acivity.</p></li>
<li><p>Prefer to use Application&#39;s Context rather than Activity&#39;s Context.</p></li>
<li><p>Prefer to use static anonymous inner class rather than non-static.</p></li>
<li><p>Use weak reference to hold external class&#39;s member variables.</p></li>
<li><p>GC can&#39;t fix memory leak.</p></li>
</ul>

<h4>Reference</h4>

<blockquote>
<p>In Android, Handler classes should be static or leaks might occur, Messages enqueued on the application thread’s MessageQueue also retain their target Handler. If the Handler is an inner class, its outer class will be retained as well. To avoid leaking the outer class, declare the Handler as a static nested class with a WeakReference to its outer class</p>

<p>When an Android application first starts, the framework creates a Looper object for the application’s main thread. A Looper implements a simple message queue, processing Message objects in a loop one after another. All major application framework events (such as Activity lifecycle method calls, button clicks, etc.) are contained inside Message objects, which are added to the Looper’s message queue and are processed one-by-one. The main thread’s Looper exists throughout the application’s lifecycle.</p>

<p>When a Handler is instantiated on the main thread, it is associated with the Looper’s message queue. Messages posted to the message queue will hold a reference to the Handler so that the framework can call Handler#handleMessage(Message) when the Looper eventually processes the message.</p>

<p>In Java, non-static inner and anonymous classes hold an implicit reference to their outer class. Static inner classes, on the other hand, do not.</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Hello World</title>
	  <link>//hello-world</link>
	  <author>Tao He</author>
	  <pubDate>2016-06-09T00:00:00+08:00</pubDate>
	  <guid>//hello-world</guid>
	  <description><![CDATA[
	     <p>This is my first post for Machine category, I named it &#39;Hello World&#39; to start my blog. Because many developers start their first program with a single line code to print &#39;Hello World&#39;. Certainly my first line code also is &#39;Hello World&#39; in C programming language. I hope this will be a good start!</p>

<p>Before Starting this blog, I think about this expression way for a long time, I didin&#39;t know what I should write, I also can&#39;t sure I could write down some useful, excellent articles. I even worry about my articles would be some non-value pieces. But now, I never care about it. I will do my best to write some useful, valuable IT articles.</p>

<p>To make a good start, I need figure out what I shoud write. I think about some categories below:</p>

<ul>
<li><p>General IT</p></li>
<li><p>Programming Miscellaneous</p></li>
<li><p>Programming</p></li>
<li><p>Computer Science</p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Similarities and Differences between Java and C++</title>
	  <link>//similarities-and-differences-between-java-and-cpp</link>
	  <author>Tao He</author>
	  <pubDate>2012-01-15T22:00:00+08:00</pubDate>
	  <guid>//similarities-and-differences-between-java-and-cpp</guid>
	  <description><![CDATA[
	     <ul>
<li><p>Java does not support typedefs, defines, or a preprocessor. </p></li>
<li><p>Java does not support enums but does support named constants through use of the final keyword.</p></li>
<li><p>Java supports classes, but does not support structures or unions.</p></li>
<li><p>There are no stand-alone functions in Java, all function or method definitions in Java are contained within the class definition. </p></li>
<li><p>All classes in Java ultimately inherit from the Object class. This is significantly different from C++ where it is possible to create inheritance trees that are completely unrelated to one another.</p></li>
<li><p>Both C++ and Java support class (static) methods or functions that can be called without the requirement to instantiate an object of the class.</p></li>
<li><p>Java does not support multiple inheritance, while the interface concept is not supported by C++.</p></li>
<li><p>Java does not support the goto statement (but goto is a reserved word). However, it does support labeled break and continue statements, a feature not supported by C++. </p></li>
<li><p>Java does not support operator overloading.</p></li>
<li><p>Java does not support automatic type conversions (except where guaranteed safe).</p></li>
<li><p>Unlike C++, Java provides true arrays as first-class objects, true boolean type and has a String type.</p></li>
<li><p>Java does not support pointers(at least it does not allow you to modify the address contained in a pointer or to perform pointer arithmetic).</p></li>
<li><p>A class definition in Java looks similar to a class definition in C++, but there is no closing semicolon. Also forward reference declarations that are sometimes required in C++ are not required in Java.</p></li>
<li><p>The scope resolution operator (::) required in C++ is not used in Java. </p></li>
<li><p>In C++, static data members and functions are called using the name of the class and the name of the static member connected by the scope resolution operator. In Java, the dot is used for this purpose.</p></li>
<li><p>Like C++, Java has primitive types such as int, float, etc. Unlike C++, the size of each primitive type is the same regardless of the platform. There is no unsigned integer type in Java. Type checking and type requirements are much tighter in Java than in C++.</p></li>
<li><p>Conditional expressions in Java must evaluate to boolean rather than to integer, as is the case in C++.</p></li>
<li><p>The char type in C++ is an 8-bit type that maps to the ASCII (or extended ASCII) character set. The char type in Java is a 16-bit type and uses the Unicode character set </p></li>
<li><p>Unlike C++, the &gt;&gt; operator in Java is a &quot;signed&quot; right bit shift, inserting the sign bit into the vacated bit position. Java adds an operator that inserts zeros into the vacated bit positions.</p></li>
<li><p>C++ allows the instantiation of variables or objects of all types either at compile time in static memory or at run time using dynamic memory. However, Java requires all variables of primitive types to be instantiated at compile time, and requires all objects to be instantiated in dynamic memory at runtime. Wrapper classes are provided for all primitive types except byte and short to allow them to be instantiated as objects in dynamic memory at runtime if needed.</p></li>
<li><p>C++ requires that classes and functions be declared before they are used. This is not necessary in Java.</p></li>
<li><p>The &quot;namespace&quot; issues prevalent in C++ are handled in Java by including everything in a class, and collecting classes into packages.</p></li>
<li><p>In C++, unless you specifically initialize variables of primitive types, they will contain garbage. Although local variables of primitive types can be initialized in the declaration, primitive data members of a class cannot be initialized in the class definition in C++.</p></li>
<li><p>Like C++, Java supports constructors that may be overloaded. </p></li>
<li><p>All objects in Java are passed by reference, eliminating the need for the copy constructor used in C++.</p></li>
<li><p>There are no destructors in Java.</p></li>
<li><p>Like C++, Java allows you to overload functions. However, default arguments are not supported by Java.</p></li>
<li><p>Unlike C++, Java does not support templates. Thus, there are no generic functions or classes.</p></li>
<li><p>Unlike C++, several &quot;data structure&quot; classes are contained in the &quot;standard&quot; version of Java. </p></li>
<li><p>Multithreading is a standard feature of the Java language.</p></li>
<li><p>Although Java uses the same keywords as C++ for access control: private, public, and protected, the interpretation of these keywords is significantly different between Java and C++. </p></li>
<li><p>There is no virtual keyword in Java. All non-static methods always use dynamic binding, so the virtual keyword isn&#39;t needed for the same purpose that it is used in C++.</p></li>
<li><p>Java provides the final keyword that can be used to specify that a method cannot be overridden and that it can be statically bound. (The compiler may elect to make it inline in this case.)</p></li>
<li><p>The detailed implementation of the exception handling system in Java is significantly different from that in C++.</p></li>
<li><p>As in C++, Java applications can call functions written in another language.</p></li>
<li><p>Unlike C++, Java has built-in support for program documentation.</p></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>高质量C++编程注意事项</title>
	  <link>//high-quality-cpp</link>
	  <author>Tao He</author>
	  <pubDate>2011-02-05T22:00:00+08:00</pubDate>
	  <guid>//high-quality-cpp</guid>
	  <description><![CDATA[
	     <ul>
<li><p>不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明</p></li>
<li><p>变量的名字应当使用“名词”或者“形容词＋名词”</p></li>
<li><p>全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）</p></li>
<li><p>不可将布尔变量直接与TRUE、FALSE 或者1、0 进行比较</p></li>
<li><p>不可将浮点变量用“==”或“！=”与任何数字比较</p></li>
<li><p>在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨切循环层的次数</p></li>
<li><p>如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面</p></li>
<li><p>在C++ 程序中只使用const 常量而不使用宏常量，即const 常量完全取代宏常量</p></li>
<li><p>需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中</p></li>
<li><p>不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用return 语句返回</p></li>
<li><p>使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的</p></li>
<li><p>用free 或delete 释放了内存之后，立即将指针设置为NULL，防止产生“野指针”</p></li>
<li><p>当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针</p></li>
<li><p>对于32 位以上的应用程序而言，无论怎样使用malloc 与new，几乎不可能导致“内存耗尽”</p></li>
<li><p>成员函数被重载的特征：</p>

<ul>
<li>相同的范围（在同一个类中）；</li>
<li>函数名字相同</li>
<li>参数不同</li>
<li>virtual 关键字可有可无</li>
</ul></li>
<li><p>覆盖是指派生类函数覆盖基类函数，特征是：</p>

<ul>
<li>不同的范围（分别位于派生类与基类）</li>
<li>函数名字相同</li>
<li>参数相同</li>
<li>基类函数必须有virtual 关键字</li>
</ul></li>
<li><p>隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>

<ul>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</li>
</ul></li>
<li><p>在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱</p>

<ul>
<li>不能改变C++内部数据类型（如int,float 等）的运算符。</li>
<li>不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法</li>
<li>不能重载目前C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级</li>
<li>对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱</li>
</ul></li>
<li><p>“缺省的拷贝构造函数”和“缺省的赋值函数”均采用“位拷贝”而非“值拷贝”的方式来实现，倘若类中含有指针变量，这两个函数注定将出错</p></li>
<li><p>如果类存在继承关系，派生类必须在其初始化表里调用基类的构造函数</p></li>
<li><p>类的const 常量只能在初始化表里被初始化，因为它不能在函数体内用赋值的方式来初始化</p></li>
<li><p>成员对象初始化的次序完全不受它们在初始化表中次序的影响，只由成员对象在类中声明的次序决定</p></li>
<li><p>如果类A 和类B 毫不相关，不可以为了使B 的功能更多些而让B继承A 的功能和属性</p></li>
<li><p>若在逻辑上B 是A 的“一种”，并且A 的所有功能和属性对B 而言都有意义，则允许B 继承A 的功能和属性</p></li>
<li><p>若在逻辑上A 是B 的“一部分”（a part of），则不允许B 从A 派生，而是要用A 和其它东西组合出B</p></li>
<li><p>如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用</p></li>
<li><p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰</p></li>
<li><p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值</p></li>
<li><p>不要一味地追求程序的效率，应当在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率</p></li>
<li><p>以提高程序的全局效率为主，提高局部效率为辅</p></li>
<li><p>在优化程序的效率时，应当先找出限制效率的“瓶颈”，不要在无关紧要之处优化。</p></li>
<li><p>先优化数据结构和算法，再优化执行代码</p></li>
<li><p>有时候时间效率和空间效率可能对立，此时应当分析那个更重要，作出适当的折衷。例如多花费一些内存来提高性能。</p></li>
<li><p>不要追求紧凑的代码，因为紧凑的代码并不能产生高效的机器码。</p></li>
<li><p>当心那些视觉上不易分辨的操作符发生书写错误。我们经常会把“＝＝”误写成“＝”，象“||”、“&amp;&amp;”、“&lt;=”、“&gt;=”这类符号也很容易发生“丢1”失误。然而编器却不一定能自动指出这类错误。</p></li>
<li><p>变量（指针、数组）被创建之后应当及时把它们初始化，以防止把未被初始化的变量当成右值使用。</p></li>
<li><p>当心变量的初值、缺省值错误，或者精度不够。</p></li>
<li><p>当心数据类型转换发生错误。尽量使用显式的数据类型转换（让人们知道发生了什么事），避免让编译器轻悄悄地进行隐式的数据类型转换。</p></li>
<li><p>当心变量发生上溢或下溢，数组的下标越界。</p></li>
<li><p>当心忘记编写错误处理程序，当心错误处理程序本身有误。</p></li>
<li><p>当心文件I/O 有错误。</p></li>
<li><p>避免编写技巧性很高代码。</p></li>
<li><p>不要设计面面俱到、非常灵活的数据结构。</p></li>
<li><p>如果原有的代码质量比较好，尽量复用它。但是不要修补很差劲的代码，应当重新编写。</p></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
