<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>longlinht.github.io/</title>
   
   <link>https://longlinht.github.io/</link>
   <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
   <language>en-uk</language>
   <managingEditor> Tao He</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Userful EOR operations in algorithm design</title>
	  <link>//useful-eor-operation</link>
	  <author>Tao He</author>
	  <pubDate>2023-07-22T22:20:12+04:00</pubDate>
	  <guid>//useful-eor-operation</guid>
	  <description><![CDATA[
	     <p>The EOR is a short form of Exclusive OR, which is a logic operator and satisfies the commutative law and the associative law. It means:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 ^ N == N
N ^ N == 0

A ^ B == B ^ A
A ^ B ^ C == A ^ (B ^ C)

</code></pre></div></div>

<p>With these properties, EOR can be useful to efficiently solve some questions. Let us start with a simple one:</p>

<blockquote>
  <p>Given an integer array with only one integer appearing odd times and others appearing even times, print the odd-times one.</p>
</blockquote>

<p>At first glance, you could have several solutions to this question. But trust me, you might not have an elegant solution like the one below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void printOddTimesNumber1(int[] array) {
    int eor = 0;
    for(int i=0; i &lt; array.length; i++) {
        eor ^= array[i];
    }
    System.out.println(eor);
}

</code></pre></div></div>

<p>With just few lines of code, it’s done. It utilizes the basic properties of EOR pretty well. EOR operation on even-time numbers always 0 while only one odd-times number <code class="language-plaintext highlighter-rouge">^</code> 0 always itself.</p>

<p>One more difficult question:</p>

<blockquote>
  <p>Given an integer array with only two integers appearing odd times and others appearing event times, print the two odd-time numbers.</p>
</blockquote>

<p>We give the solution directly and explain the code later.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void printOddTimesNumber2(int[] array) {
    int eor = 0;
    for(int i=0; i &lt; array.length; i++) {
        eor ^= array[i];
    }
    
    int rightOne = eor &amp; (~eor + 1);
    onlyOne = 0;
    for(int i=0; i &lt; array.length; i++) {
        if(array[i] &amp; rightOne != 0) {
            onlyOne ^= array[i];
        }
    }
    
    int zeroOne = eor ^ onlyOne;
    System.out.println(onlyOne, eor ^ onlyOne);
}

</code></pre></div></div>

<p>The code seems complex, especially this segment <code class="language-plaintext highlighter-rouge">eor &amp; (~eor + 1)</code>. The expression gets an integer whose only bit is the same as the most right 1 bit of eor and the rest is 0.</p>

<p>Assume that these two numbers are A and B. The first part of the code was figured out: eor = A ^ B. We know A != B. So there must be a bit of A and B that is different. If the bit of A is 1 and the bit of B is 0, We need to figure out this bit. Then the complex expression above helped. Having the <code class="language-plaintext highlighter-rouge">rightOne</code>, we can iterate the array to find which number’s this bit is 1. After iteration, we get it as <code class="language-plaintext highlighter-rouge">onlyOne</code> which is A. Finally, we also get the <code class="language-plaintext highlighter-rouge">zeroOne</code> which is B.</p>


	  ]]></description>
	</item>

	<item>
	  <title>A practical way to make sure the correctness of your algorithm</title>
	  <link>//a-practical-way-for-algorithm-correctness</link>
	  <author>Tao He</author>
	  <pubDate>2023-07-20T22:20:12+04:00</pubDate>
	  <guid>//a-practical-way-for-algorithm-correctness</guid>
	  <description><![CDATA[
	     <p>As programmers, it really frustrates us when we cannot 100 percent make sure the functions or algorithms we have written can produce the results we expected. Although we have passed many test cases, we are still not confident enough to say these functions can work and output correct values in all cases. It is impossible for us to have a test case system like Leecode wherever and whenever. It is not realistic. So we need to figure out a way to test our algorithm ourselves. Fortunately, there is indeed one.</p>

<p>As a fact, this method is based on comparing an existing solution to verify a new one. It sounds simple, right? What are we waiting for? Let us implement it step by step.</p>

<ul>
  <li>Identify a function or algorithm you would like to test. For this example, it is a selection sort function we wrote.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void selectionSort(int[] arr) {
		if (arr == null || arr.length &lt; 2) {
			return;
		}
		for (int i = 0; i &lt; arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j &lt; arr.length; j++) { 
				minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

</code></pre></div></div>

<ul>
  <li>In order to compare, we need to implement a simple function, which also can sort the array using an existed and verified solutiion. In this case we using a Java API.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void comparator(int[] arr) {
    Arrays.sort(arr);
}

</code></pre></div></div>

<ul>
  <li>Implement a random sample generator.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static int[] generateRandomArray(int maxSize, int maxValue) {
    int[] arr = new int[(int) (Math.random() * maxSize) + 1];
    arr[0] = (int) (Math.random() * maxValue) - (int) (Math.random() * maxValue);
    for (int i = 1; i &lt; arr.length; i++) {
        do {
            arr[i] = (int) (Math.random() * maxValue) - (int) (Math.random() * maxValue);
        } while (arr[i] == arr[i - 1]);
    }
    return arr;
}
</code></pre></div></div>

<ul>
  <li>Write a function to compare output.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static boolean isEqual(int[] arr1, int[] arr2) {
    if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) {
        return false;
    }
    if (arr1 == null &amp;&amp; arr2 == null) {
        return true;
    }
    if (arr1.length != arr2.length) {
        return false;
    }
    for (int i = 0; i &lt; arr1.length; i++) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }
    return true;
}

</code></pre></div></div>

<ul>
  <li>Using various size of sample to test the function we wrote and compare to the existed solution.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void main(String[] args) {
    int testTime = 500000;
    int maxSize = 100;
    int maxValue = 100;
    boolean succeed = true;
    for (int i = 0; i &lt; testTime; i++) {
        int[] arr1 = generateRandomArray(maxSize, maxValue);
        int[] arr2 = copyArray(arr1);
        selectionSort(arr1);
        comparator(arr2);
        if (!isEqual(arr1, arr2)) {
            succeed = false;
            printArray(arr1);
            printArray(arr2);
            break;
        }
    }
    System.out.println(succeed ? "Nice!" : "Fucking fucked!");

    int[] arr = generateRandomArray(maxSize, maxValue);
    printArray(arr);
    selectionSort(arr);
    printArray(arr);
}

</code></pre></div></div>

<p>We can randomly set the test time and sample size to do loads of tests to make sure the function works and outputs correctly. If it can produce expected results after millions of tests. We can be sure of the correctness of this function. But if there is one time they are not equal, in other words, <code class="language-plaintext highlighter-rouge">selectionSort</code> produces outputs that are not equal, <code class="language-plaintext highlighter-rouge">comparator</code>. We have to say the new solution cannot be accepted; we should debug and test more to find the problem. As long as we use this sharp comparator more and more, we will have more confidence to write down more reliable algorithms.</p>

	  ]]></description>
	</item>

	<item>
	  <title>A quick tour of Spring Boot</title>
	  <link>//a-quick-tour-of-spring-boot</link>
	  <author>Tao He</author>
	  <pubDate>2023-07-12T22:20:12+04:00</pubDate>
	  <guid>//a-quick-tour-of-spring-boot</guid>
	  <description><![CDATA[
	     <p>As an Android developer currently, I have always dreamed of becoming a full-stack developer, so I started to learn Java backend programming. During the past two weeks, I have read one book and watched a series of tutorial videos on Spring Boot. So I am going to summarize what I have learned and write down my thoughts.</p>

<p>I have to admit that I had never heard of Spring Boot before I started learning it. After I effortlessly started up a simple project and ran it successfully following the steps the book describes, I have to say it is pretty easy to create and run an application. It just takes one or two minutes to start a runnable program without any extra effort. It just works.</p>

<p>So the first question is what such a powerful Spring Boot is. Actually, it is not a mysterious thing. You can treat it as an enhanced Spring, which simplifies the complicated configurations and makes dependency management unprecedentedly easy. Let us compare the differences between Spring and Spring Boot in configurations to experience the attractions of Spring Boot for developers.</p>

<p>for Spring applications:</p>

<ul>
  <li>We have to manually add dependency in pom.xml</li>
  <li>We have to manually program the Web3.0 configuration class.</li>
  <li>We have to manually write the Spring/Spring MVC configuration class.</li>
</ul>

<p>while for Spring Boot applications:</p>

<p>We only need to check a dependency to add it or manually add it, not manually write a configuration class anymore. Writing business controllers and designing data models become the only things we need to do. It significantly speeds up the process of development. No configurations, no worry about dependencies, especially dependency versions—it sounds amazing. We cannot stop asking, How did Spring Boot make it? The answer is that these configurations and dependencies are embedded into Spring Boot. The starter is the key point. Spring Boot has embedded most dependencies we need and organized every dependency with the most matched versions. For example, if we need Spring Web, we just add lines like below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;dependencies&gt;

...

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
...

&lt;dependencies&gt;
</code></pre></div></div>

<p>You may have noticed that the dependency didn’t specify the version and that the name of artifactId contains <code class="language-plaintext highlighter-rouge">starter</code>. The version is not necessary any more; Spring Boot helps us figure out all embedded dependencies with the proper version based on the Spring Boot version. This saves us much time and effort in finding the matched versions of dependencies. As an Android developer, I have to say that Android developers also need a framework like this, which can do the most dirty work for us.</p>

<p>Spring Boot also helps us avoid writing boilerplate code like the Spring MVC configuration class. I think it makes the most use of the annotation and the reflection of Java to implement. It is not uncommon to find that almost all production-grade frameworks written in Java use these Java features to fulfill complicated tasks.</p>

<p>Another obvious difference between Spring and Spring Boot in the work flow is that Spring Boot has embedded a Tomcat, so I do not need to configure one manually any more. When you are in the process of development, you even forget its existence. You just run and wait for the result.</p>

<p>Although Spring Boot has helped us get rid of annoying XML configurations, it still has configurations. Several styles of configuration files are supported. But the style of yaml is preferred.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring:
  thymeleaf:
    cache: false
</code></pre></div></div>
<p>Yaml differs from traditional property files, which consist of key=value lines. The reason for choosing yaml instead of property files is that property files cannot represent structured configuration well.</p>

<p>Before going to the most exciting part of Spring Boot, let us go on a whirlwind REST tour.
If we would like to locate a resource through a URI (path) and do different operations on it, we usually define different paths to complete different tasks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://localhost/user/saveUser
http://localhost/user/delete?id=1
http://localhost/user/updateUser
http://localhost/user/getById?id=1
http://localhost/user/getAll

</code></pre></div></div>
<p>While adopting REST style, we can do this more elegantly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://localhost/user/users
http://localhost/user/users/1
http://localhost/user/users
http://localhost/user/users/1
http://localhost/user/users

</code></pre></div></div>
<p>On first sight, it is hard to tell the difference among these paths. In fact, Spring Boot has provided us with several annotations to specify every action each path stands for. The first path with the GET action will make a request for all users, while the third path with the POST action will save a user. Concise and elegant, right? Next, we will step into the key part of Spring Boot that can show its power.</p>

<p>Spring Boot has been evolving quickly since it appeared. Until now, it has been seamlessly integrated with most mainstream third-party technologies like JUnit(for testing), MyBatis(for persistence), Druid(for data source), Simple(for cache). Actually, it supports most of them directly. Introducing them to your project becomes quick and effortless. I have tried to integrate several of them into my trivial project and found a general routine to complete the integration task. When you want to introduce a technology (library) for a specific purpose to your project, generally speaking, you should do these three steps:</p>

<ol>
  <li>Import the starter of this library.</li>
  <li>Turn on this library, which means letting Spring Boot know you want to use this library or technology.</li>
  <li>Using it in your business code.</li>
</ol>

<p>For example, if we want to introduce Simple for cache, we will follow these 3 steps:</p>

<p>1.Import</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre></div></div>
<p>2.Turn on</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
@SpringBootApplication
@EnableCaching
public class TacoCloudApplication implements WebMvcConfigurer {
    public static void main(String[] args) {
        SpringApplication.run(TacoCloudApplication.class, args);
    }
}

</code></pre></div></div>
<p>3.Using</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Cachable(value="cacheSpace",key="#id")
public User getById(Integer id) {
  return userDao.selectById(id);
}

</code></pre></div></div>

<p>After these 3 steps, we can already use all the cache capabilities that Simple has provided for us. Other 3rd-party libraries are directly supported by Spring Boot nearly all can be introduced like above. The quick tour of Spring Boot has to end now. This article is just a summary and whirlwind tour; next I will dive deep into a specific technology often used in Spring Boot.</p>


	  ]]></description>
	</item>

	<item>
	  <title>生活在Vim中</title>
	  <link>//live-in-the-vim</link>
	  <author>Tao He</author>
	  <pubDate>2021-12-10T22:30:12+04:00</pubDate>
	  <guid>//live-in-the-vim</guid>
	  <description><![CDATA[
	     <p>从第一天接触Vim编辑器到现在已经过去10年了，从最开始的不知所措到现在的运用自如，Vim已经融入到了我工作生活的很多场景, 它对于我已经不仅仅是一个高效强大的编辑器，更是变成了一种做事的方式和编辑，操作的哲学。关于这种哲学我最喜欢一个类比: 使用Vim的过程就像是一个画家画画的过程，当一个画家需要挥毫泼墨时，他就进入了insert模式，可以对画布进行任意的修改，当一个画家需要思考和审视时，他需要防止笔误和操作失当，这个时候他就需要进入normal模式，这个时候不能修改画布，只能在画布上移动，无论是移动你的手指和思绪，这个时候都不能对画布进行修改。这种特有的多模式也许是Vim和Emacs与其他大部分编辑器最显著的不同。</p>

<p>当你初窥Vim的与众不同后，如果你还不熟悉它的使用，你可能会不知所措，甚至无法编辑，无法退出，你和它会僵死在那里。你遇到的这种困境也正是Vim特有的操作方式引起的。这篇文章不打算如流水账般罗列Vim的诸多命令，我只挑选几种在日常代码编辑中最常用的命令来呈现Vim的神奇与强大。Vim之强大主要体现在无论是移动查询还是修改替换都能将一个动作做到非常小的粒度和精确控制，并且可以以极少的击键次数优雅地实现你精细的操作。我来举一个最常见的例子:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i = 3 * (4 + 2);

</code></pre></div></div>
<p>如上，假如我们想将括号中的内容改掉，一般的编辑器的做法都是移动到数字4，然后完全选中括号中的内容后修改。但是如果使用Vim，动作将会非常简单和快捷，只需移动到左括号后键入<code class="language-plaintext highlighter-rouge">ci(</code>即可，然后就可以直接进入insert模式修改了。敏感的读者可能已经感知到Vim的这条命令其实就是change in ()，有非常强的自然语言命令的感觉。</p>

<p>因为vim的使用其实可以写成一本书，网络上的教程更是数不胜数，这篇文章也不打算写成一篇使用教程。vim本身的使用需要长期的实践，而vim的使用场景的扩展可能就需要不断的探索和尝试了。我因为长期使用vim，对其浸润很深，所以发现了不少vim的其他使用方式和场景。第一个场景就是vim的命令和操作方式以插件的形式存在于其他的编辑器，IDE和软件应用中。 以下是三个典型的插件：</p>

<ul>
  <li>
    <p>VsVim(这个是大名鼎鼎的Visual Studio的一款Vim插件)</p>
  </li>
  <li>
    <p>VSCodeVim(for Visual Studio Code)</p>
  </li>
  <li>
    <p>IdeaVim(for Android Studio)</p>
  </li>
</ul>

<p>这三个插件都是应用于IDE或编辑器, 下面的这个插件甚至应用于Google浏览器:</p>

<ul>
  <li>Vimium</li>
</ul>

<p>其实按照这个思路，凡是有编辑需求的应用都可以嵌入Vim插件，这样的话即使某一天Vim这个编辑器不存在了, Vim的这种思想却可以一直存在下去，这也许就是Vim的魅力吧! 至此，谈到Vim的永生，就不得不谈一个我最近几年一直在用的Emacs变体–Spacemacs。Spacemacs本质上还是Emacs，一个厉害的程序员通过配置文件将其扩展成了一个可以同时支持Vim和Emacs操作的巨无霸，足见Emacs的强大的可扩展性。当你第一次使用Spacemacs时会让你选择Vim世界还是Emacs世界,两大上古神奇竟以此种方式存在了下来…</p>

<p>使用Vim的历程，从排斥到爱不释手到离不开，Vim已成为工作生活的一部分，可谓一日Vim，终生Vim.</p>


	  ]]></description>
	</item>

	<item>
	  <title>BaseQuickAdapter使用tips</title>
	  <link>//base-quick-adapter-tips</link>
	  <author>Tao He</author>
	  <pubDate>2021-11-10T18:00:00+04:00</pubDate>
	  <guid>//base-quick-adapter-tips</guid>
	  <description><![CDATA[
	     <p>此文记录在实际工作中使用BaseQuickAdapter的一些经验和心得，以期新同学在第一次使用时免去踩坑的风险。</p>

<p>Tips:</p>

<ul>
  <li>如果adapter只有一种类型的item，则直接继承自BaseQuickAdapter，提供布局文件即可，例如:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
class SelectedContactAdapter : BaseQuickAdapter&lt;ContactUIItemData, BaseViewHolder&gt;(layoutResId = R.layout.s_item_select_user_normal){
    override fun convert(holder: BaseViewHolder, item: ContactUIItemData) {
        holder.getView&lt;UserFaceView&gt;(R.id.ufv_avatar).bindUid(item.bean.account)
        addChildClickViewIds(R.id.ll_item)
    }
}

</code></pre></div></div>

<ul>
  <li>如果adapter需要多种类型的item，则需要继承自BaseMultiItemQuickAdapter，例如:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
class ContactAdapter : BaseMultiItemQuickAdapter&lt;ContactUIItemData, BaseViewHolder&gt;() {

    var actionType = AppConstants.User.TYPE_CONTACT_NEW_MESSAGE

    init {
        addItemType(ITEM_TYPE_HEAD, R.layout.s_item_contact_head)
        addItemType(ITEM_TYPE_TITLE, R.layout.s_item_contact_title)
        addItemType(ITEM_TYPE_CONTACT, R.layout.s_item_single_contact)

        setDiffCallback(object : DiffUtil.ItemCallback&lt;ContactUIItemData&gt;() {
            override fun areItemsTheSame(
                oldItem: ContactUIItemData,
                newItem: ContactUIItemData
            ): Boolean {
                return oldItem.viewType == newItem.viewType
            }

            override fun areContentsTheSame(
                oldItem: ContactUIItemData,
                newItem: ContactUIItemData
            ): Boolean {
                if (newItem.viewType == ITEM_TYPE_CONTACT) {
                    return TextUtils.equals(newItem.bean.account, oldItem.bean.account) &amp;&amp; TextUtils.equals(newItem.bean.name, oldItem.bean.name)
                    &amp;&amp; TextUtils.equals(newItem.searchText, oldItem.searchText)
                }
                return true;
            }
        })
    }
    
    ....
}

</code></pre></div></div>

<p>这里需要注意的是数据item必须实现MultiItemEntity接口:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
public class ContactUIItemData implements MultiItemEntity {

    ...

    @Override
    public int getItemType() {
        return viewType;
    }
}

</code></pre></div></div>

<p>并且需要实现DiffCallback，DiffCallback有两个方法需要实现，第一个用来判断两个item是否同一类型，如果判断是，则调用第二个方法判断两个item内容是否相等，这两个方法需要根据实际业务场景谨慎实现。</p>

<ul>
  <li>
    <p>刷新数据统一调用setDiffNewData，无论是第一次加载数据还是后续数据变更刷新，这里要注意的是，刷新时调用setDiffNewData需要传入新的数据列表才能实现刷新。</p>
  </li>
  <li>
    <p>如只需刷新某个item，则可以通过notifyItemChanged来实现，当然添加和删除数据都有对应的方法，但是添加和删除还是统一走setDiffNewData比较好。</p>
  </li>
  <li>
    <p>如只需刷新某个item中的某个元素，而不是刷新整个item，则可以通过payload的方式来实现局部刷新，例如:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
override fun convert(holder: BaseViewHolder, item: GroupUIItemData, payloads: List&lt;Any&gt;) {
    super.convert(holder, item, payloads)
    when(holder.itemViewType) {
        GroupContactItemConstants.ITEM_TYPE_CONTACT -&gt; {
            if (payloads.isEmpty()) {
                return
            }

            val payload = payloads[0];
            if (payload == EDIT_MODE_PAYLOAD) {

                val cbSelect = holder.getView&lt;CheckBox&gt;(R.id.cb_select)
                cbSelect.isChecked = item.checked
                cbSelect.isEnabled = item.enabled

                if (item.canSelect) {
                    cbSelect.visibility = View.VISIBLE
                } else {
                    cbSelect.visibility = View.GONE
                }
            }
        }
    }
}

</code></pre></div></div>

<p>对需要局部刷新的item调用contactsAdapter.notifyItemChanged(position, GroupContactAdapter.EDIT_MODE_PAYLOAD).</p>

<ul>
  <li>
    <p>如遇到列表不刷新的问题，则需要检查调用setDiffNewData时传入的是否时新的列表，数据源对象是不是新对象，从多个方面来排查，理论上更新列表就统一使用这个方法，避免调用notifyDataSetChanged.</p>
  </li>
  <li>
    <p>要注意DiffCallback的实现，如果遇到问题，可调试此接口两个方法实现的返回值。</p>
  </li>
  <li>
    <p>Item的点击事件响应都是通过setOnItemClickListener和setOnItemChildClickListener分别实现，前者是注册整个item，后者是注册item上的子view，子view的响应需要调用addChildClickViewIds来分别注册。</p>
  </li>
  <li>
    <p>Item的长按与点击相同，分别对应setOnItemLongClickListener和setOnItemChildLongClickListener两个方法。</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Kotlin使用小计</title>
	  <link>//kotlin-overview</link>
	  <author>Tao He</author>
	  <pubDate>2021-11-06T18:00:00+04:00</pubDate>
	  <guid>//kotlin-overview</guid>
	  <description><![CDATA[
	     <p>此文记录一次对Kotlin的技术分享，显然无法对Kotlin的方方面面都涉及到，只将一些在实际工作中频繁涉及到的要点做一个梳理，以期对Kotlin这们JVM语言有一个整体的认识。</p>

<h4 id="为什么使用kotlin">为什么使用Kotlin</h4>
<ul>
  <li>静态类型语言</li>
  <li>同时支持面向对象和函数式编程范式</li>
  <li>更强大语言表达能力</li>
  <li>解决Java NPE问题，更安全</li>
  <li>支持扩展函数</li>
  <li>与Java的高互操作性</li>
</ul>

<h3 id="类和函数">类和函数</h3>
<ul>
  <li>我们只能继承声明为open 或 obstract的类</li>
  <li>Unit 类似Java中的void</li>
  <li>每一个函数都返回一个值</li>
  <li>函数参数支持默认值，类似C++</li>
</ul>

<h3 id="变量和属性">变量和属性</h3>
<ul>
  <li>一切都是对象，包括基础类型，比Java更加彻底</li>
  <li>对于var和val的使用，最佳实践是: 尽可能多的使用val</li>
  <li>Property类似java中的field，但更强大:</li>
</ul>

<p>In Java:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Person {
   private String name;

   public String getName() {
     return name;
   }

  public void setName(String name) {
     this.name = name;
   }

}

Person person = new Person();
person.setName("name");
String name = person.getName();

</code></pre></div></div>

<p>In Kotlin:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person {
  var name: String = ""
}

val person = Person()
person.name = "name"
val name = person.name

</code></pre></div></div>

<p>定制getter，setter行为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person {
  var name: String = ""
     get() = field.toUpperCase()
     set(value) {
       field = "Name: $value"
     }
}

</code></pre></div></div>

<h4 id="data-classes">Data Classes</h4>

<p>强大的一种类，可以帮助我们避免一些模板代码和避免出错</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data class Movie(var name: String, var studio: String, var rating: Float)

</code></pre></div></div>

<p>等价于Java Pojo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
public class Movie {

    private String name;
    private String studio;
    private float rating;
    
    public Movie(String name, String studio, float rating) {
        this.name = name;
        this.studio = studio;
        this.rating = rating;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getStudio() {
        return studio;
    }

    public void setStudio(String studio) {
        this.studio = studio;
    }

    public float getRating() {
        return rating;
    }

    public void setRating(float rating) {
        this.rating = rating;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + Float.floatToIntBits(rating);
        result = prime * result + ((studio == null) ? 0 : studio.hashCode());
        
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        
        if (obj == null)
            return false;
        
        if (getClass() != obj.getClass())
            return false;
        
        Movie other = (Movie) obj;
        
        if (name == null) {
            if (other.name != null)
                return false;
            
        } else if (!name.equals(other.name))
            return false;
        
        if (Float.floatToIntBits(rating) != Float.floatToIntBits(other.rating))
            return false;
        
        if (studio == null) {
            if (other.studio != null)
                return false;
            
        } else if (!studio.equals(other.studio))
            return false;
        
        return true;
    }

    @Override
    public String toString() {
        return "Movie [name=" + name + ", studio=" + studio + ", rating=" + rating + "]";
    }
}

</code></pre></div></div>

<p>Copy数据类对象:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f1 = Forecast(Date(), 27.5f, "Shiny day")
val f2 = f1.copy(temperature = 30f)

</code></pre></div></div>

<p>把一个对象的多个字段映射到多个变量中</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f1 = Forecast(Date(), 27.5f, "Shiny day")
val (date, temperature, details) = f1

</code></pre></div></div>

<h4 id="操作符重载">操作符重载</h4>

<ul>
  <li>类似C++</li>
  <li>===和!==不能被重载</li>
</ul>

<h4 id="lambdas">Lambdas</h4>

<ul>
  <li>Java也支持，但是Kotlin中lambdas表达式可以变得非常简单，语法糖，便利的同时也要特别小心</li>
  <li>在Kotlin中，函数可以作为一个类型</li>
  <li>类似C++中的函数指针</li>
</ul>

<h4 id="visibility-modifiers">Visibility Modifiers</h4>

<ul>
  <li>默认的可见性是public</li>
  <li>private, protected, internal可见官方文档定义</li>
</ul>

<h4 id="集合和函数操作">集合和函数操作</h4>

<p>大概有如下几类操作,具体见官方文档</p>

<ul>
  <li>Aggregate operations:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
//any
val list = listOf(1, 2, 3, 4, 5, 6)
assertTrue(list.any { it % 2 == 0 })
assertFalse(list.any { it &gt; 10 })

//all
assertTrue(list.all { it &lt; 10 })
assertFalse(list.all { it % 2 == 0 })

...

</code></pre></div></div>

<ul>
  <li>
    <p>Filtering operations</p>
  </li>
  <li>
    <p>Mapping operations</p>
  </li>
  <li>
    <p>Elements operations</p>
  </li>
  <li>
    <p>Generation operations</p>
  </li>
  <li>
    <p>Ordering operations</p>
  </li>
</ul>

<h4 id="null-safety-in-kotlin">Null safety in Kotlin</h4>

<ul>
  <li>
    <p>对臭名昭著的Java NPE有了解决方案</p>
  </li>
  <li>
    <p>代码中如果大量充斥!!操作符将是一个很不好的信号</p>
  </li>
  <li>
    <p>如果显示声明为非空变量后再赋值空对象，会导致运行时crash，需特别注意</p>
  </li>
  <li>
    <p>Kotlin和Java代码共存，并且互操作时要特别注意空指针问题</p>
  </li>
  <li>
    <p>Java可通过Nullable和NonNull注解来显式明晰变量的取值</p>
  </li>
</ul>

<h4 id="coroutine">Coroutine</h4>
<p>可参见已有的一次技术分享: https://wiki.inn.bitcall.xyz/pages/viewpage.action?pageId=2232386</p>

<h4 id="anko">Anko</h4>

<ul>
  <li>
    <p>Github: https://github.com/Kotlin/anko</p>
  </li>
  <li>
    <p>JetBrains开发的一个强大的类库</p>
  </li>
  <li>
    <p>主要目的是使用代码来代替XML来生成UI布局</p>
  </li>
  <li>
    <p>我们的项目在后期性能优化时可考虑引入使用</p>
  </li>
</ul>

<h4 id="kotlin-vs-java">Kotlin vs. Java</h4>

<p><img src="/assets/images/java-vs-kotlin.png" /></p>


	  ]]></description>
	</item>

	<item>
	  <title>升级Kotlin版本导致的coroutine崩溃ANR小记</title>
	  <link>//kotli-coroutine-proguard-crash</link>
	  <author>Tao He</author>
	  <pubDate>2021-06-04T18:00:00+04:00</pubDate>
	  <guid>//kotli-coroutine-proguard-crash</guid>
	  <description><![CDATA[
	     <p>最近公司的项目在最新的版本中升级了kotlin版本，使用CI打包后的版本启动都或闪退，或ANR，看崩溃日志和ANR日志，矛头都指向了coroutine，并且Release版本崩溃而Debug版本没有问题，初步断定就是混淆的问题了。因此搜索相关Proguard rules，在Kotlin官方Github中找到coroutines.pro文件:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# Allow R8 to optimize away the FastServiceLoader.
# Together with ServiceLoader optimization in R8
# this results in direct instantiation when loading Dispatchers.Main
-assumenosideeffects class kotlinx.coroutines.internal.MainDispatcherLoader {
    boolean FAST_SERVICE_LOADER_ENABLED return false;
}

-assumenosideeffects class kotlinx.coroutines.internal.FastServiceLoaderKt {
    boolean ANDROID_DETECTED return true;
}

-keep class kotlinx.coroutines.android.AndroidDispatcherFactory {*;}

# Disable support for "Missing Main Dispatcher", since we always have Android main dispatcher
-assumenosideeffects class kotlinx.coroutines.internal.MainDispatchersKt {
    boolean SUPPORT_MISSING return false;
}

# Statically turn off all debugging facilities and assertions
-assumenosideeffects class kotlinx.coroutines.DebugKt {
    boolean getASSERTIONS_ENABLED() return false;
    boolean getDEBUG() return false;
    boolean getRECOVER_STACK_TRACES() return false;
}

</code></pre></div></div>
<p>添加此混淆规则后重新打包，崩溃和ANR成功修复。</p>


	  ]]></description>
	</item>

	<item>
	  <title>xCrash运用小结</title>
	  <link>//summary-of-using-xcrash</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-29T18:00:00+04:00</pubDate>
	  <guid>//summary-of-using-xcrash</guid>
	  <description><![CDATA[
	     <p>公司在做海外产品，由于免费版firebase对native崩溃的捕获上报能力有限(无堆栈，无具体上下文信息)，因此对我们定位和降低native极为不利，当native崩溃总量进入top行列的时候，就不能对其视而不见了，因此我开始调研解决方案，最后决定接入爱奇艺推出的xCrash来捕获native崩溃，当然了，xCrash本身是不具备上报功能的，它只是将崩溃信息写入tombstone文件。因此需要在其基础之上添加上报功能。</p>

<p>要实现上报功能，就需要选择一个上报时机，在崩溃发生时或App再次启动时，我选择了在崩溃发生时即时上传tombstone文件，并与服务端约定上报协议，最终实现可在firebase后台通过设备ID来查看上传到服务器的tombstone文件。</p>

<p>具体实现如下：</p>

<p>在崩溃发生的回调中找到最新的tombstone文件，打包上传至服务器</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
public void init(Context context) {
    XCrash.init(context, new XCrash.InitParameters()
            .setAppVersion(BuildConfig.VERSION_NAME)
            .setLogDir(getCrashDir().getAbsolutePath())
            .setJavaRethrow(true)
            .setJavaLogCountMax(3)
            .setJavaDumpAllThreadsWhiteList(new String[]{"^main$", "^Binder:.*", ".*Finalizer.*"})
            .setJavaDumpAllThreadsCountMax(0)
            .setNativeRethrow(true)
            .setNativeLogCountMax(3)
            .setNativeDumpAllThreadsWhiteList(new String[]{"^Signal Catcher$", "^Jit thread pool$", ".*(R|r)ender.*", ".*Chrome.*"})
            .setNativeDumpAllThreadsCountMax(0)
            .setAnrRethrow(true)
            .setAnrLogCountMax(3)
            .setPlaceholderCountMax(0)
            .setLogFileMaintainDelayMs(1000)
            .setLogger(mLogger)
            .setLibLoader(new ILibLoader() {
                @Override public void loadLibrary(String libName) {
                    try {
                        ReLinker.loadLibrary(context, libName);
                    } catch (Exception e) {
                        printLog(e + " | " + libName);
                        System.loadLibrary(libName);
                    }
                }
            }).setAnrCallback(new ICrashCallback() {
                // ANR发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchANRLogDelay();
                }
            }).setJavaCallback(new ICrashCallback() {

                // Java崩溃发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchCrashLog();
                }
            }).setNativeCallback(new ICrashCallback() {
               //Native崩溃发生时的回调
                @Override public void onCrash(String logPath, String emergency) throws Exception {
                    catchCrashLog();
                }
            })
    );
}


// 打包上传tombstone文件
private void catchCrashLog() {
    crashZipId = generateCrashId();
    final File out = new File(AppInstances.getPathManager().getTmpFilePath() + crashZipId + ".gzip");

    try {
        List&lt;File&gt; files = Arrays.asList(getCrashDir().listFiles());
        if (ListUtils.isEmpty(files)) {
            return;
        }

        File crashFile = null;
        long lastModified = 0;
        for (File f : files) {
            if (f.lastModified() &gt; lastModified) {
                lastModified = f.lastModified();
                crashFile = f;
            }
        }

        if (crashFile != null) {
            GZIPUtils.gzipFile(crashFile.getAbsolutePath(), out.getAbsolutePath());
        }

    } catch (Throwable e) {
        e.printStackTrace();
    }

    upload();
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

</code></pre></div></div>
<p>上面的代码有一点需要注意: 为了尽可能将崩溃日志成功上传至服务器，主线程sleep五秒，对于anr的情况则是在非UI线程中上传日志。</p>

<p>日志上传成功后，就可以在firebase的崩溃列表中查看某一个崩溃，在数据一栏找到设备ID来查询。因为我们有运营后台可以将设备ID和用户ID关联，因此就可以轻松查到每个用户的崩溃日志。</p>

<p>此即时上报的方案上线后虽然助力定位到了一些问题，但也有如下缺陷和问题</p>

<ul>
  <li>
    <p>引入了新的问题，如OOM，ANR等问题。</p>
  </li>
  <li>
    <p>由于上报依赖于全局的OkHttp Client，因此如果App在没有初始化OkHttp Client的情况下崩溃，则不会上报，就属漏报了。</p>
  </li>
  <li>
    <p>崩溃和anr不能即时聚合到一处供查看</p>
  </li>
  <li>
    <p>ANR目前不能查询，但是已尝试使用firebase Event上报，但是貌似免费版无法查看Event的字段，上报的意义不大，后期考虑向服务端上报。</p>
  </li>
</ul>

<p>问题2和3其实可以很容易改善，但是问题1还有待进一步观察，同期因为我们代码的原因引入了一个严重的OOM问题，所以不太确定是不是xCrash受到了影响和牵连。这个OOM问题修复后准备再打开xCrash进一步验证。</p>

<p>目前观察到一个现象，Android 7以下的机器基本都没有成功上报，比较奇怪，但是本地测试Android 4的机器是可以上报的，此问题后续有待验证。</p>

	  ]]></description>
	</item>

	<item>
	  <title>客户端线上问题应对小记</title>
	  <link>//resolve-online-problem</link>
	  <author>Tao He</author>
	  <pubDate>2021-04-26T18:00:00+04:00</pubDate>
	  <guid>//resolve-online-problem</guid>
	  <description><![CDATA[
	     <p>今年三四月份我所在的App项目经历了不少我之前很少遇到的情况，回看这些无论是突发状况，还是隐匿得让人无法发觉的细节导致的问题，都非常有借鉴意义，也是很大的教训，难能可贵的经验，有必要用一小文记录下。</p>

<p>两个月的时间，经历了一次线上crash激增，一次新发版本用户无法播放视频的集中反馈，和一次OOM和ANR持续上涨。下面分别复盘这三次惊魂时刻。</p>

<p>先来说说线上crash突然激增，那天上午的时候突然native崩溃曲线陡升，而我们App最近的一个版本已经全量好多天了，native崩溃一直都是一个相对稳定的曲线，这使我们一头雾水，因为firebase对native崩溃的捕获很不好，更加导致我们焦急万分，我负责App的整体质量，当时更是如热锅上的蚂蚁。着急归着急，也不能乱了阵脚，先开始排除活动或广告下发的影响，于是赶紧联系了市场的同学，让他们确定最近是否有活动或广告投放，询问后发现并没有，但是得知最近的确有买量的操作，并且DAU有上涨的趋势，于是怀疑是不是因为买量导致native崩溃激增，但是后来查看firebase后台，native崩溃大多发生在低端机器上，这就说不过去了，难道买到的量都是低端机器?于是很快推翻了这个怀疑。开始分版本分析，很快发现，近几个版本的native崩溃上涨曲线基本都能吻合，说明这是一个外部环境变化导致的崩溃，而不是某一个版本引入的新崩溃，在firebase有限的native崩溃信息中，还是发现了
libmonochrome.so这个信息，当看到这个so的时候，直觉告诉我是广告导致的没跑了，但是问题来了，最近并没有增加广告的投放，广告又如何使native崩溃激增呢？直到我们搜到这条新闻:<a href="https://www.cnbeta.com/articles/tech/1105323.htm">谷歌正在修复Android系统WebView组件引发的应用崩溃问题</a>一切才豁然开朗，是因为Google推送的webview组件更新有bug，导致了大面积的崩溃，于是我们果断的关闭了广告的投放，到晚上八点的时候，native崩溃曲线终于回归了正常。</p>

<p>再来说说集中反馈，事情是这样的，我们新发布了一个版本，在放量不到20%时，一天内集中收到好几个用户反馈视频不能播放，从用户提供的截图可以看出视频进度条还在动，但是并未渲染出视频，这个问题与之前我们已知的黑屏问题不同，显然是一个新问题。在没有任何头绪的情况下，就只能通过对比此版本与上个版本的diff来寻找蛛丝马迹，看完所有的diff后还是很让人疑惑，因为真的没有修改任何与播放器相关的代码，就连可能影响播放器的代码也没有，那这个版本到底有什么不同呢？在第二次对比diff的时候，广告sdk的升级改动引起了我的注意，我大胆猜想，难不成是这导致的，如果非要找个嫌疑人的话，只能是它了，于是赌上客户端组的声誉，告知市场广告sdk有问题，新版本去除更新重新发版，放量后再未出现此问题反馈，也是神奇，猜测广告sdk使用了opengl，可能影响到了播放器的视频渲染。</p>

<p>最后说下OOM和ANR持续上涨得情况，这可以说是一次线上事故，是因为使用第三方库不当和第三方工具本身的问题合力导致的，这次问题是在版本全量后几天后才逐步暴露出来的，坏就坏在这个问题是逐步积累，然后雪球越滚越大最后导致了严重的问题。因为firebase不能统计到有些OOM的崩溃，期初的几天我们还奇怪为什么在没有新增崩溃的情况下，崩溃率竟然一直在涨，于是尽快分析firebase的数据，但仍旧没有什么有用的线索，因为我们一直习惯于在firebase后台看崩溃，在Google Play Console看ANR，因此一直以来的习惯是没有人去GPC去看崩溃，直到在一次看ANR的时候不经意间看到了一个之前未发现的崩溃，显示为OOM问题，至此，问题浮出水面，是全量的这个版本在使用第三方库的时候，未注意到第三方库有一个每次操作如果是在主线程调用的话都新建线程的逻辑，导致了严重的OOM，再加上同一版本也接入了xCrash和BoostMultiDex，因此到底是谁导致了OOM和ANR，已然纠缠不清，版本已发出xCrash和BoostMultiDex已无法绕过，但是导致OOM的这个rtt上报却有开关，可以动态关闭，于是在关闭几天后，崩溃率逐步恢复正常，ANR也恢复正常，因此可以断定rtt上报应该是罪魁祸首。这是一个失误导致的大问题，教训深刻，既暴露了我们工程对线程的管理不善，也暴露出firebase可能漏报了很多我们不知道的OOM崩溃，也就说实际的OOM可能比我们现在看到的还要严重。</p>

<p>这三次线上问题，都已经过去了，App的崩溃率和ANR也恢复正常，但是教训却很深刻，经过几天的认真复盘和思考，总结出如下经验和教训:</p>

<ul>
  <li>一个问题激增时不一定是App本身的代码导致的，但也需要及时诊断和定位，不能倾向于从用户设备和DAU变化找问题</li>
  <li>诊断问题要聚焦，不要受一些外部因素干扰</li>
  <li>当问题发生时，倾向于App本身有问题，而不是找外部原因，不要被误导诊断方向</li>
  <li>当反馈集中发生时，肯定是有问题，而不用怀疑是反馈变集中了，事出反常必有妖</li>
  <li>接入第三方库和工具时要慎之又慎，多测试，多验证，多怀疑，做好兜底，做好出了问题的应对之策</li>
  <li>影响较大的功能和模块不宜同时出现在一个版本里，出现问题后纠缠不清，无法定位</li>
  <li>一个问题持续出现后，必须引起重视，在上报数据不完整，无上下文的情况下也要通过其他途径去诊断和定位，切不可倾向于没有问题。</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Booster使用小结</title>
	  <link>//summary-of-using-booster</link>
	  <author>Tao He</author>
	  <pubDate>2021-02-20T18:00:00+04:00</pubDate>
	  <guid>//summary-of-using-booster</guid>
	  <description><![CDATA[
	     <p>使用Booster去修复SharedPreferences导致的ANR的版本已全量上架Google Play，SP导致的ANR几乎绝迹，但是随之全量版本的逐步铺开，firebase崩溃后台却出现了Booster所导致的两个比较多的崩溃:</p>

<p>一个是NPE，触发的基本环境如下:</p>

<p>System version 6.0.1</p>

<p>Java version 8</p>

<p>Gradle version 6.6.1</p>

<p>Android Gradle plugin version 4.0.0</p>

<p>Booster version 3.1.0</p>

<p>主要的崩溃机型:Galaxy J2 Prime(76%), Galaxy Grand Neo, Galaxy J3(2016), MAXTRON U22</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fatal Exception: java.lang.NullPointerException
Attempt to invoke virtual method 'java.lang.String java.io.File.getParent()' on a null object reference
com.didiglobal.booster.instrument.sharedpreferences.SharedPreferencesManager.&lt;init&gt; (SharedPreferencesManager.java:36)
com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.&lt;init&gt; (BoosterSharedPreferences.java:42)
com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.getSharedPreferences (BoosterSharedPreferences.java:58)
com.didiglobal.booster.instrument.ShadowSharedPreferences.getSharedPreferences (ShadowSharedPreferences.java:15)
com.google.android.gms.internal.ads.zzabb.initialize (zzabb.java:33)
com.google.android.gms.internal.ads.zzabf.zzi (zzabf.java:15)
com.google.android.gms.internal.ads.zzabe.get (zzabe.java)
com.google.android.gms.ads.internal.util.zzbu.zza (zzbu.java:13)
com.google.android.gms.internal.ads.zzabf.initialize (zzabf.java:1)
com.google.android.gms.internal.ads.zzanc.run (zzanc.java:2)
java.lang.Thread.run (Thread.java:818)

</code></pre></div></div>

<p>此问题已经在github上提issue给开源团队，经过几次沟通，确定是Booster的bug，开源团队响应极快，在3.3.1版本已修复此问题。</p>

<p>另一个问题Class Cast Exception，基本环境与上面相同，主要发生在 Samsung Android 4, 4.2.2</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Caused by java.lang.ClassCastException
java.lang.Integer cannot be cast to java.lang.Boolean

com.didiglobal.booster.instrument.sharedpreferences.BoosterSharedPreferences.getBoolean (BoosterSharedPreferences.java:120)
cn.xiaochuankeji.zuiyouLite.common.instance.SelectGenderDlgManager.&lt;init&gt; (SelectGenderDlgManager.java:95)
cn.xiaochuankeji.zuiyouLite.common.instance.SelectGenderDlgManager.getInstance (SelectGenderDlgManager.java:71)
cn.xiaochuankeji.zuiyouLite.ui.main.MainActivity.onCreate (MainActivity.java:236)
android.app.Activity.performCreate (Activity.java:5112)
android.app.Instrumentation.callActivityOnCreate (Instrumentation.java:1080)
android.app.ActivityThread.performLaunchActivity (ActivityThread.java:2214)
android.app.ActivityThread.handleLaunchActivity (ActivityThread.java:2300)
android.app.ActivityThread.access$700 (ActivityThread.java:156)
android.app.ActivityThread$H.handleMessage (ActivityThread.java:1298)
android.os.Handler.dispatchMessage (Handler.java:99)
android.os.Looper.loop (Looper.java:137)
android.app.ActivityThread.main (ActivityThread.java:5211)
java.lang.reflect.Method.invokeNative (Method.java)
java.lang.reflect.Method.invoke (Method.java:511)
com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:815)
com.android.internal.os.ZygoteInit.main (ZygoteInit.java:582)
dalvik.system.NativeStart.main (NativeStart.java)

</code></pre></div></div>

<p>此问题目前还未被修复。除了这两个比较崩溃，目前Booster未引入新的问题，并且实实在在的解决了SP的ANR问题，使用线程池优化模块的版本也已上线，目前未发现问题，后续会统计对减少创建线程导致的OOM的贡献。引入Booster也是担着一定的风险，对于一个百万级日活的App，如果出现一个因为第三方工具导致的问题，很有可能导致线上事故，因此在引入前一定要对其做足了调研和评估。</p>

<p>Booster的这种解决问题的方式真的是可谓优雅，不需你更改一行代码，在你使用它提供的gradle插件构建你的工程后，它已默默的为你修复了诸多问题，并且可以根据你的实际情况选择使用不同的功能模块。使用booster以来真的给我很多启发:</p>

<ul>
  <li>系统问题也不是不可解决，也许换个思路，就有了办法</li>
  <li>开发工具，一定要让它易用，直观，易于理解</li>
  <li>开发的功能一定要相对独立，模块化</li>
  <li>引入第三方工具钱，一定要做足调研和评估</li>
  <li>使用了以后也要做好权衡，如它带来的利是否远大于弊</li>
</ul>


	  ]]></description>
	</item>


</channel>
</rss>
