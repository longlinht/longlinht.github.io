<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>与机器，人，神共舞</title>
    <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
    <link>http://longlinht.github.io/</link>
    <atom:link href="http://longlinht.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>在Android中定制Emoji的实现</title>
        <description>&lt;p&gt;最近公司产品在评论输入中要加入定制emoji面板，因此趟了emoji这个浑水，现以此文记录期间踩过的坑和一些心得。要实现一个相对比较完善的emoji输入和显示的功能，需要解决两个主要的问题: 键盘和emoji表情的平滑切换和emoji的正确显示。前者其实和emoji本身不相关，因此放在后面讨论。先来探究定制emoji的实现方案。 &lt;/p&gt;

&lt;p&gt;我们团队内部想到的最快的实现方案是定制googlefonts的NotoColorEmojiCompat.ttf, 使用EmojiCompact加载定制的ttf文件来显示我们定制的emoji。Google官方提供的NotoColorEmojiCompat的使用方法只有两种，一种方式是将NotoColorEmojiCompat.ttf文件放在assets目录，打入apk中使用，另一种方式是不打入apk，而是通过动态查询ContentProvider去查询获得，好处是不用将ttf文件打入apk包，坏处是查询到的ttf文件还是未定制的NotoColorEmojiCompat.ttf文件，实现不了定制的目的。我们的目标是在不打入这样一个7M的ttf文件的情况下实现定制目的，因此官方提供的这两种使用方式都不可取。因此就只剩下一条路，那就是app启动时下载我们定制的ttf文件，在EmojiCompat初始化时自己实现ttf的load过程，从而实现动态加载定制的emoji表情。&lt;/p&gt;

&lt;p&gt;创建一个EmojiHelpler类来管理EmojiCompat的初始化和定制ttf的加载:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class EmojiHelper {

    private static Context sContext;
    private static boolean sEmojiReady = false;

    public static void initCompat(Context context) {

        sContext = context;
        //EmojiCompat.Config config = new BundledEmojiCompatConfig(AppContext.get());
        EmojiCompat.Config config = new XLEmojiCompatConfig();

        config.setReplaceAll(true);
        config.registerInitCallback(new EmojiCompat.InitCallback() {
            @Override
            public void onInitialized() {
                super.onInitialized();
                Log.d(&amp;quot;hetaod&amp;quot;, &amp;quot;onInitialized&amp;quot;);
                //XLog.d(&amp;quot;onInitialized&amp;quot;);
            }

            @Override
            public void onFailed(@Nullable Throwable throwable) {
                super.onFailed(throwable);
                Log.d(&amp;quot;hetaod&amp;quot;, &amp;quot;onFailed: &amp;quot; + throwable.getMessage());
                //XLog.printStackTrace(throwable);
            }
        });


        EmojiCompat.init(config);
    }

    public static CharSequence process(CharSequence text) {
        if (sEmojiReady) {
            return EmojiCompat.get().process(text);
        }
        return text;
    }

    private static class XLEmojiCompatConfig extends EmojiCompat.Config {
        XLEmojiCompatConfig() {
            super(new XLMetadataRepoLoader());
        }
    }

    private static class XLMetadataRepoLoader implements EmojiCompat.MetadataRepoLoader {

        @Override
        public void load(@NonNull EmojiCompat.MetadataRepoLoaderCallback loaderCallback) {
            //String filePath = sContext.getCacheDir().getAbsolutePath() + &amp;quot;/NotoColorrEmojiCompat.ttf&amp;quot;;

            File file = new File(&amp;quot;/sdcard/NotoColorEmojiCompat.ttf&amp;quot;);
            FileInputStream fileInputStream = null;
            try {
                fileInputStream = new FileInputStream(file);
                loaderCallback.onLoaded(MetadataRepo.create(Typeface.createFromFile(file.getAbsolutePath()), fileInputStream));
            } catch (IOException e) {
                Log.d(&amp;quot;hetaod&amp;quot;, e.getMessage());
                //XLog.printStackTrace(e);
            } finally {
                //Util.safeClose(fileInputStream);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载定制ttf的关键是继承EmojiCompat和实现EmojiCompat.MetadataRepoLoader接口。在实现了初始化和加载定制ttf后，就剩最后一步，制作定制ttf文件，通过一些emoji的工具，可以轻松制作定制的emoji，我们的实现方式是使用未使用的unicode码来定义我们自己的emoji，在定制的ttf文件制作后以后，下载，初始化，加载，加载失败，卡在了加载这一步，我们定制的ttf文件加载失败，一直报如下的错误:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Cannot read metadata.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们多次确认制作ttf的方法应该没有问题，但是仍旧加载失败，怀疑是Google做了限制，无法定制这个ttf文件，多次尝试无果后，我们放弃了这个方案。&lt;/p&gt;

&lt;p&gt;放弃了上面这个方案后，我们选择了Github上的一个开源实现，简单易用，通过实现一个提供定制表情的provider就可以达到定制的目的。&lt;/p&gt;

&lt;p&gt;Github地址: https://github.com/vanniktech/Emoji&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;添加依赖：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;implementation &amp;#39;com.vanniktech:emoji:0.7.0&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;实现EmojiProvider接口:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//实现EmojiProvider接口
public class CocoEmojiProvider implements EmojiProvider {
    @Override @NonNull
    public EmojiCategory[] getCategories() {
        return new EmojiCategory[] {
                new SimpleCategory()
        };
    }
}


//emoji分类
public class SimpleCategory implements EmojiCategory {
    private static final CocoEmoji[] EMOJIS = CategoryUtils.concatAll(SimpleCategoryChunk0.get());

    @Override @NonNull
    public CocoEmoji[] getEmojis() {
        return EMOJIS;
    }

    @Override @DrawableRes
    public int getIcon() {
        return 0;
    }

    @Override @StringRes
    public int getCategoryName() {
        return 0;
    }
}


// 定制emoji列表定义
final class SimpleCategoryChunk0 {
    @SuppressWarnings(&amp;quot;PMD.ExcessiveMethodLength&amp;quot;) static CocoEmoji[] get() {
        return new CocoEmoji[] {
                new CocoEmoji(0x1F580, new String[]{&amp;quot;Hehe&amp;quot;}, 0, 0, false),
                new CocoEmoji(0x1F581, new String[]{&amp;quot;Mesume&amp;quot;}, 0, 1, false),
                new CocoEmoji(0x1F582, new String[]{&amp;quot;Ngenes&amp;quot;}, 0, 2, false),
                new CocoEmoji(0x1F583, new String[]{&amp;quot;Apaan sih&amp;quot;}, 0, 3, false),
                new CocoEmoji(0x1F584, new String[]{&amp;quot;Ngupil&amp;quot;}, 0, 4, false),
                new CocoEmoji(0x1F585, new String[]{&amp;quot;Bodo&amp;quot;}, 0, 5, false),
                new CocoEmoji(0x1F586, new String[]{&amp;quot;Berdoa&amp;quot;}, 0, 6, false),
                new CocoEmoji(0x1F588, new String[]{&amp;quot;Lempar tai&amp;quot;}, 0, 7, false),
                new CocoEmoji(0x1F589, new String[]{&amp;quot;Bengek&amp;quot;}, 0, 8, false),
                new CocoEmoji(0x1F58E, new String[]{&amp;quot;Jempol&amp;quot;}, 0, 9, false),
                new CocoEmoji(0x1F58F, new String[]{&amp;quot;tepuk tangan&amp;quot;}, 0, 10, false),
                new CocoEmoji(0x1F591, new String[]{&amp;quot;love&amp;quot;}, 0, 11, false),
        };
    }

    private SimpleCategoryChunk0() {
        // No instances.
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在布局中使用支持emoji的控件:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;RelativeLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:layout_width=&amp;quot;wrap_content&amp;quot;
    android:layout_height=&amp;quot;wrap_content&amp;quot;
    android:padding=&amp;quot;10dp&amp;quot;
    android:orientation=&amp;quot;horizontal&amp;quot;&amp;gt;

    &amp;lt;com.vanniktech.emoji.EmojiTextView
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;30dp&amp;quot;
        android:id=&amp;quot;@+id/quick_textview&amp;quot;
        android:textColor=&amp;quot;@color/CO_T1&amp;quot;
        android:textSize=&amp;quot;25sp&amp;quot;
        android:gravity=&amp;quot;center_horizontal&amp;quot;
        /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在此方案中仍旧是使用未使用的unicode来定义我们定制的emoji，而不是去定一个固定形式的字符串来定义。因此存在兼容老版本的问题，因为我们app的老版本未使用任何定制emoji，这个问题我们目前是简单的通过服务端替换来解决。&lt;/p&gt;

&lt;p&gt;解决了emoji的显示问题，就该着手解决emoji面板和键盘平滑切换的问题了。需要键盘和其他面板切换的输入场景下一般的解决方案是使用KPSwitch实现。但是KPSwitch切换界面在嵌入到一个单独的view里面后，切换时有跳闪，体验不是很好，所以这种方案虽然实现起来最快，但是不符合交互要求，所以首先pass，还有一个方案是把emoji面板，键盘都整体做到一个透明的Activity中，和app其他的业务逻辑分离，吊起键盘相当于启动一个透明的activity，和输入相关的功能逻辑都封装到activity中。这种方案虽然隔离性很好，也相对独立，但是需要管理生命周期的问题，对我们现有的输入功能改动较大，所以也pass。排除了两种可行的方案后，要想改动最小，又能实现平滑的体验，就需要做到两点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这个输入功能还是得实现为一个自定义View，而不是一个Activity，这样对现有代码改动最小，影响最小。&lt;/li&gt;
&lt;li&gt;要在不使用KPSwitch的情况下实现平滑切换。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个要求好实现，不在赘述。要实现第二个要求也不是那么难，关键点如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自定义View的特殊布局&lt;/li&gt;
&lt;li&gt;关键的几个布局控制方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来看布局:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;LinearLayout
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;wrap_content&amp;quot;
        android:orientation=&amp;quot;vertical&amp;quot;
        &amp;gt;

        &amp;lt;!--键盘弹起后上，屏幕剩余部分--&amp;gt;
        &amp;lt;View
            android:id=&amp;quot;@+id/layout_input_empty&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;0dp&amp;quot;
            android:layout_weight=&amp;quot;1&amp;quot;
            /&amp;gt;

        &amp;lt;!--键盘及其他交互UI部分--&amp;gt;
        &amp;lt;LinearLayout
            android:id=&amp;quot;@+id/ll_bottom&amp;quot;
            android:layout_width=&amp;quot;match_parent&amp;quot;
            android:layout_height=&amp;quot;wrap_content&amp;quot;
            android:focusable=&amp;quot;true&amp;quot;
            android:clickable=&amp;quot;true&amp;quot;
            android:focusableInTouchMode=&amp;quot;true&amp;quot;
            android:gravity=&amp;quot;center_vertical&amp;quot;

            &amp;gt;

            &amp;lt;LinearLayout
                android:layout_width=&amp;quot;match_parent&amp;quot;
                android:layout_height=&amp;quot;wrap_content&amp;quot;
                android:orientation=&amp;quot;vertical&amp;quot;
                &amp;gt;

                &amp;lt;cn.xiaochuankeji.zuiyouLite.widget.listener.FrameListenerLayout
                    android:id=&amp;quot;@+id/publisher_top_listener&amp;quot;
                    android:layout_width=&amp;quot;match_parent&amp;quot;
                    android:layout_height=&amp;quot;wrap_content&amp;quot;
                    android:layout_gravity=&amp;quot;center_vertical&amp;quot;
                    android:paddingLeft=&amp;quot;15dp&amp;quot;
                    android:paddingTop=&amp;quot;5dp&amp;quot;
                    android:paddingRight=&amp;quot;15dp&amp;quot;
                    android:background=&amp;quot;@drawable/replay_comment_bg&amp;quot;
                    &amp;gt;

                    &amp;lt;RelativeLayout
                        android:layout_width=&amp;quot;match_parent&amp;quot;
                        android:layout_height=&amp;quot;wrap_content&amp;quot;
                        android:gravity=&amp;quot;center_vertical&amp;quot;&amp;gt;

                        &amp;lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.ReplaySomeoneTipView
                            android:id=&amp;quot;@+id/replay_someone_tip_view&amp;quot;
                            android:layout_width=&amp;quot;match_parent&amp;quot;
                            android:layout_height=&amp;quot;wrap_content&amp;quot;
                            android:layout_marginTop=&amp;quot;14dp&amp;quot;
                            android:layout_marginBottom=&amp;quot;3dp&amp;quot;
                            android:visibility=&amp;quot;gone&amp;quot; /&amp;gt;


                        &amp;lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.QuickReplayView
                            android:id=&amp;quot;@+id/quick_replay_view&amp;quot;
                            android:layout_width=&amp;quot;match_parent&amp;quot;
                            android:layout_height=&amp;quot;wrap_content&amp;quot;
                            android:layout_below=&amp;quot;@+id/replay_someone_tip_view&amp;quot;
                            android:layout_marginTop=&amp;quot;11dp&amp;quot; /&amp;gt;

                        &amp;lt;LinearLayout
                            android:id=&amp;quot;@+id/edit_scroll&amp;quot;
                            android:layout_width=&amp;quot;match_parent&amp;quot;
                            android:layout_height=&amp;quot;wrap_content&amp;quot;
                            android:orientation=&amp;quot;vertical&amp;quot;
                            android:background=&amp;quot;@drawable/comment_edit_bg&amp;quot;
                            android:padding=&amp;quot;8dp&amp;quot;
                            android:layout_below=&amp;quot;@+id/quick_replay_view&amp;quot;
                            android:layout_toLeftOf=&amp;quot;@+id/publisher_send_new&amp;quot;
                            android:layout_marginBottom=&amp;quot;12dp&amp;quot;
                            &amp;gt;

                            &amp;lt;cn.xiaochuankeji.zuiyouLite.widget.publisher.PostCommentEditText
                                android:id=&amp;quot;@+id/publisher_edit&amp;quot;
                                android:layout_width=&amp;quot;match_parent&amp;quot;
                                android:layout_height=&amp;quot;wrap_content&amp;quot;
                                android:background=&amp;quot;@color/CO_B3&amp;quot;
                                android:hint=&amp;quot;@string/comment_input_comment&amp;quot;
                                android:lineSpacingExtra=&amp;quot;2.4dp&amp;quot;
                                android:maxLength=&amp;quot;2000&amp;quot;
                                android:maxLines=&amp;quot;3&amp;quot;
                                android:minLines=&amp;quot;1&amp;quot;
                                android:textColor=&amp;quot;@color/CO_T1&amp;quot;
                                android:textColorHint=&amp;quot;@color/CO_T3&amp;quot;
                                android:textCursorDrawable=&amp;quot;@drawable/cursor_yellow&amp;quot;
                                android:textSize=&amp;quot;13sp&amp;quot; /&amp;gt;
                            &amp;lt;!-- 选中的 视频/图片 文件列表 --&amp;gt;
                            &amp;lt;androidx.recyclerview.widget.RecyclerView
                                android:id=&amp;quot;@+id/publisher_select_media_list&amp;quot;
                                android:layout_below=&amp;quot;@+id/publisher_edit&amp;quot;
                                android:layout_width=&amp;quot;wrap_content&amp;quot;
                                android:layout_height=&amp;quot;match_parent&amp;quot;
                                android:layout_alignLeft=&amp;quot;@+id/publisher_edit&amp;quot;
                                android:layout_alignRight=&amp;quot;@+id/publisher_edit&amp;quot;
                                android:layout_marginTop=&amp;quot;7dp&amp;quot;
                                android:visibility=&amp;quot;gone&amp;quot; /&amp;gt;
                        &amp;lt;/LinearLayout&amp;gt;


                        &amp;lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&amp;quot;@+id/publisher_send_new&amp;quot;
                            android:layout_width=&amp;quot;24dp&amp;quot;
                            android:layout_height=&amp;quot;24dp&amp;quot;
                            android:layout_marginLeft=&amp;quot;15dp&amp;quot;
                            android:layout_alignBottom=&amp;quot;@id/edit_scroll&amp;quot;
                            android:layout_marginBottom=&amp;quot;4dp&amp;quot;
                            android:layout_alignParentRight=&amp;quot;true&amp;quot;
                            android:background=&amp;quot;@drawable/selector_chat_send&amp;quot; /&amp;gt;


                        &amp;lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&amp;quot;@+id/publisher_image_new&amp;quot;
                            android:layout_width=&amp;quot;36dp&amp;quot;
                            android:layout_height=&amp;quot;36dp&amp;quot;
                            android:paddingRight=&amp;quot;12dp&amp;quot;
                            android:paddingBottom=&amp;quot;12dp&amp;quot;
                            android:layout_below=&amp;quot;@+id/edit_scroll&amp;quot;
                            android:src=&amp;quot;@drawable/ic_comment_select_image&amp;quot; /&amp;gt;

                        &amp;lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&amp;quot;@+id/publisher_emoji&amp;quot;
                            android:layout_width=&amp;quot;36dp&amp;quot;
                            android:layout_height=&amp;quot;36dp&amp;quot;
                            android:layout_below=&amp;quot;@+id/edit_scroll&amp;quot;
                            android:layout_toRightOf=&amp;quot;@id/publisher_image_new&amp;quot;
                            android:paddingLeft=&amp;quot;12dp&amp;quot;
                            android:paddingBottom=&amp;quot;12dp&amp;quot;
                            android:src=&amp;quot;@drawable/ic_comment_cocoemoji&amp;quot; /&amp;gt;

                        &amp;lt;androidx.appcompat.widget.AppCompatImageView
                            android:id=&amp;quot;@+id/publisher_at_new&amp;quot;
                            android:layout_width=&amp;quot;36dp&amp;quot;
                            android:layout_height=&amp;quot;36dp&amp;quot;
                            android:layout_below=&amp;quot;@id/edit_scroll&amp;quot;
                            android:layout_toRightOf=&amp;quot;@id/publisher_emoji&amp;quot;
                            android:layout_marginLeft=&amp;quot;12dp&amp;quot;
                            android:paddingLeft=&amp;quot;12dp&amp;quot;
                            android:paddingBottom=&amp;quot;12dp&amp;quot;
                            android:src=&amp;quot;@drawable/ic_comment_at&amp;quot; /&amp;gt;

                    &amp;lt;/RelativeLayout&amp;gt;


                &amp;lt;/cn.xiaochuankeji.zuiyouLite.widget.listener.FrameListenerLayout&amp;gt;


                &amp;lt;!--emoji面板--&amp;gt;
                &amp;lt;FrameLayout
                    android:id=&amp;quot;@+id/fl_bottom&amp;quot;
                    android:layout_width=&amp;quot;match_parent&amp;quot;
                    android:layout_height=&amp;quot;300dp&amp;quot;
                    android:background=&amp;quot;#f5f7fa&amp;quot;
                    android:visibility=&amp;quot;gone&amp;quot;
                    &amp;gt;

                    &amp;lt;androidx.recyclerview.widget.RecyclerView
                        android:id=&amp;quot;@+id/rv_emoji&amp;quot;
                        android:layout_width=&amp;quot;match_parent&amp;quot;
                        android:layout_height=&amp;quot;wrap_content&amp;quot;
                        android:paddingTop=&amp;quot;5dp&amp;quot;
                        android:paddingLeft=&amp;quot;5dp&amp;quot;
                        android:paddingRight=&amp;quot;5dp&amp;quot;
                        /&amp;gt;

                    &amp;lt;androidx.appcompat.widget.AppCompatImageView
                        android:id=&amp;quot;@+id/iv_emoji_delete&amp;quot;
                        android:layout_width=&amp;quot;54dp&amp;quot;
                        android:layout_height=&amp;quot;40dp&amp;quot;
                        android:src=&amp;quot;@drawable/ic_comment_delete&amp;quot;
                        android:scaleType=&amp;quot;centerInside&amp;quot;
                        android:layout_gravity=&amp;quot;bottom|right&amp;quot;
                        android:layout_marginRight=&amp;quot;15dp&amp;quot;
                        android:layout_marginBottom=&amp;quot;15dp&amp;quot;
                        android:shadowColor=&amp;quot;#33000000&amp;quot;
                        android:shadowDx=&amp;quot;3.0&amp;quot;
                        android:background=&amp;quot;@drawable/emoji_delete_bg&amp;quot;
                        /&amp;gt;


                &amp;lt;/FrameLayout&amp;gt;

            &amp;lt;/LinearLayout&amp;gt;
        &amp;lt;/LinearLayout&amp;gt;
    &amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;动态代码中几个关键的方法:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/**
  * 锁定内容View以防止跳闪
  */
public void lockContentViewHeight() {
    LinearLayout.LayoutParams layoutParams =
            (LinearLayout.LayoutParams) layout_input_empty.getLayoutParams();
    layoutParams.height = layout_input_empty.getHeight();
    layoutParams.weight = 0;
    layout_input_empty.requestLayout();
}

/**
  * 释放锁定的内容View
  */
public void unlockContentViewHeight() {
    postDelayed(() -&amp;gt; {
        LinearLayout.LayoutParams layoutParams =
                (LinearLayout.LayoutParams) layout_input_empty.getLayoutParams();
        layoutParams.height = 0;
        layoutParams.weight = 1;
        //rc_content.requestLayout();
        ll_bottom.requestLayout();
        //requestLayout();
    }, 200);
}


public void hideEmoji() {
    iv_emoji.setImageResource(R.drawable.ic_comment_cocoemoji);
    lockContentViewHeight();
    rv_emoji.setVisibility(View.GONE);
    fl_bottom.setVisibility(GONE);
    unlockContentViewHeight();
    presentStatus = PublisherStatus.文字编辑;
    emojiVisible = false;
}

public void showEmoji(boolean animate) {
    iv_emoji.setImageResource(R.drawable.ic_comment_keyboard);
    if (!animate) {
        lockContentViewHeight();
        rv_emoji.setVisibility(View.VISIBLE);
        fl_bottom.setVisibility(VISIBLE);
        unlockContentViewHeight();
    } else {
        rv_emoji.setVisibility(View.VISIBLE);
        fl_bottom.setVisibility(VISIBLE);
    }
    //UIUtils.hideSoftInput((Activity) getContext());
    AndroidPlatformUtil.hideSoftInput((Activity) getContext());
    presentStatus = PublisherStatus.EMOJI;
    emojiVisible = true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何调用：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private void onEmojiClick() {
    if (rv_emoji.getVisibility() == View.VISIBLE) {
        lockContentViewHeight();
        hideEmoji();
        unlockContentViewHeight();
        //UIUtils.showSoftInput(et_comment, getContext());
        AndroidPlatformUtil.showSoftInput(et_comment, getContext());
    } else {
        showEmoji(false);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实实现这个方案后，我也有点惊讶，KPSwitch那么复杂的逻辑，竟然可以简单的以这种方式实现。说明做一切事情都不可拘泥于过去成功的方案，应该大胆尝试新的方法，说不定就能收获到惊喜呢！&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Jan 2021 22:00:00 +0800</pubDate>
        <link>http://longlinht.github.io//custom-emoji-in-android</link>
        <guid isPermaLink="true">http://longlinht.github.io//custom-emoji-in-android</guid>
      </item>
    
      <item>
        <title>First Lesson of Machine Learning</title>
        <description>&lt;p&gt;Two months ago, I made a decision for my career: learning machine learning from scratch. Machine learning involves many stuff of math while math is difficult. But I didnot give up in half way this time. Books, Youtube lectures, blogs, I collect learning materials as much as I can and do my best to learning it. 60 days passed, I have had a clarity understanding about some important concepts of Machine learing. In this article, I will figure out these concepts and their relations through 2 figures.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;This figure seems simple, but it reveals the relations of some important concepts.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/scratch_ml.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 2&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;This figure describes more detail.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/machine_learning.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Dec 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//first-lesson-of-machine-learning</link>
        <guid isPermaLink="true">http://longlinht.github.io//first-lesson-of-machine-learning</guid>
      </item>
    
      <item>
        <title>Review Matrix</title>
        <description>&lt;p&gt;Linear Algebra is prerequisite for Machine Learning while Matrix is the one of most important stuff in Linear Algebra. It is difficult to learn ML well in case of not 
familiar with Matrix. So it is time to review a few aspects of Matrix. Because of complexity of mathematical formula input, I will skip some details in main text, but attach them in three images(output from my Inkredible notes).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Image 1&lt;/strong&gt; (Learning notes output by Inkredible)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/IMG_20201203_201913.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 1 involves:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Matrix Definition&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Matrix Addition and Multiplication&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Image 2&lt;/strong&gt; (Learning notes output by Inkredible)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/IMG_20201203_201928.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 2 involves:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity Matrix &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Properties of Matrix:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Not Commutative&lt;/li&gt;
&lt;li&gt;Associativity&lt;/li&gt;
&lt;li&gt;Distributivity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Multiplication with the Identity Matrix&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inverse and Transpose&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Image 3&lt;/strong&gt; (Learning notes output by Inkredible)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/IMG_20201203_201950.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Image 3 involves:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Symetric Matrix&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Multiplication by a Scalar&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compat Representation of System Linear Equation&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 Nov 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//review-matrix</link>
        <guid isPermaLink="true">http://longlinht.github.io//review-matrix</guid>
      </item>
    
      <item>
        <title>Android module SDK化的实践</title>
        <description>&lt;p&gt;文章标题指的SDK化指的是将一个有多个module的Android工程中的特定module以aar的形式输出后被app模块依赖使用。那么如何在基本不改动代码的情况下实现这个要求，完成app模块对特定module的依赖呢?&lt;/p&gt;

&lt;p&gt;最直接的想法就是把要SDK化的module输出为aar文件，然后在app模块添加对此aar文件的依赖。在解决完所有的编译错误以后，运行app后发生了crash，查看输出，是因为输出为aar的这个模块所依赖的一个类在运行时找不到，事实上就是这个远端依赖没有被打进apk包。很明显，直接输出aar然后依赖是不可行的。&lt;/p&gt;

&lt;p&gt;远端依赖的类找不到，因为此module在输出为aar的时候并未将他的依赖打入aar包，那有没有办法将此module的所有依赖都打进aar包呢? 在线上搜索了一番后，还真找到了这样的一个gradle插件&lt;a href=&quot;https://github.com/kezong/fat-aar-android&quot;&gt;fat-aar-android&lt;/a&gt;来做这件事，接入到工程中很简单:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;应用插件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在project build gradle文件中加入如下代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &amp;#39;com.android.tools.build:gradle:xxx&amp;#39;
        classpath &amp;#39;com.kezong:fat-aar:1.2.20&amp;#39;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;使用插件关键字来嵌入依赖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将需要嵌入的依赖，修改implementation或api为embed&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;dependencies {
    implementation fileTree(dir: &amp;#39;libs&amp;#39;, include: &amp;#39;*.jar&amp;#39;)
    // java dependency
    embed project(path: &amp;#39;:lib-java&amp;#39;, configuration:&amp;#39;default&amp;#39;)
    // aar dependency
    embed project(path: &amp;#39;:lib-aar&amp;#39;, configuration:&amp;#39;default&amp;#39;)
    // aar dependency
    embed project(path: &amp;#39;:lib-aar2&amp;#39;, configuration:&amp;#39;default&amp;#39;)
    // local full aar dependency, just build in flavor1
    flavor1Embed project(path: &amp;#39;:lib-aar-local&amp;#39;, configuration:&amp;#39;default&amp;#39;)
    // local full aar dependency, just build in debug
    debugEmbed (name:&amp;#39;lib-aar-local2&amp;#39;,ext:&amp;#39;aar&amp;#39;)
    // remote jar dependency
    embed &amp;#39;com.google.guava:guava:20.0&amp;#39;
    // remote aar dependency
    embed &amp;#39;com.facebook.fresco:fresco:1.11.0&amp;#39;
    // don&amp;#39;t want to embed in
    // implementation is not recommended because the dependency may be different with the version in application, resulting in the R class not found.
    compileOnly &amp;#39;com.android.support:appcompat-v7:27.1.1&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用此插件除了会遇到资源冲突外，目前没有发现其他问题。但这个插件在github上的issue有点多，心里有点没底，所以还需要想其他的办法。&lt;/p&gt;

&lt;p&gt;这两个方法被排除后，就想到用maven来管理依赖，更灵活，是更一般的做法。 将此module输出后上传到maven服务器，在app上添加对此module的远程依赖后，发现无法编译，找不到此module依赖中的类，这是因为没有在pom中添加依赖。将aar发布到maven和添加依赖配置的代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;afterEvaluate {
    publishing {
        publications {
            release(MavenPublication) {
                artifact(&amp;quot;$buildDir/outputs/aar/live-debug.aar&amp;quot;) {
                    builtBy tasks.getByName(&amp;quot;assembleDebug&amp;quot;)
                }

                groupId = &amp;quot;com.overseas.android.live&amp;quot;
                artifactId = &amp;#39;live&amp;#39;
                version = &amp;#39;1.0.8&amp;#39;

                pom.withXml {
                    def dependenciesNode = asNode().appendNode(&amp;quot;dependencies&amp;quot;)
                    configurations.compile.dependencies.forEach { dep -&amp;gt; addDependency(dependenciesNode, dep, &amp;quot;compile&amp;quot;) }
                    configurations.api.dependencies.forEach { dep -&amp;gt; addDependency(dependenciesNode, dep, &amp;quot;compile&amp;quot;) }
                    configurations.implementation.dependencies.forEach { dep -&amp;gt; addDependency(dependenciesNode, dep, &amp;quot;runtime&amp;quot;) }
                }
            }
        }

        repositories {
            maven {
                url = uri(&amp;quot;https://xxx/repository/android-release/&amp;quot;)

                credentials {
                    username = &amp;quot;hetao&amp;quot;
                    password = &amp;quot;hetao&amp;quot;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在用maven管理依赖时需要注意一下几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要关注发布的module是不是有远程依赖，有的话需要添加依赖配置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要发布的module输出为debug版本，统一由app模块去做混淆&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要发布的module的混淆规则不能被遗漏，需要添加此配置:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;defaultConfig {
    ...

    consumerProguardFiles &amp;#39;proguard-rules.pro&amp;#39;

    ...

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不然会有因为混淆而找不到类的问题。&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Nov 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//using-maven-to-mananger-library</link>
        <guid isPermaLink="true">http://longlinht.github.io//using-maven-to-mananger-library</guid>
      </item>
    
      <item>
        <title>用python脚本优雅的整理Kindle的标注和笔记</title>
        <description>&lt;p&gt;我是重度Kindle使用者，Kindle里面存满了各类书籍，经常会同时读两三本书，时间一长，多本书的标注和笔记都交叉记录在My Clippings.txt文本文件里，现在这个文件已经有几万行，每次手动去整理特定的一本书的标注和笔记时都极为头疼，还容易错漏，终于有一天实在忍不了了，就去网上找有没有整理kindle标注和笔记的服务，还真让我给找到了，clipping.io，在线服务，马上使用，上传My Clippings.txt文件，一切顺利，文件上传后开始分析整理文本，看到几本书的标注已经出来了，等全部整理结束后发现少了好几本书的，再次重新上传文件重试整理，问题依旧，空欢喜一场，依旧不能解决我的痛点，最近在读的两本书的标注和笔记恰好没有被整理出来，一怒之下，决定自己用python脚本来写一个这样的整理工具，还以为得花费一两天的时间，一不小心，两个小时不到的功夫写完了，调试了一番，完全满足我的需求，现在只需一条命令，传入书名就可以整理出指定的一本书的所有标注和笔记，脚本如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# coding=utf-8

import os
import sys

def main():
   filepath = sys.argv[1]
   bookName = sys.argv[2]

   if not os.path.isfile(filepath):
       print(&amp;quot;File path {} does not exist. Exiting...&amp;quot;.format(filepath))
       sys.exit()

   DELIMITER = &amp;quot;==========&amp;quot;
   TIME_MAKR = &amp;quot;- 您在第&amp;quot;
   lineNum = 0
   books = {}

   bag_of_words = {}
   with open(filepath) as fp:
       encounter = False
       delimiterCount = 0
       curBookName = &amp;quot;&amp;quot;
       for line in fp:
           if lineNum == 0:
               books[line] = []
               curBookName = line
               delimiterCount += 1
           else:
               if line.startswith(DELIMITER):
                   delimiterCount += 1
                   encounter = True
               else:
                   if encounter == True:
                       if line in books:
                           curBookName = line
                       else:
                           books[line] = []
                       encounter = False
                       curBookName = line
                   else:
                       books[curBookName].append(line)
           lineNum += 1
           #print(line)

       fp.close()            

   outFile = open(&amp;quot;MyClippingOutput.txt&amp;quot;, &amp;quot;w&amp;quot;)
   for k in books:
       if k.startswith(bookName) :
           outFile.writelines(k)
           lines = books[k]
           for l in lines:
               if l.startswith(TIME_MAKR):
                   continue
               if l.startswith(bookName):
                   continue
               outFile.writelines(l)
   outFile.close()

if __name__ == &amp;#39;__main__&amp;#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前这个脚本我只是自用，满足我个人的需求，我想肯定也有很多kindle的重度使用者有类似的需求，后续我准备把这个工具也做成在在线服务，使用方式类似clipping.io，做到比clipping.io的可定制型更强，能够适应更多的异常情况，因为我发现clipping.io对一些不规范的书名的容错性很差。期待这个服务上线！&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Nov 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//using-python-parse-kindle-notes</link>
        <guid isPermaLink="true">http://longlinht.github.io//using-python-parse-kindle-notes</guid>
      </item>
    
      <item>
        <title>读《未来简史》</title>
        <description>&lt;p&gt;读《未来简史》一直都在我的读书计划中，最近终于可以安排上了，本来的计划是先把《人类简史》的英文版先读一遍，再接着读三部曲中的第二部，这样可以像看电影似的接上，因为赫拉利的书观点性很强，《人类简史》的中文版我已经读过一遍，所以不太想再把那些观点再嚼一遍，于是直接在Kindle上开始看《未来简史》，通勤中，飞机上，睡觉前，半个月时间，不知不觉看完了。如同《人类简史》一样，是一本让人手不释卷的好书。看完后，总有一种不吐不快的感觉，因此有了此文。
英文版的封面与中文版不同，醒目的红色大字&amp;quot;Homo Deus&amp;quot;是主标题，而中文版的主标题却是英文版的副标题&amp;quot;A Brief History of Tomorrow&amp;quot;,正好主副标题颠倒，对&amp;quot;Homo Deus&amp;quot;的翻译是&amp;quot;从智人到智神&amp;quot;, 看完全书，感觉还是翻译为&amp;quot;从智人到智神&amp;quot;更为贴切，&amp;quot;未来简史&amp;quot;感觉是病句，当然认为前者更贴切的原因不仅仅是咬文嚼字，而是这个标题才是整本书的主旨——未来会有一个新的脱胎于智人的种族（Homo Deus）诞生，或取代智人的地位，或导致智人灭绝。Homo Deus延续了《人来简史》的风格，或者说延续了赫拉利的写史风格, 宏大的叙事，精炼的语句，几乎是我读过的所有历史类，社会类书籍里面独有的一种，开篇就有惊人之语，至少在我读过的书里面没有遇到类似的论调:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For thousands of years the answer to this question remained unchanged. The same three problems preoccupied the people of twentieth-century China, of medieval India and of ancient Egypt. Famine, plague and war were always at the top of the list. For generation after generation humans have prayed to every god, angel and saint, and have invented countless tools, institutions and social systems – but they continued to die in their millions from starvation, epidemics and violence. Many thinkers and prophets concluded that famine, plague and war must be an integral part of God’s cosmic plan or of our imperfect nature, and nothing short of the end of time would free us from them.&lt;/p&gt;

&lt;p&gt;Yet at the dawn of the third millennium, humanity wakes up to an amazing realisation. Most people rarely think about it, but in the last few decades we have managed to rein in famine, plague and war. Of course, these problems have not been completely solved, but they have been transformed from incomprehensible and uncontrollable forces of nature into manageable challenges.&lt;/p&gt;

&lt;p&gt;Forthe first time in history, more people die today from eating too much than from eating too little; more people die from old age than from infectious diseases; and more people commit suicide than are killed by soldiers, terrorists and criminals combined. In the early twenty-first century, the average human is far more likely to die from bingeing at McDonald’s than from drought, Ebola or an al-Qaeda attack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译提炼下截取的这三个段落:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;饥荒，瘟疫和战争一直是世代困扰智人的三大难题，智人在第三个千年第一次战胜了饥荒，瘟疫和战争，或者说基本控制了这三大难题.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;的确是新颖的观点，第一次发现可以从这个视角来看人类的历史，开篇的这些惊人之语，只是开胃菜，也是论述智神诞生的铺垫，因为当智人战胜了这三大难题后，智人的使命或者说智人未来的福祉会是什么，追求永生还是获取极乐？这个问题明显是一个无限开放，无限发散的问题，整本书就是沿着这条主线展开的，而从智人脱颖而出的智神的诞生也是探寻这个问题过程中导致的结果之一，书中在探寻这个问题的过程中逐步展开更多的命题，抛出振聋发聩，令人耳目一新的论点，让人震惊，叹息，恐惧，并引起深思。&lt;/p&gt;

&lt;p&gt;因为我是差不多半个月的时间陆续读完全书，对书中内容的印象是碎片化的，写下此文时也不是正襟危坐，思绪连贯的行文，而是在手机或电脑上迅速记下一些思绪的片段，着重对一些触动我的部分展开讨论，现遴如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人类有灵魂而动物没有灵魂是错的， 灵魂是不存在的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个论点既不是无神论，也不是唯物主义，而是经过大量的心理学实验的论断，智人从动物中脱颖而出并最终统治这个世界当然不是因为独有的灵魂，而仅仅是因为智人可以想象并编造出这个世界上没有的东西，并因此而为之达成规模无限扩大的合作，这才是智人胜出的关键，之所以这里说到的是智人，而不是人类，是因为一些与智人同源的一些人类分支已经灭绝了，而可怕的事实是灭绝的原因可能与智人直接相关。 乍一看，这个观点仅仅是对上一部《人类简史》中观点的呼应，但书中讨论了很多心理学实验，进一步佐证和加强了这个观点。并且这个观点也将智人拉下了神坛，顺便给人文主义一击。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人文主义(Humanism)不过是另一种宗教而已，数据(Dataism)主义也是&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个不仅对人文主义是沉重一击，也击到了我，人文主义不是人类曙光吗？引领人类摆脱宗教，战胜愚昧。作者有很多理由，多个维度告诉你它仅仅是另一种宗教，这是一个激怒无数人的论调，因为人文主义不单单是一种主义，在当下语境，它是和自由主义，民主，市场化，法律等等的观念产物紧密相连，是目前人类社会的基石。而往往认为它是和宗教完全不同的。看到这个论调的时候我猛然想到汤因比的《历史研究》里曾把社会主义和基督教作类比，但仍旧无法立刻接受把人文主义与基督教作类比。而这个论调更要命的是否定智人的自由意志，而自由意志是所有人类法律，市场，良知，道德的基石。很多抛弃人文主义的人开始倒向数据主义，而数据主义得益于日益飞速发展的计算机互联网技术，凭借惊人的算力，AI的逐步演进，生物技术的突破，俨然成为了另一种宗教。人有丰富的情绪，在人文主义者看来这是人的价值所在，独特之处，而在数据主义者看来不过是一些人体的生化反应而。孰对孰错，孰优孰劣，交给时间吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;智神会导致智人的消亡，如同智人导致了非智人人类的消亡一样&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;智神如何导致智人消亡我们没看到过，但是智人导致其他人类的消亡却有考古和历史证据，而智神们是脱胎于现在的人类，也许通过基因技术，数据特权，悄无声息的崛起。所谓的超人诞生，智人消亡，这不禁让人联想到纳粹主义，想到尼采，但都不能与之同日而语，也许这个过程是和平演进，底层的民众如大梦初醒时一切都已经晚了，因为智神已经出现，无论从智力，体力，智神都完全碾压智人，智人比任何一个时代都绝望，“富不过三代，穷不过三代”，这个规律不再适用，智人厄运不止，最终消亡。这种图景也许是很多普通人无法接受的，但是果真如赫拉利所言，智人又能怎样呢？你只能期盼赫拉利错了。&lt;/p&gt;

&lt;p&gt;当然整本书绝不仅仅是以上的这些观点，只是以上的这些观点最触动我，也能呼应很多以前看过的书，是一次很好的对思维方式和观念结构的SPA，至于书中的一些观点的对错其实并不重要，启发和击中我才是最重要的，其中所提供的一些视角和思考方法也是独一份，独特到我很快要被它安利了，但是我又要保持警惕，不至于陷入&amp;quot;赫拉利主义&amp;quot;。放眼全球，貌似赫拉利在中国最火，似乎我们又狂热的认为如获至宝，就跟很多年前马克思主义被引进时，而事实上赫拉利如美国很多畅销书作家一样，只是提出了一种新的观点和研究成果，既不是真理，也不是终极预言，却引来很多国内互联网大佬和学者的热烈讨论，实属奇观，如果仅是讨论学术，那真是太好了，说明国内思想学术之活跃，如果因为其他，那也是奇观！&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Oct 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//read-homo-deus</link>
        <guid isPermaLink="true">http://longlinht.github.io//read-homo-deus</guid>
      </item>
    
      <item>
        <title>在Flutter中实现一个类似Android中的BottomSheetDialog</title>
        <description>&lt;p&gt;从屏幕底部滑出的这种弹窗实在是太普遍的需求了，所以Flutter不可能不提供，一查文档，果然有一个API直接就可以调出Dialog: showModalBottomSheet, 这个API有很多入参，但是如果不需要对Dialog的外观和行为有特殊的定制需求的话，值传递前两个参数就可以了。 API看起来非常简单，但是我看到网上有些blog文章对这个API的使用是错误的，所以我贴出我实现了上方圆角dialog的代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;void openBottomSheet(context) {
  showModalBottomSheet(
    backgroundColor: Colors.white,
    context: context,
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.only(topLeft: Radius.circular(18), topRight: Radius.circular(18))
  ),

  builder: (builder) {
      return new Container(
        child: Wrap(
          children: &amp;lt;Widget&amp;gt;[
            getListTile(Icons.more, Colors.black45, &amp;quot;More&amp;quot;, context),
            getListTile(Icons.favorite, Colors.pink, &amp;quot;Favourites&amp;quot;, context),
            getListTile(Icons.account_box, Colors.blue, &amp;quot;Profile&amp;quot;, context),
            new Divider(
              thickness: 2.0,
              height: 10.0,
            ),
            getListTile(Icons.exit_to_app, null, &amp;quot;Logout&amp;quot;, context),
          ],
        ),
      );
    },
  );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个圆角的实现，其实可以直接传入&lt;code&gt;backgroundColorback&lt;/code&gt;和&lt;code&gt;shape&lt;/code&gt;参数，不用额外去添加一层i&lt;code&gt;Container&lt;/code&gt;，如果想实现圆角背景，通过&lt;code&gt;Container&lt;/code&gt;也可以实现，就是把&lt;code&gt;backgroundColor&lt;/code&gt;设置成透明，多了一道工序，没必要。背景阴影的效果通过&lt;code&gt;barrierColor&lt;/code&gt;来设置。很简单的一api，如果错误使用，不但不能优雅的实现功能，反而额外做了很多工作，却不能实现预期。看到的几个demo都没有正确使用这个API，所以特意为这个问题做此小记。&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Oct 2020 02:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//bottom-sheet-dialog-in-flutter</link>
        <guid isPermaLink="true">http://longlinht.github.io//bottom-sheet-dialog-in-flutter</guid>
      </item>
    
      <item>
        <title>Kotlin synthetic binding view is null in Fragment</title>
        <description>&lt;p&gt;Kotlin provide a handy and concise way to access views in xml layout from code, it works well, but When I create a subclass of &lt;code&gt;DialogFragment&lt;/code&gt;, in its method &lt;code&gt;onCreateView&lt;/code&gt;, I access synthetic binding view, it seems all is fine, but when run these code, app crash. In logcat, I got this &lt;code&gt;NullPointerException&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Caused by: java.lang.NullPointerException: Attempt to invoke virtual method &amp;#39;android.view.View android.view.View.findViewById(int)&amp;#39; on a null object reference&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;#39;m sure synthetic statement is imported and view id is right, it confused me a bit. So I Google Kotlin synthetic binding view related web pages, finally I found a solution:&lt;/p&gt;

&lt;p&gt;Just move accessing syntheic binding view statement from &lt;code&gt;onCreateView&lt;/code&gt; to &lt;code&gt;onViewCreated&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The problem is that I am accessing it too soon, When I delay the chance to access view, all works well. Magic! But it’s nothing magical, if you decompile the bytecode (By going toTools -&amp;gt; Kotlin -&amp;gt; Show Kotlin Bytecode and then selecting Decompile in the pane) and take a look at the generated java class, you’ll see that all it does is call findViewById() for us. Although this is a simple problem, but it is useful to record it.&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2020 02:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//kotlin-synthetic-view-binding-view-is-null-in-fragment</link>
        <guid isPermaLink="true">http://longlinht.github.io//kotlin-synthetic-view-binding-view-is-null-in-fragment</guid>
      </item>
    
      <item>
        <title>Kotlin中的&quot;静态&quot; 方法和域</title>
        <description>&lt;p&gt;最近开始尝试在现有的工程中使用Kotlin，刚开始使用时感觉语法简洁，代码量也少了很多，语法层面的防空，可以直接访问布局控件这些特性，都让人耳目一新，但是当我要定义静态方法和静态类时，不爽的体验一下子就上来了，所以通过此文来一探Kotlin&amp;quot;静态&amp;quot; 的究竟。
  先来看静态方法， 很遗憾，Kotlin中没有&lt;code&gt;static&lt;/code&gt;关键字，需要将静态方法放在&lt;code&gt;companion object&lt;/code&gt;中的代码块中，因此：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo {
  public static int a() { return 1; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就变成了这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo {
  companion object {
     fun a() : Int = 1
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在Kotlin代码中这样使用该类:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Foo.a();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Java代码中:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Foo.Companion.a();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你不喜欢使用&lt;code&gt;Companion&lt;/code&gt;, 你可以对该静态方法添加&lt;code&gt;@JvmStatic&lt;/code&gt;注解:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo {
  companion object {
    @JvmStatic
    fun a() : Int = 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以命名你的&lt;code&gt;companion&lt;/code&gt;类:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo {
  companion object Blah {
    fun a() : Int = 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以这样调用:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Foo.Blah.a() 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后来看静态域， 比起静态方法，静态域的情况有所不同，虽然也可以这样定义:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Foo {
  companion object {
    val MY_CONSTANT = &amp;quot;MY_CONSTANT&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是会自动为&lt;code&gt;MY_CONSTANT&lt;/code&gt;生成getter和setter方法，相当于实例域访问，开销会比静态方法大，不推荐此种定义方法。可以这样定义:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;object Foo {
    const val MY_CONSTANT = &amp;quot;MY_CONSTANT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面定义的object Foo可以全局访问:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Foo.MY_CONSTANT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而companion object中定义的&lt;code&gt;const var MY_CONSTANT&lt;/code&gt;是不可以全局访问的。 当然了，静态域为了避免访问时的Companion，也可以在定义时添加&lt;code&gt;@StaticField&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;到此Kotlin中&lt;code&gt;静态&lt;/code&gt;相关的部分基本已经覆盖到了，个人觉得这个companion object不是什么好的设计，远没有Java的static关键字来的简洁和表达力。&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Sep 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//static-method-in-kotlin</link>
        <guid isPermaLink="true">http://longlinht.github.io//static-method-in-kotlin</guid>
      </item>
    
      <item>
        <title>基于DrawerLayout实现直播抽屉</title>
        <description>&lt;p&gt;直播间里右侧的滑出抽屉现在几乎成了主流直播的标配，无论是映客还是Bigo，都很早就上线了抽屉。我所在的这个产品最近也要上同样的功能，因此需要简单实现一个。
  要实现一个简单的侧滑抽屉，最先想到的就是直接使用&lt;code&gt;DrawerLayout&lt;/code&gt;，但是无法满足产品的一个手势要求: 在屏幕任何位置都可以调出和收起抽屉。&lt;code&gt;DrawerLayout&lt;/code&gt; 的默认行为是只能从屏幕边缘调出。因此需要改变DrawerLayout的默认行为，使期能够从屏幕任何位置调出，这就需要通过反射修改drawerlayout的edgesize属性，因为drawerlayout还可以通过长按调出，我们的产品需求并不需要这个行为，因此也需要屏蔽掉，通过一个静态方法来统一实现：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public static void setDrawerLeftEdgeSize(DrawerLayout drawerLayout,
                                             float percent) {
    if (drawerLayout == null)
        return;
    try {
        //获取 ViewDragHelper，更改其 edgeSizeField 为 displayWidthPercentage*屏幕大小
        Field rightDraggerField = drawerLayout.getClass().getSuperclass().getDeclaredField(&amp;quot;mRightDragger&amp;quot;);
        rightDraggerField.setAccessible(true);
        ViewDragHelper rightDragger = (ViewDragHelper) rightDraggerField.get(drawerLayout);

        Field edgeSizeField = rightDragger.getClass().getDeclaredField(&amp;quot;mEdgeSize&amp;quot;);
        edgeSizeField.setAccessible(true);
        int edgeSize = edgeSizeField.getInt(rightDragger);

        edgeSizeField.setInt(rightDragger, Math.max(edgeSize, (int)(UIUtils.getScreenWidth() * percent)));

        //获取 Layout 的 ViewDragCallBack 实例“mLeftCallback”
        //更改其属性 mPeekRunnable
        Field rightCallbackField = drawerLayout.getClass().getSuperclass().getDeclaredField(&amp;quot;mRightCallback&amp;quot;);
        rightCallbackField.setAccessible(true);

        //因为无法直接访问私有内部类，所以该私有内部类实现的接口非常重要，通过多态的方式获取实例
        ViewDragHelper.Callback leftCallback = (ViewDragHelper.Callback) rightCallbackField.get(drawerLayout);

        Field peekRunnableField = leftCallback.getClass().getDeclaredField(&amp;quot;mPeekRunnable&amp;quot;);
        peekRunnableField.setAccessible(true);
        Runnable nullRunnable = new Runnable() {
            @Override
            public void run() {

            }
        };
        peekRunnableField.set(leftCallback, nullRunnable);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决了edgsize和长按的问题后，马上又面临一个净屏页和抽屉的手势滑动冲突问题，并且还要注意两个UI元素的层级，基本的解决思路是根据滑动的方向和净屏页的状态在&lt;code&gt;DrawerLayout&lt;/code&gt;子类的onInterceptTouchEvent里来处理事件拦截，改变&lt;code&gt;DrawerLayout&lt;/code&gt;的默认行为，净屏页的逻辑不变，只向&lt;code&gt;DrawerLayout&lt;/code&gt;提供状态的get方法，具体实现如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
public boolean onInterceptTouchEvent(MotionEvent ev){
    Log.d(&amp;quot;drawerLayout&amp;quot;, &amp;quot;onInterceptTouchEvent, action: &amp;quot;
            + ev.getAction() + &amp;quot; x= &amp;quot; + ev.getX() + &amp;quot; y=&amp;quot; + ev.getY());

    boolean drawerOpen = this.isDrawerOpen(Gravity.RIGHT);
    boolean pureMode = contentView.isPureMode();

    switch(ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mLastX = ev.getX();
            mLastY = ev.getY();

            /*
            final View touchedView = findTopChildUnder((int) mLastX, (int) mLastY);
            boolean isContent = isContentView(touchedView);


            if (!drawerOpen &amp;amp;&amp;amp; isContent) {
                return false;
            }
              */

            break;
        case MotionEvent.ACTION_MOVE:
            float dx = ev.getX() - mLastX;
            float dy = ev.getY() - mLastY;

            boolean horizontal = Math.abs(dx) &amp;gt; Math.abs(dy);

            if (!pureMode &amp;amp;&amp;amp; dx &amp;lt; 0 &amp;amp;&amp;amp; horizontal) {

            } else if(!pureMode &amp;amp;&amp;amp; dx &amp;gt; 0 &amp;amp;&amp;amp; drawerOpen &amp;amp;&amp;amp; horizontal){

            } else {
                return false;
            }

            break;
        default:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样用最小的开发成本完成了产品的需求，实现了主流直播产品的抽屉功能。唯一的小瑕疵是直播间上下滑动时不能自动收起抽屉，这个因为并不是产品很在意的点，再加上产品需求紧急，就没有深究。当然了，这个抽屉功能其实可以抽取出来做成一个通用的抽屉，提供不同的接口来满足定制要求。&lt;/p&gt;

&lt;p&gt;tips：&lt;code&gt;DrawerLayout&lt;/code&gt;显示区域穿透的问题可以这样解决：
将显示区域的clickable属性设置为true。&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2020 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//implement-live-drawer</link>
        <guid isPermaLink="true">http://longlinht.github.io//implement-live-drawer</guid>
      </item>
    
  </channel>
</rss>