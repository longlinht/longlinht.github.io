<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>与机器，人，神共舞</title>
    <description>编程，读书，思考，旅行，与机器对话，与人交谈，对神发问，探索，体验人生美丽的风景</description>
    <link>http://longlinht.github.io/</link>
    <atom:link href="http://longlinht.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>ImageSpan的定制使用</title>
        <description>&lt;p&gt;最近在做一个具体业务需求时，为了实现UI设计的要求，需要实现在同一段文字中，有一段文字是需要有形状的背景色，有一段文字中还有网络图片的插入，如果要达到这两个要求，简单的使用SpannableStringBuilder肯定是达不到要求的，虽然SpannableStringBuilder可以设置背景色，但是并不能绘制形状，说白了就是只能设置颜色，不能设置文字的背景图片。想要在文字中插入图片，可以直接使用ImageSpan，但是ImageSpan并不能加载网络图片。因此这种简单的使用方式都是行不通的，需要考虑去定制ImageSpan实现我们特殊的要求。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现给同一段文字的一部分文字区域设置背景图片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个功能的实现还是要继承ImageSpan，将我们的背景图片传进去，并且override ImageSpan的draw方法，根据对文字区域的测量，分别绘制出背景和文字。实现代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// BgImageSpan

public class BgImageSpan extends ImageSpan {

    private int textSize = 20;
    private int color = Color.GRAY;
    private TextView mTextView;
    static float textboundhight;
    static float textY;
    String mText;

    public BgImageSpan(Drawable d, TextView tv, String text) {
        super(d);
        mTextView = tv;
        mText = text;
        textSize = (int) mTextView.getTextSize();
    }


    @Override
    public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y,
                     int bottom, Paint paint) {

        String str = mText;
        Rect bounds = new Rect();
        paint.setTextSize(textSize);
        paint.getTextBounds(str, 0, str.length(), bounds);
        int textHeight = bounds.height();
        int textWidth = bounds.width();

        getDrawable().setBounds(0, top, (int)(bounds.width() * 1.3) , bottom);
        super.draw(canvas, str, start, end, x, top, y, bottom, paint);
        paint.setColor(mTextView.getTextColors().getDefaultColor());
        paint.setTypeface(Typeface.create(&amp;quot;normal&amp;quot;, Typeface.NORMAL));

        Rect bounds1 = getDrawable().getBounds();

        float textX = x + bounds1.width() / 2 - bounds.width() / 2;
        if (textboundhight == 0) {
            textboundhight = bounds.height();
            textY = (bounds1.height()) / 2 + textboundhight / 2;
        }
        canvas.drawText(str, textX, textY, paint);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方法和ImageSpan并没有什么区别:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;String username = &amp;quot;用户名：&amp;quot;;
String message = &amp;quot;哈哈，我是一个天才&amp;quot;;

SpannableStringBuilder ssb = new SpannableStringBuilder(username);
ssb.append(message);

Rect bounds = new Rect();
Paint paint = mContent.getPaint();
paint.getTextBounds(username, 0, username.length(), bounds);

Drawable bgDrawable = getDrawable(R.drawable.round_rect);
bgDrawable.setBounds(0, 0, (int)(bounds.width() * 1.3), bounds.height());

ImageSpan nameBgSpan = new BgImageSpan(bgDrawable, mContent, username);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

ForegroundColorSpan contentColorSpan = new ForegroundColorSpan(Color.parseColor(&amp;quot;#ffc800&amp;quot;));
ssb.setSpan(contentColorSpan, username.length(), username.length() + message.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

mContent.setText(ssb);
mContent.postInvalidate();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用代码需要注意一下几点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;传给BgImageSpan的Drawable需要设置Bounds，然后再传进去，否则可能会出现字符重叠的问题。&lt;/li&gt;
&lt;li&gt;如果设置了Bounds还有字符重叠错乱的问题，可以调用TextView的postInvalidate重绘。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;第二种实现同一段文字的一部分文字区域设置背景图片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种实现的思路很简单，就是通过inflate一个单独的布局，然后用这个inflate好的view生成图片，然后传给一个ImageSpan，即可完成，代码如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;View view = LayoutInflater.from(this).inflate(R.layout.container, null);
TextView textView = view.findViewById(R.id.tv_value);
textView.setText(username);

view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),
        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
view.buildDrawingCache();
Bitmap bitmap = view.getDrawingCache();

ImageSpan nameBgSpan = new ImageSpan(this, bitmap);
ssb.setSpan(nameBgSpan, 0, username.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;实现一段文字中插入网络图片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;插入网络图片和插入本地图片其实没有本质区别，要插入网络图片，就得先获取到网络图片后再设置到ImageSpan中去。代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;String url = &amp;quot;http://img2.imgtn.bdimg.com/it/u=1467875646,1039972052&amp;amp;fm=26&amp;amp;gp=0.jpg&amp;quot;;
RequestOptions options = new RequestOptions()
        .dontAnimate()
        .diskCacheStrategy(DiskCacheStrategy.NONE);

Glide.with(this)
        .load(url)
        .apply(options)
        .into(new CustomTarget&amp;lt;Drawable&amp;gt;() {
            @Override
            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&amp;lt;? super Drawable&amp;gt; transition) {
                if (resource instanceof BitmapDrawable) {
                    resource.setBounds(0, 0, 50, 50);

                    ImageSpan iconSpan = new ImageSpan(resource);
                    ssb.setSpan(iconSpan, username.length(), username.length() + 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

                    mContent.setText(ssb);
                    mContent.postInvalidate();
                }
            }

            @Override
            public void onLoadCleared(@Nullable Drawable placeholder) {

            }
        });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用起来需要注意的问题和上面的BgImageSpan相同，也是先要设置Drawable的Bounds。&lt;/p&gt;

&lt;p&gt;虽然这两个实现看起来也没有什么难度，但是还是需要把这种解决过的，不那么常规的方法记录下来，以后遇到同样的问题可节省很多调研和调试的事件。&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Oct 2019 04:54:12 +0800</pubDate>
        <link>http://longlinht.github.io//custom-image-span</link>
        <guid isPermaLink="true">http://longlinht.github.io//custom-image-span</guid>
      </item>
    
      <item>
        <title>修复VideoView引起的内存泄露小计</title>
        <description>&lt;p&gt;最近写了非常简单的新手引导视频页面，逻辑很简单，就是新手用户在第一次使用App时可以点击引导视频入口，然后进入一个视频播放页面，为了快速实现功能，就直接使用了VideoView，从需求开发到交付也都没什么问题，需求上线后我打开LeakCanary，想观察下最近有没有新增的内存泄露，竟然发现这个视频页面竟然泄露了。排查了一圈也没有发现有什么会阻止Activity销毁。但是LeakCanary打出了引用链，发现和VideoView有关，通过Google发现，竟然是VideoView自身的bug！这种情况也不是第一次遇见，那也得解决啊，所以开始想办法。&lt;/p&gt;

&lt;p&gt;首先显明确是谁导致了Activity的销毁，通过查看VideoView的源码，发现罪魁祸首是AudioManager，它可能会长期持有Context(即泄露的Activity)。很明显是因为生命周期不一致导致的泄露，因此最先想到的就是在创建VideoView时不要传Activity的Context，传给它ApplicationContext。当然了，在布局中创建的VideoView传入的就是Activity的Context，所以需要用代码动态创建:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mVideoView = new VideoView(getApplicationContext());
RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.WRAP_CONTENT);

layoutParams.addRule(RelativeLayout.CENTER_IN_PARENT);
mContainer.addView(mVideoView, layoutParams);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样修改后还是会有内存泄露，只是引用链变了，需要在Activity的onDestroy回调中做一些处理&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@Override
protected void onDestroy() {
  super.onDestroy();

  if (mVideoView != null) {
      mVideoView.stopPlayback();
      mVideoView.setOnCompletionListener(null);
      mVideoView.setOnPreparedListener(null);
      mVideoView.setOnErrorListener(null);
      mVideoView = null;
  }

  if (mContainer != null) {
      mContainer.removeAllViews();
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上解决办法需要注意三点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给VideoView设置的Listener都要分别置空，否则仍然会泄露&lt;/li&gt;
&lt;li&gt;VideoView的父容器要删掉VideoView，光置空VideoView不够&lt;/li&gt;
&lt;li&gt;需设置VideoView的OnErrorListener且返回true，防止弹出弹窗使用ApplicationContext导致崩溃 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传递ApplicationContext还有人提出另一种方法，但是我test发现没有效果，这种方法我也贴出来:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// Override Activity的attachBaseContext的行为
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(new ContextWrapper(newBase){
        @Override
        public Object getSystemService(String name) {
            if(Context.AUDIO_SERVICE.equals(name)){
                return getApplicationContext().getSystemService(name);
            }
            return super.getSystemService(name);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;去规避系统API的bug真是很烦人的一件事，既不优雅，也不安全！&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Sep 2019 02:30:12 +0800</pubDate>
        <link>http://longlinht.github.io//fix-video-view-leak</link>
        <guid isPermaLink="true">http://longlinht.github.io//fix-video-view-leak</guid>
      </item>
    
      <item>
        <title>Parcelable vs Serializable</title>
        <description>&lt;p&gt;在实际的Android开发中Serializable和Parcelable我们都会用到，只是需要区分使用场景。刚开始遇到这两个接口的时候比较疑惑，貌似都是用来做序列化的，虽然能分得清什么时候用哪个，但是对这两个接口并没有清晰的认识，要是冷不丁的问我这俩有什么区别，可能还无法清晰的界定和阐述。因此有必要用一篇文章来彻底捋清这些东西。&lt;/p&gt;

&lt;h3&gt;相同点&lt;/h3&gt;

&lt;p&gt;相同点其实很明显，主要有如下两点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;都可以序列化反序列化&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;都可以通过Intent传递&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;区别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Serializable是Java API，Parcelable是Android SDK API，设计目的不同。Serializable是一个通用的序列化机制，通过将文件保存到本地文件、网络流等实现便数据的传递，这种数据传递不仅可以在单个程序中进行，也可以在两个不同的程序中进行；Parcelable是Android SDK API,为了在同个程序的不同组件之间和不同程序（AIDL）之间高效的传输数据，是通过IBinder通信的消息的载体。从设计目的上可以看出Parcelable就是为了Android高效传输数据而生的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Serializable序列化过程使用反射机制，速度慢，且产生很多临时对象，容易触发GC；Parcelable是直接在内存中读写的，自已实现封送和解封（marshalled &amp;amp;unmarshalled）操作，将一个完整的对象分解成Intent所支持的数据类型，不需要使用反射，所以Parcelable具有效率高，内存开销小的优点。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Serializable是通用的序列化机制，将数据存储在磁盘，可以做到有限持久化保存，文件的生命周期不受程序影响，Parcelable的序列化操作完全由底层实现，不同版本的Android是实现方式可能不相同，所以不能进行持久化存储。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用场景不同。Parcelable 是 Android 中的序列化方式，因此更适合于 Android 平台上，它的缺点是使用起来稍微麻烦点，但它的效率很高，这是 Android 推荐的序列化方式，因此我们要首选 Parcelable。但 Serializable 也不是在 Android 上无用武之地，下面两种情况就发日常适合 Serializable：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;需要将对象序列化到设备；&lt;/li&gt;
&lt;li&gt;对象序列化后需要网络传输。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样一一列举了两者的相同点和区别，对两者的认识清晰了很多！积跬步，共勉！&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Sep 2019 02:30:12 +0800</pubDate>
        <link>http://longlinht.github.io//serializable-vs-parcelable</link>
        <guid isPermaLink="true">http://longlinht.github.io//serializable-vs-parcelable</guid>
      </item>
    
      <item>
        <title>修复崩溃ANR小记</title>
        <description>&lt;p&gt;最近一直在集中精力解决Bugly的崩溃，到现在基本上把可以解决的已经都解决完了，剩下的都是一些特定系统版本和特定机型的崩溃，暂时没有太好的思路去排查，其中系统4.4版本的崩溃尤为特殊，有几个崩溃几乎都只出现在4.4版本的机器上，这些特定版本和特定机型的问题暂不谈论，下面来小结一下最近成功解决过的一些崩溃和ANR。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;复写父类方法要当心，注意父类的方法约定(崩溃)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)
java.lang.NullPointerException
Attempt to invoke virtual method &amp;#39;android.graphics.Rect android.graphics.drawable.Drawable.getBounds()&amp;#39; on a null object reference
1 android.text.style.DynamicDrawableSpan.getSize(DynamicDrawableSpan.java:78)
2 android.text.TextLine.handleReplacement(TextLine.java:813)
3 android.text.TextLine.handleRun(TextLine.java:908)
4 android.text.TextLine.measureRun(TextLine.java:387)
5 android.text.TextLine.measure(TextLine.java:277)

...

暂略
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;堆栈太长，底下的暂略，这个崩溃乍一看，没啥线索，崩到了系统类DynamicDrawableSpan，然后就看工程中有没有用到DynamicDrawableSpan，果然发现我们的类EmojiTextSpan继承了这个类，那可以缩小问题范围了，从崩溃处逆推调用栈，可以发现我们的类复写了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private Drawable getCachedDrawable() {
    if (mDrawableRef == null || mDrawableRef.get() == null) {
        mDrawableRef = new WeakReference&amp;lt;Drawable&amp;gt;(getDrawable());
    }
    return mDrawableRef.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而DynamicDrawableSpan的方法实现如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private Drawable getCachedDrawable() {
    WeakReference&amp;lt;Drawable&amp;gt; wr = mDrawableRef;
    Drawable d = null;

    if (wr != null) {
        d = wr.get();
    }

    if (d == null) {
        d = getDrawable();
        mDrawableRef = new WeakReference&amp;lt;Drawable&amp;gt;(d);
    }

    return d;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显我们的类做了一个蠢事，其实不用去复写父类的方法，反而不会有问题，这个问题的根本原因是我们没有详细了解这个类，至少是没有了解这个方法的约定。只要删除我们的复写方法即可解决问题。当然，系统代码也不严谨，drawable在调用getBounds方法时没有判空。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主线程切不可进行IO操作(ANR)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class GameBgmService extends Service {

    ...
    ...

    @Override
    public void onCreate() {
        super.onCreate();
        ...
        ...

        PathUtil.findAllKV(BGM_PATH, mBgmMap);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据ANR的堆栈，可以追踪到是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;PathUtil.findAllKV(BGM_PATH, mBgmMap);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的调用导致了ANR，而这个方法是一个典型的IO操作，而这种操作不应该在系统组件的生命周期方法里调用。解决方法也很简单，就是将这种操作放到子线程去。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有时需要频繁IO操作，可考虑建立内存缓存，避免ANR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个ANR和上面的类似，也是要进行一个IO操作，并且和上面不一样的是，这个操作需要同步进行，不能异步，因此我们采取建立内存缓存的方式来解决。这个IO操作其实是通过解析文件中的json，创建出一个对象列表返回，而这个操作在App进入首页的时候就在子线程中操作过一次，但是并没有在这个时机去建立内存缓存，因此这个问题的最简单解决方式就是建立内存缓存，在之前需要IO操作的地方直接操作内存，并且保证文件和内存的内容一致即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用RxJava需要注意Backpressure(崩溃)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)

io.reactivex.exceptions.MissingBackpressureException

Can&amp;#39;t deliver value 9440 due to lack of requests

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:io.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | io.reactivex.exceptions.MissingBackpressureException: Can&amp;#39;t deliver value 9440 due to lack of requests
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 io.reactivex.exceptions.MissingBackpressureException:Can&amp;#39;t deliver value 9440 due to lack of requests
6 io.reactivex.internal.operators.flowable.FlowableIntervalRange$IntervalRangeSubscriber.run(FlowableIntervalRange.java:117)
7 io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask.run(ScheduledDirectPeriodicTask.java:38)
8 java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:458)
9 java.util.concurrent.FutureTask.runAndReset(FutureTask.java:307)
10 java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:302)
11 java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
12 java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
13 java.lang.Thread.run(Thread.java:784)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个崩溃根据堆栈可追溯到RxJava中的intervalRange操作符，工程中有多处使用，找到一个典型使用:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private void startCountDown(String order, String text, long time) {
    if (time &amp;gt; 0) {
        if (mDisposable != null &amp;amp;&amp;amp; !mDisposable.isDisposed()) {
            mDisposable.dispose();
            mDisposable = null;
        }
        mDisposable = Flowable.intervalRange(0, time + 1, 0, 1, TimeUnit.SECONDS)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Consumer&amp;lt;Long&amp;gt;() {
                    @Override
                    public void accept(Long aLong) throws Exception {
                        if (mKillerAreaTop != null) {
                            if (aLong == time) {
                                mKillerAreaTop.setText(String.format(&amp;quot;【%s号】%s&amp;quot;, order, text));
                            } else {
                                mKillerAreaTop.setText(String.format(Locale.CHINA,
                                        &amp;quot;【%s号】%s(%d)&amp;quot;, order, text, time - aLong));
                            }
                        }
                    }
                });

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个问题RxJava在GitHub上的issue已解决，添加流量控制，在调用intervalRange后紧接着调用onBackpressDrop即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RxJava和ButterKnife混用时先clear disposable后unbind&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# main(1)

java.lang.NullPointerException

Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference

1 io.liuliu.music.repair.CrashUtil$Up1Throwable:java.lang.NullPointerException: Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference
2 io.liuliu.music.repair.CrashUtil.lambda$initRxCrash$0(CrashUtil.java:160)
3 ......
4 Caused by:
5 java.lang.NullPointerException:Attempt to invoke virtual method &amp;#39;void io.liuliu.music.widget.resource.ResourceView.setVisibility(int)&amp;#39; on a null object reference
6 io.liuliu.music.hall.hall.widget.UserInfoView$1.onStartDownload(UserInfoView.java:159)
7 io.liuliu.music.resource.GoodsResProvider.lambda$startEffect$3(GoodsResProvider.java:121)
8 io.liuliu.music.resource.-$$Lambda$GoodsResProvider$o_C6H-o_OQTCEa45A-3wRHNQygg.accept(Unknown Source:10)
9 io.reactivex.internal.observers.ConsumerSingleObserver.onSuccess(ConsumerSingleObserver.java:62)

......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看似一个很普通的一个崩溃，对这个View对象使用前判空就完事了，但是实际问题没那么简单，很多页面使用了这个机制，难道要每个页面的每个View在使用前都要判空吗？必须从机制上保证在RxJava的异步回调中View对象不为空，检查代码后发现的确是有这个保证的，就是在View要销毁时clear掉RxJava的异步回调，问题出在先后顺序上，写代码时并没有注意到这个先后顺序，unbind都在clear disposable之前，导致了这种崩溃有概率发生。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fragment has not been attached yet 崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个崩溃时因为Fragmegnt还没有Attach到Activity就调用了getChildFragmnetManager()导致，可通过添加isAdded判断，或在attach和detach时加一个标志来判断当前fragment的状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多线程没有同步导致的崩溃&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种问题比较常见了，虽然一个移动端App不需要很大量的并发，但是多个线程同时存在，并且操作共享变量的情况也不少，在这次修复崩溃的过程中就遇到很多例，都是因为对共享变量没有保护，导致其中一个线程已经把变量置空，而其他线程还在dereference这个变量而导致崩溃。这类问题，可根据实际情况采取不同的同步策略。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在UI线程中start，reset，release MediaPlayer导致的ANR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只要用到MediaPlayer的工程可能都避免不了这个问题吧，最好的解决办法就是将这些操作都放在一个非UI线程里，而把一些事件回调调度回UI线程，这样既不会有ANR，也将MediaPlayer的使用变得比较简单。典型的做法是对MediaPlayer进行封装，使用两个Handler和一个HandlerThread，将对MediaPlayer的操作都放在HandlerThread中，事件回调都通过其中一个Handler调度回主线程。&lt;/p&gt;

&lt;p&gt;以上就是最近解决的一些典型的崩溃和ANR，作此小计，积跬步。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Sep 2019 02:30:12 +0800</pubDate>
        <link>http://longlinht.github.io//fix-crash-and-anr</link>
        <guid isPermaLink="true">http://longlinht.github.io//fix-crash-and-anr</guid>
      </item>
    
      <item>
        <title>Android防空指南</title>
        <description>&lt;p&gt;最近集中进行了一段时间降低公司App崩溃率的工作，现在App的崩溃率控制在了万一与万三之间，整体来说还比较顺利，有必要将其中的方法和经验做一个沉淀。由于空指针异常导致的崩溃对App整体的崩溃率贡献巨大，日常的崩溃修复总是少不了几个空指针异常，虽然明显的空指针异常修复很容易，但是发出去的版本会持续崩溃，影响留存和体验，因此在积极修复空指针崩溃的同时也需要未雨绸缪，在开发阶段就把空指针拒之门外，对于事前防空的讨论非常多，也有大量的文章总结和分析这件事情，此文可能会提及这些讨论，但是主要还是总结我实践过的一些防空措施：&lt;/p&gt;

&lt;h3&gt;编写不空的代码&lt;/h3&gt;

&lt;p&gt;这个是基础，也是第一道防线，如果这一步没有做好，后面的一些措施可能负担更重。编写不空的代码其实就是要求我们在编写具体的方法和接口时尽量保证不返回null值，以及一些编程语言特性来避免空指针，也就是从根源上杜绝client代码不经意间去dereference一个空对象，具体的办法，或者说一些规约如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于数组，比如Point，返回空对象，return new Point[0];&lt;/li&gt;
&lt;li&gt;对于容器，比如ArraryList,返回空对象。如果需要泛型支持，retrun Collections.emptyList(); 如果不需要泛型支持，则 return Collections.EMPTY_LIST;&lt;/li&gt;
&lt;li&gt;对于字符串String,返回空对象， return “”; 而不是return null;&lt;/li&gt;
&lt;li&gt;这一条用语言不好表达，直接看代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// wrong way - may cause NullPointerException
if (unknownObj.equals(&amp;quot;unknownObj&amp;quot;)) {
}
// right way - avoid NPE even if unknownObj is null
if (&amp;quot;unknownObj&amp;quot;.equals(unknownObj) {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;更加偏好使用valueOf()，而不是toString()&lt;/li&gt;
&lt;li&gt;避免没有必要的boxing和unboxing&lt;/li&gt;
&lt;li&gt;遵守约定，定义有意义的default(初始)对象&lt;/li&gt;
&lt;li&gt;如果必须返回null值，则用@Nullable注解标注，并在Android Studio中打开此类注解的警告开关，如遇警告，积极修复此类警告后再继续编码。&lt;/li&gt;
&lt;li&gt;进行双重入参校验&lt;/li&gt;
&lt;li&gt;使用Java8新特性，Optional&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些措施需要在代码编写时真正去遵守和实践，长期坚持下来会有不错的效果。如果以上措施是事前，那下面的措施就算是事后防空屏障了。&lt;/p&gt;

&lt;h3&gt;通过静态检测工具检查编译阶段代码&lt;/h3&gt;

&lt;p&gt;在不胜其烦的修复了很多Bugly上的空指针以后，我决定一定要找出一个能在编译阶段就能发现空指针风险的办法，于是就想到了通过静态代码检测工具来做这个事情。最先想到的就是findbugs，还找到了一个叫SpotBug的插件，但是这两个插件都没有针对性，毕竟我最优先要解决的是空指针异常的问题。又开始重新找寻，最后找到了由Uber公司研发的Nullaway检查器，它需要配合ErrorProne插件一起使用。因为Nullaway在Gradle里的配置，github上的README有点语焉不详，至少下面两个问题就很让人疑惑:
* 那些配置语句到底写在project的build.gradle文件里还是app下的build.gradle？ （当然如果你的工程只有一个app模块的话不存在这个问题)
* 在多模块的情况下是否可以统一在project的build.gradle文件里配置，还是需要在每个模块里配置一遍？&lt;/p&gt;

&lt;p&gt;所以我决定记录下我的采坑过程:  &lt;/p&gt;

&lt;h4&gt;配置ErrorProne插件和Nullaway检查器&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//build.gradle

buildscript {
    dependencies {
        classpath deps.gradlePlugin
        classpath deps.butterKnife
        classpath deps.wallePlugin
        classpath deps.sensorsPlugin

        classpath deps.realmPlugin

        // 配置ErrorProne插件和Nullaway检查器
        classpath deps.spotBugPlugin
        classpath deps.errorPronePlugin
    }
    repositories {
        google()
        jcenter()
    }
}


// check.gradle

apply plugin: &amp;#39;net.ltgt.errorprone&amp;#39;
tasks.withType(JavaCompile) {
    // remove the if condition if you want to run NullAway on test code
    if (!name.toLowerCase().contains(&amp;quot;test&amp;quot;)) {
        // remove &amp;quot;-Xep:NullAway:ERROR&amp;quot; to have NullAway only emit warnings
        options.compilerArgs += [&amp;quot;-Xep:NullAway:WARN&amp;quot;,
                                 //&amp;quot;-XepAllErrorsAsWarnings&amp;quot;,
                                 &amp;quot;-XepExcludedPaths:.*/build/generated/.*&amp;quot;,
                                 &amp;quot;-Xep:UnusedVariable:OFF&amp;quot;,
                                 &amp;quot;-Xep:UnusedMethod:OFF&amp;quot;,
                                 &amp;quot;-Xep:UnnecessaryParentheses:OFF&amp;quot;,
                                 &amp;quot;-Xep:CatchAndPrintStackTrace:OFF&amp;quot;,
                                 &amp;quot;-Xep:DefaultCharset:OFF&amp;quot;,
                                 &amp;quot;-Xep:JdkObsolete:OFF&amp;quot;,
                                 &amp;quot;-Xep:ClassCanBeStatic:OFF&amp;quot;,
                                 &amp;quot;-Xep:MissingOverride:OFF&amp;quot;,
                                 &amp;quot;-Xep:FragmentNotInstantiable:OFF&amp;quot;,
                                 &amp;quot;-Xep:VariableNameSameAsType:OFF&amp;quot;,
                                 &amp;quot;-Xep:FallThrough:OFF&amp;quot;,
                                 &amp;quot;-Xep:FutureReturnValueIgnored:OFF&amp;quot;,
                                 &amp;quot;-Xep:OperatorPrecedence:OFF&amp;quot;,
                                 &amp;quot;-Xep:UndefinedEquals:OFF&amp;quot;,
                                 &amp;quot;-Xep:RxReturnValueIgnored:OFF&amp;quot;,
                                 &amp;quot;-Xep:StringSplitter:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsHashCode:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsGetClass:OFF&amp;quot;,
                                 &amp;quot;-Xep:ComplexBooleanConstant:OFF&amp;quot;,
                                 &amp;quot;-Xep:DoubleBraceInitialization:OFF&amp;quot;,
                                 &amp;quot;-Xep:InconsistentCapitalization:OFF&amp;quot;,
                                 &amp;quot;-Xep:HidingField:OFF&amp;quot;,
                                 &amp;quot;-Xep:EqualsUnsafeCast:OFF&amp;quot;,
                                 &amp;quot;-XepOpt:NullAway:AnnotatedPackages=com.inyuapp,io.liuliu&amp;quot;]
    }
}

// 因为我们的工程有很多个模块，因此我在每个module的build.gradle如下配置:

apply plugin: &amp;#39;com.android.library&amp;#39;
apply from: &amp;#39;../../check.gradle&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个配置之后基本就可以正常使用了，但是还是需要特别注意几个问题，也是我在集成的过程中踩过的坑:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在project的build.gradle中统一配置的方式会报Nullaway找不到的问题，这个目前无解，就只能通过在每个module分别配置，不过可以通过统一写一个check.gradle，在每个module的build.gradle中apply，如上&lt;/li&gt;
&lt;li&gt;可以配置ErrorProne每个检查器的编译错误级别，分别有ERROR，WARN，OFF，如果某个检查器配置为ERROR级别，那么此检查器如果在代码中发现此类问题，就会导致整个build失败，如果对特定的错误很关注，可设为ERROR级别，限制处理完此类问题才能build成功。&lt;/li&gt;
&lt;li&gt;Nullaway检查器需要配置要检查的包，多个源代码包可通过”,&amp;quot;分割&lt;/li&gt;
&lt;li&gt;Nullaway的检查都是基于@Nullable注解，因此在类中的字段，方法返回值，入参上适当使用@Nullable才能使Nullaway检查器很好工作&lt;/li&gt;
&lt;li&gt;此类代码不会通过Nullaway检查&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (ControllerHelper.getTopLineModel() != null) {
    ControllerHelper.getTopLineModel().setUserLifeShow(false);
    ControllerHelper.getTopLineModel().setCoinNumberShow(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在开启了ErrorProne和Nullable检查器后，公司的工程出现了大量无法通过检查器的代码，出现问题最多的错误如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;dereferenced expression is @Nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而此类错误就是很多Bugly上空指针异常的罪魁祸首，需重点排查。&lt;/p&gt;

&lt;p&gt;实际上Nullaway可以检查很多情况的问题，Nullaway的文档显示有诸如以下致空的情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dereferenced expression is @Nullable&lt;/li&gt;
&lt;li&gt;returning @Nullable expression from method with @NonNull return type&lt;/li&gt;
&lt;li&gt;passing @Nullable parameter where @NonNull is required&lt;/li&gt;
&lt;li&gt;assigning @Nullable expression to @NonNull field&lt;/li&gt;
&lt;li&gt;method returns @Nullable, but superclass method returns @NonNull&lt;/li&gt;
&lt;li&gt;referenced method returns @Nullable, but functional interface method returns @NonNull&lt;/li&gt;
&lt;li&gt;parameter is @NonNull, but parameter in superclass method is @Nullable&lt;/li&gt;
&lt;li&gt;parameter is @NonNull, but parameter in functional interface method is @Nullable&lt;/li&gt;
&lt;li&gt;unbound instance method reference cannot be used, as first parameter of functional interface method is @Nullable&lt;/li&gt;
&lt;li&gt;initializer method does not guarantee @NonNull field is initialized / @NonNull field not initialized&lt;/li&gt;
&lt;li&gt;read of @NonNull field before initialization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在公司的工程只开启了两个module作为试点，如果能有好的防空效果，会逐步应用到整个工程。目前的主要防空措施就是这些，当然在调研的过程中也引入了一个类似findbugs的工具SpotBug，此插件也已集成好，只要通过一个简单的命令即可开始一次检查&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;./gradlew check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查的结果可以通过输出的本地html文件查看&lt;/p&gt;

&lt;p&gt;用了这么多工具，又是插件，又是检查器，又是注解，说以前道一万，这些都是辅助措施，要真正减少空指针，降低崩溃率，还是要通过编写高质量的代码来实现，上面提到的那个代码片段，实在不能容忍，肯定要喷，必须要改，共勉！&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Sep 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//guide-to-prevent-null-in-android-project</link>
        <guid isPermaLink="true">http://longlinht.github.io//guide-to-prevent-null-in-android-project</guid>
      </item>
    
      <item>
        <title>在WebView中支持视频全屏</title>
        <description>&lt;p&gt;最近感觉和WebView杠上了，刚解决完在WebView中使用Android相机拍照和录像的问题，又遇到在WebView中视频无法全屏，和之前相机拍照和视频的问题一样，iOS和其他浏览器都没有问题，独WebView出错。通过网上查阅一些资料，最终顺利解决，虽不是什么难搞的东西，但是真要弄起来，也需要一些心力，所以通过此篇记录下整个过程。&lt;/p&gt;

&lt;p&gt;解决整个问题其实很程式化，先按部就班保证视频能够正常播放:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在AndroidManifest.xml中声明hardwareAccelerate属性&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; &amp;lt;application android:hardwareAccelerated =&amp;quot;true&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在Activity中声明&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;activity android:hardwareAccelerated=&amp;quot;true&amp;quot; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;在代码中设置&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;getWindow.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后来实现全屏, 而能够全屏的关键在于重写WebChromeClient的onShowCustomView()和onHideCustomView()方法, 在Activity中实现自定义的WebChromeClient，在onShowCustomView中横屏，隐藏WebView,并将得到的View添加到FrameLayout中显示。在onHideCustomView中隐藏View，显示WebView，并竖屏.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private View mCustomView;
private WebChromeClient.CustomViewCallback mCustomViewCallback;

@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    if (mCustomView != null) {
        callback.onCustomViewHidden();
        return;
    }
    mCustomView = view;
    webViewContainer.addView(mCustomView);
    mCustomViewCallback = callback;
    mWebView.setVisibility(View.GONE);
    mTitle.setVisibility(View.GONE);
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
}

@Override
public void onHideCustomView() {
    mWebView.setVisibility(View.VISIBLE);
    mTitle.setVisibility(View.VISIBLE);
    if (mCustomView == null) {
        return;
    }
    mCustomView.setVisibility(View.GONE);
    webViewContainer.removeView(mCustomView);
    mCustomViewCallback.onCustomViewHidden();
    mCustomView = null;
    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中mCustomView和 mCustomViewCallback 需要保存下来，WebView的父容器在实现中也很重要。&lt;/p&gt;

&lt;p&gt;需要注意的问题&lt;/p&gt;

&lt;p&gt;如果H5工程师在html中使用了iframe, 那需要H5工程师配合在其中中加入一些属性才能对视频进行操作，&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;allowfullscreen=&amp;quot;true&amp;quot; webkitallowfullscreen=&amp;quot;true&amp;quot; mozallowfullscreen=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Thu, 11 Jul 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//h5-video-fullscreen-in-webview</link>
        <guid isPermaLink="true">http://longlinht.github.io//h5-video-fullscreen-in-webview</guid>
      </item>
    
      <item>
        <title>解决SharedPreferences导致的ANR</title>
        <description>&lt;p&gt;这几天在Google Play的ANR实时报告中看到很多貌似与SharedPreferences相关的ANR，看了历史版本后发现，这个已经是一个老问题了，在历次版班的ANR中居高不下。今天实在忍不了，决定对这个问题一探究竟。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; at java.lang.Object.wait! (Native method)
- waiting on &amp;lt;0x0a351954&amp;gt; (a java.lang.Object)
  at java.lang.Thread.parkFor$ (Thread.java:1220)
- locked &amp;lt;0x0a351954&amp;gt; (a java.lang.Object)
  at sun.misc.Unsafe.park (Unsafe.java:299)
  at java.util.concurrent.locks.LockSupport.park (LockSupport.java:158)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt (AbstractQueuedSynchronizer.java:810)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly (AbstractQueuedSynchronizer.java:970)
  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly (AbstractQueuedSynchronizer.java:1278)
  at java.util.concurrent.CountDownLatch.await (CountDownLatch.java:203)
  at android.app.SharedPreferencesImpl$EditorImpl$1.run (SharedPreferencesImpl.java:366)
  at android.app.QueuedWork.waitToFinish (QueuedWork.java:88)
  at android.app.ActivityThread.handleServiceArgs (ActivityThread.java:3029)
  at android.app.ActivityThread.access$2200 (ActivityThread.java:155)
  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1450)
  at android.os.Handler.dispatchMessage (Handler.java:102)
  at android.os.Looper.loop (Looper.java:175)
  at android.app.ActivityThread.main (ActivityThread.java:5430)
  at java.lang.reflect.Method.invoke! (Native method)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:726)
  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:616)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这事Google Play提供的堆栈信息，信息非常有限，但是还是能观察到SharedPreferences的身影的，这个 &lt;code&gt;waitToFinish&lt;/code&gt; 非常可疑，追踪到代码:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/**
 * Finishes or waits for async operations to complete.
 * (e.g. SharedPreferences$Editor#startCommit writes)
 *
 * Is called from the Activity base class&amp;#39;s onPause(), after
 * BroadcastReceiver&amp;#39;s onReceive, after Service command handling,
 * etc. (so async work is never lost)
 */
public static void waitToFinish() {
    Runnable toFinish;
    while ((toFinish = sPendingWorkFinishers.poll()) != null) {
        toFinish.run();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的注释已经很清楚了，如果我们使用SharedPreference的apply方法, 虽然该方法可以很快返回， 并在其它线程里将键值对写入到文件系统， 但是当Activity, BroadcastReceiver和Service的一些回调方法被调用时，会等待写入到文件系统的任务完成，如果写入比较慢，主线程就会出现ANR问题。&lt;/p&gt;

&lt;p&gt;另外，SharedPreference除了提供apply外还提供commit方法，源码如下所示，该方法直接在调用线程中执行，不会转入后台，但如果我们在UI线程commit，且磁盘写入较慢的情况下，ANR依然会发生。行文至此，问题应该描述的比较清楚了，可以理解为SharedPreferences的机制导致系统组件回调过程中的阻塞，触发了ANR。可以将这个问题视为Android一个bug，也可以将问题归咎于为使用SharedPreferences不当(在SharedPreferences里读写数据量太大), 但是问题终究要解决，所以下面提出解决方案，并且记录下解决过程中的实践经验。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案一&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑启动一个线程commit，不使用apply&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案二&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hook ActivityThread，拿到Handler变量，在调用QueuedWork.waitToFinish()之前，将其中保存的队列清空，防止ANR的发生&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方案三&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用MMKV替代SharedPrferences&lt;/p&gt;

&lt;p&gt;最后我们选用了第三种方案，对于我们现有的代码改动量最小。第一种方案可行，但是也有问题，会有线程同步，仍然需要管理其他线程，保证读写的一致性。第二种方案不好验证它的副作用，因此也没有采纳。&lt;/p&gt;

&lt;p&gt;选用MMKV后也有一个问题需要解决，那就是数据迁移，因为不可能针对之前所有使用SharedPreferences的地方逐一进行迁移，因此写了一个MMKV的封装类来统一对外提供数据迁移和读写的接口，可以实现对现已代码最小改动的情况下完成替换和迁移。封装类如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class SharedPreferencesStore {
    public static final String TAG = SharedPreferencesStore.class.getSimpleName();

    private MMKV mMMKV;

    private SharedPreferencesStore(MMKV mmkv) {
        mMMKV = mmkv;
    }

    // 初始化，必须在使用前调用
    public static void initialize(Context context) {
        String rootDir = MMKV.initialize(context);
        ApplicationDelegate.log(TAG + &amp;quot; MMKV root directory=&amp;quot; + rootDir);
    }

    // 获取全局SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobal() {
        MMKV mmkv = MMKV.defaultMMKV();
        return new SharedPreferencesStore(mmkv);
    }

    // 获取全局SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getGlobalWithMigration(Context context) {
        MMKV mmkv = MMKV.defaultMMKV();
        importFromDefaultSharePreferences(mmkv, context);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        return new SharedPreferencesStore(mmkv);
    }

    // 获取特定SharedPreferencesStore, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name);
        importFromSharePreferences(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 不需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByName(final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        return new SharedPreferencesStore(mmkv);
    }

    // 需要多进程访问, 需要迁移老的SharedPreferences数据的情况下调用
    public static SharedPreferencesStore getMultiProcessByNameWithMigration(Context context, final String name) {
        MMKV mmkv = MMKV.mmkvWithID(name, MMKV.MULTI_PROCESS_MODE);
        importFromSharePreferencesMultiProcess(mmkv, context, name);
        return new SharedPreferencesStore(mmkv);
    }

    public void put(final String key, boolean value) {
        mMMKV.encode(key, value);
    }

    public boolean getBoolean(final String key, boolean defValue) {
        return mMMKV.decodeBool(key, defValue);
    }

    public void put(final String key, int value) {
        mMMKV.encode(key, value);
    }

    public int getInt(final String key, int defValue) {
        return mMMKV.decodeInt(key, defValue);
    }

    public void put(final String key, long value) {
        mMMKV.encode(key, value);
    }

    public long getLong(final String key, long defValue) {
        return mMMKV.decodeLong(key, defValue);
    }

    public void put(final String key, float value) {
        mMMKV.encode(key, value);
    }

    public float getFloat(final String key, float defValue) {
        return mMMKV.decodeFloat(key, defValue);
    }

    public void put(final String key, double value) {
        mMMKV.encode(key, value);
    }

    public double getDouble(final String key, double defValue) {
        return mMMKV.decodeDouble(key, defValue);
    }

    public void put(final String key, final String value) {
        mMMKV.encode(key, value);
    }

    public String getString(final String key, final String defValue) {
        return mMMKV.decodeString(key, defValue);
    }

    public void put(final String key, final byte[] value) {
        mMMKV.encode(key, value);
    }

    public byte[] getBytes(final String key) {
        return mMMKV.decodeBytes(key);
    }

    public Map&amp;lt;String, ?&amp;gt; getAll() {
        return mMMKV.getAll();
    }

    public void remove(final String key) {
        mMMKV.remove(key);
    }

    public void removeForKey(final String key) {
        mMMKV.removeValueForKey(key);
    }

    public void removeForKeys(final String[] keys) {
        mMMKV.removeValuesForKeys(keys);
    }

    public boolean contains(final String key) {
        return mMMKV.contains(key);
    }

    public boolean containsKey(final String key) {
        return mMMKV.containsKey(key);
    }

    public SharedPreferences.Editor edit() {
        return mMMKV.edit();
    }

    public static void importFromSharePreferences(MMKV mmkv, final Context context, final String name) {
        if (null == context) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_PRIVATE);
        doImport(mmkv, sp, name);
    }

    public static void importFromSharePreferencesMultiProcess(MMKV mmkv, final Context context, final String name) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = context.getSharedPreferences(name, Context.MODE_MULTI_PROCESS);
        doImport(mmkv, sp, name);
    }

    public static void importFromDefaultSharePreferences(MMKV mmkv, final Context context) {
        if (context == null) {
            return;
        }
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(context);
        doImport(mmkv, sp, context.getPackageName() + &amp;quot;_preferences&amp;quot;);
    }

    private static void doImport(MMKV mmkv, SharedPreferences sp, final String name) {
        ApplicationDelegate.log(TAG + &amp;quot; ------&amp;quot; + name + &amp;quot;-----SharedPreferences迁移开始-----------&amp;quot;);
        if (sp.getAll() == null || sp.getAll().size() == 0) {
            ApplicationDelegate.log(TAG + &amp;quot; &amp;quot; + name + &amp;quot; SharedPreferences 为空，不需要迁移&amp;quot;);
            return;
        }

        int oldSize = sp.getAll().size();
        ApplicationDelegate.log(TAG + &amp;quot; old size: &amp;quot; + oldSize);

        Map&amp;lt;String, ?&amp;gt; map = sp.getAll();

        Map&amp;lt;String, String&amp;gt; keyTypes = new HashMap&amp;lt;&amp;gt;();

        ApplicationDelegate.log(TAG + &amp;quot; ---old data: &amp;quot;);
        for (Map.Entry&amp;lt;String, ?&amp;gt; entry : map.entrySet()) {
            Object obj = entry.getValue();
            if (obj instanceof Boolean) {
                keyTypes.put(entry.getKey(), &amp;quot;Boolean&amp;quot;);
            } else if (obj instanceof Integer) {
                keyTypes.put(entry.getKey(), &amp;quot;Integer&amp;quot;);
            } else if (obj instanceof Long) {
                keyTypes.put(entry.getKey(), &amp;quot;Long&amp;quot;);
            } else if (obj instanceof Float) {
                keyTypes.put(entry.getKey(), &amp;quot;Float&amp;quot;);
            } else if (obj instanceof Double) {
                keyTypes.put(entry.getKey(), &amp;quot;Double&amp;quot;);
            } else if (obj instanceof String) {
                keyTypes.put(entry.getKey(), &amp;quot;String&amp;quot;);
            }
            ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + entry.getKey() + &amp;quot; value: &amp;quot; + entry.getValue());
        }


        int imported = mmkv.importFromSharedPreferences(sp);
        ApplicationDelegate.log(TAG + &amp;quot; imported size: &amp;quot; + imported);

        if (BuildConfig.DEBUG) {
            ApplicationDelegate.log(TAG +  &amp;quot; ---imported data: &amp;quot;);

            String[] keys = mmkv.allKeys();
            for (int i = 0; i &amp;lt; keys.length; i++) {

                String type = keyTypes.get(keys[i]);
                if (type == null) {
                    continue;
                }

                switch (type) {
                    case &amp;quot;Boolean&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeBool(keys[i]));
                        break;
                    case &amp;quot;Integer&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeInt(keys[i]));
                        break;
                    case &amp;quot;Long&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeLong(keys[i]));
                        break;
                    case &amp;quot;Float&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeFloat(keys[i]));
                        break;
                    case &amp;quot;Double&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeDouble(keys[i]));
                        break;
                    case &amp;quot;String&amp;quot;:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: &amp;quot; + mmkv.decodeString(keys[i]));
                        break;
                    default:
                        ApplicationDelegate.log(TAG + &amp;quot; key: &amp;quot; + keys[i] + &amp;quot; value: unknown type&amp;quot;);
                        break;
                }
            }
        }


        if (imported &amp;gt; 0 &amp;amp;&amp;amp; oldSize == imported) {
            sp.edit().clear().apply();
        }

        if (oldSize != imported) {
            ApplicationDelegate.log(TAG + &amp;quot; SharedPreferences 迁移失败, name=&amp;quot; + name);
            ApplicationDelegate.bugTrace(ApplicationDelegate.MAIN_CODE_MMKV_IMPORT_FAIL, 0,
                    &amp;quot;name=&amp;quot; + name + &amp;quot;, old size=&amp;quot; + oldSize + &amp;quot;, import size=&amp;quot; + imported);
        }
        ApplicationDelegate.log(TAG +  &amp;quot; ------&amp;quot; + name + &amp;quot;-----SharedPreferences迁移结束-----------&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次替换和迁移目前已经上线验证 ，目前只发现在API 19的机器上出现崩溃，报java.lang.UnsatisfiedLinkError，MMKV的官网上有次问题的解答，可以参考解决。&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jul 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//fix-anr-related-sharedpreferences</link>
        <guid isPermaLink="true">http://longlinht.github.io//fix-anr-related-sharedpreferences</guid>
      </item>
    
      <item>
        <title>在WebView中调用Android相机拍照录像</title>
        <description>&lt;p&gt;最近公司App需要以H5的方式接入七鱼客服，根据他们的开发文档接入起来还是很容易，成本很低。理论上如果以native的方式接入的话，用户体验会更好，但是接入后增加的包体积是无法接受的，遂改用H5的方式，整个接入过程还算顺利，有相对详尽的接入文档和demo，只是在最后接入完成后，因为沟通不畅，忽略了客服聊天界面在Android上无法发图片和发视频的问题。同一份html，iOS就是正常的，Android上就死活没反应。后来才恍然大悟，WebView是不支持JS去直接操作Android相机的，必须通过回调到native，由native完成照片的选择，拍摄和录像后将数据返回给JS才能完成一次照片和视频的发送。清楚了问题所在，就需要实现WebView的标准接口来实现这个回调到native的功能，在代码实现前，需要先厘清一些WebView的基本概念和原理。&lt;/p&gt;

&lt;p&gt;像发送图片和视频这样的操作，涉及到了定制WebView的一些默认行为，理论上如果要做定制，就需要了解WebSettings、JavaScriptInterface、WebViewClient以及WebChromeClient，一般而言，通过配置WebSettings，使用JavasScriptInterface，重写WebViewClient和WebChromeClient对象的相关方法，就可以实现一些我们想要的行为。发图片和发视频就是通过重写WebChromeClient对象的几个方法来实现的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// 重写WebChromeClient的特定方法来实现图片和视频的发送
mWebView.setWebChromeClient(new WebChromeClient() {
    // For Android &amp;gt;=3.0
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg, String acceptType) {
        if(acceptType.equals(&amp;quot;image/*&amp;quot;)) {
            if (mUploadMessage != null) {
                mUploadMessage.onReceiveValue(null);
                return;
            }
            mUploadMessage = uploadMsg;
            selectImage();
        } else {
            onReceiveValue();
        }
    }

    // For Android &amp;lt; 3.0
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg) {
        openFileChooser(uploadMsg, &amp;quot;image/*&amp;quot;);
    }

    // For Android  &amp;gt;= 4.1.1
    public void openFileChooser(ValueCallback&amp;lt;Uri&amp;gt; uploadMsg, String acceptType, String capture) {
        openFileChooser(uploadMsg, acceptType);
    }

    // For Android  &amp;gt;= 5.0
    @Override
    @SuppressLint(&amp;quot;NewApi&amp;quot;)
    public boolean onShowFileChooser(WebView webView, ValueCallback&amp;lt;Uri[]&amp;gt; filePathCallback, FileChooserParams fileChooserParams) {
        if (fileChooserParams != null &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes() != null
                &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes().length &amp;gt; 0 &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;image/*&amp;quot;)) {
            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            selectImage();
        } else if (fileChooserParams != null &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes() != null
                &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes().length &amp;gt; 0 &amp;amp;&amp;amp; fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;video/*&amp;quot;)){

            if (mUploadMessageArray != null) {
                mUploadMessageArray.onReceiveValue(null);
            }
            mUploadMessageArray = filePathCallback;
            PermissionUtil.requestPermission(QiyuWebViewActivity.this, PermissionUtil.PERMISSIONS_CAMERA_RECORD_AUDIO, PermissionUtil.REQUEST_CAMERA_RECORD_AUDIO);
        } else {
            onReceiveValue();
        }
        return true;
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，这几个回调方法，需要针对不同Android版本分别做处理，在onShowFileChooser方法中需要区分是图片还是视频，并且无论是在相册中选取还是拍摄照片，录像都需要申请相应的权限，这个一定不能少，网上很多的demo都是没有权限申请环节的，代码根本不可用。&lt;/p&gt;

&lt;p&gt;在正确的回调到onShowFileChooser后，就要区分图片和视频的情况下走正常的选取，拍照，录像的流程，并且把获取到的图片，视频数据回传给JS调用，这样就完成了桥接调用。虽然现在看起来挺简单的，但是还是有些点容易成为坑点，让人走很多弯路:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要的配置一定要设定&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mWebView.getSettings().setJavaScriptEnabled(true);
mWebView.getSettings().setDomStorageEnabled(true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态权限申请一定不能少&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正确区分图片和视频&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// &amp;quot;video/* 为视频&amp;quot;
fileChooserParams.getAcceptTypes()[0].equals(&amp;quot;image/*&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下，在WebView的JS调用系统相机的关键是重写WebChromeClient的特定方法来实现的。&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Jun 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//operate-camera-in-webview</link>
        <guid isPermaLink="true">http://longlinht.github.io//operate-camera-in-webview</guid>
      </item>
    
      <item>
        <title>HTTP/2 从初探到实际场景的运用</title>
        <description>&lt;p&gt;HTTP/2其实出来已经很长时间了，但是一个新的协议，新的标准从出现到大量被采用，总是会经历一个过程。我们的产品最近基于网络请求优化的要求，需要将之前的HTTP/1都升级到支持HTTP/2，这个事情其实需要两方同时进行，服务端和客服端需要同时支持HTT/2。在做这个事情之前需要首先调研HTTP/2，了解它的特性和优缺点。&lt;/p&gt;

&lt;p&gt;对HTTP2的基本的调研结果如下:&lt;/p&gt;

&lt;h4&gt;HTTP/2的由来&lt;/h4&gt;

&lt;p&gt;HTTP/2 的前身是 SPDY协议，第一版草稿就是基于 SPDY3 规范修改制定而来。HTTP/2维持了原来 HTTP 的范式（不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等等）&lt;/p&gt;

&lt;h4&gt;为什么是HTTP/2&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接次数减少 
理想情况下，单个域名对应一条链接，如果此链接一直保持有数据传输，则类似一个长链接，不会建立多条链接，HTTP/1.1虽然也可以通过keep-alive做到类似的效果，但是无法做到请求并发，这也是HTTP/2不同于HTTP/1.x的一个重要方面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发发送请求 
发送请求不再是串行, 提高了发送效率,同一时间可同时发出多个请求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流量节省 
由于 HTTP/2的发送协议的修改和优化，流量的表现也有明显提升。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;HTTP/2的特性&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制分帧
HTTP/2 在维持原有 HTTP 范式的前提下，实现突破性能限制，改进传输性能，实现低延迟和高吞吐量的其中一个关键是：在应用层（HTTP2）和传输层（TCP or
UDP）之间增加了二进制分帧层&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多路复用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同一个流中的帧是交错传输的！&lt;/li&gt;
&lt;li&gt;Header 帧必须在 data 帧前面，因为无论是客户端还是服务端，都依赖 header 帧的信息解析 data 帧的数据！&lt;/li&gt;
&lt;li&gt;先到的帧不一定先返回，快的可以先返回！ &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头压缩&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过HPACK 压缩算法，HTTP2 在户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器推送&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;送优先级与依赖性&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可重置&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流量控制&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTTPS RFC 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和服务器实现都基于 HTTPS 来实现 HTTP/2&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上是在支持HTTP/2前所做的一些调研，一些HTTP/2的特性，略显简略，因为此文的重点并不是介绍协议特性，因此就不赘述了。接下我想具体谈谈我们在支持HTTP/2的过程中所做的事，所遇到的问题和解决方法。&lt;/p&gt;

&lt;h4&gt;在现有工程支持HTTP/2&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用大名鼎鼎的OkHttp来替换原有使用HttpURLConnection封装的网络基础模块，因为OkHttp原生支持HTTP/2，实际上我们不需要自己去实现HTTP/2协议，更不需要去设计和管理复杂的网络基础设施。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对现有代码逻辑的兼容&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为现有代码中很多不那么规范的写法，例如文件上传，将参数拼接和文件内容的字节流写在了一起，这类网络请求本来也不是HTTP/2的优势场景，因此还是走HTTP/1.x协议，因此我们设计了一个网络请求协议分派的管理类，在这个类里面统一做网络请求协议的分发。这样做的另一个考量是如果支持HTTP/2协议的这个版本在上线后出现大面积问题的话，可以迅速再切回HTTP/1.x。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加入顺延心跳&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTTP/2的理想情况下有点类似长连接，但是毕竟不是长连接，在一定的时间段如果没有请求的话，连接一样会断开，因为我们App的大部分业务请求其实都对应一个域名，所以保持这条连接一直不断就变得比较有意义，所有我们加入了心跳机制，心跳间隔以顺延的方式，进一步减少不必要的心跳，这样一来既不会有过多的心跳，也保证了连接不会频繁断开。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DNS 优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个在上一篇讨论连通性的文章中已经讨论过了，这里就不再详述。&lt;/p&gt;

&lt;h4&gt;如何衡量HTTP/2带来的提升&lt;/h4&gt;

&lt;p&gt;有的时候衡量你做的事的结果比起做事本省可能还要难，这次支持HTTP/2和优化连通性的工作就属于此类，做本身真不是很难，可预见的问题也都在可控范围之内，但是要衡量它的效果，或者说带来的提升和优化，这就需要设计一整套的衡量指标了，并且这些指标也都需要在这个支持HTTP/2的版本上线前就准备好。为此，我们也是调研了很多资料，结合我们能通过上报的数据，最终定下了如下几个指标来衡量:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RTT - 完成整个事件的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据我们为了和没有支持HTTP/2的版本作比较，将上报的数据做了分区间整理，也就是将耗时从&lt;200ms, 200~500ms, 500~700ms, 700~1000ms, &gt;1000ms做了五个区间来统计每个区间的请求数在总请求数中的占比，通过两个版本的数据来验证HTTP/2的优化和提升，这个指标是最直观的。为了避免一些脏数据导致的数据偏差，我们还针对单个接口进行了数据分析。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求失败率 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个比率是有所下降的，尤其UnknownHostException异常导致的失败在总失败中所占比重明显下降，这个数据的提升得益于上篇文章中对连通性的优化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求各个阶段的耗时 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个数据做了上报和统计，但是并没有去细致的分析各个阶段的耗时，不过的确可以作为一个参考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;观察并发请求下的表现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为我们做的是直播业务，在进入直播间的一瞬间，可能会有非常多的并发请求，这种场景就体现出了HTTP/2并发发送请求的特性，可以说提升非常可观。&lt;/p&gt;

&lt;h4&gt;如何测试HTTP/2&lt;/h4&gt;

&lt;p&gt;如果在有限的资源条件下测试和验证HTTP/2，可能最先想到的就是要进行弱网环境测试:&lt;/p&gt;

&lt;p&gt;如何进行弱网测试:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SIM卡的网络切换,手机-设置-移动网络设置-网络类型选择3G,4G卡都可以设置关闭3G/4G，只走2G网络&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用虚拟机模拟网络速度,如用树莓派搭建的弱网测试仪&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用软件进行网络代理,模拟不同的网络带宽、延时率、丢包率&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Charles&lt;/li&gt;
&lt;li&gt;Chrome的webview调试工具&lt;/li&gt;
&lt;li&gt;iOS自带Network Linker Conditioner&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上就是我们在支持HTTP/2过程中的一些调研结果和实际工作中的经验总结。&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jun 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//upgrade-to-http2</link>
        <guid isPermaLink="true">http://longlinht.github.io//upgrade-to-http2</guid>
      </item>
    
      <item>
        <title>优化App网络连通性问题</title>
        <description>&lt;p&gt;最近遇到一个棘手的问题，我们开发的一款App在中东那边出现大量的&lt;code&gt;UnknownHostException&lt;/code&gt;, 导致App在中东那边体验很糟，很快这个问题就被抛给了我们技术优化组，我和另外一名同事就开始定位问题的原因并且试图提出一个可行的解决方案。一般理解，出现&lt;code&gt;UnkownHostException&lt;/code&gt;就是DNS失败了，在我们开始解决这个问题的时候，App的网络库已逐渐开始使用OkHttp，我们想到自定义DNS过程，在系统DNS失败的情况下再尝试其他DNS方式，降低&lt;code&gt;UnknownHostException&lt;/code&gt;出现的频率，优化App网络连通性。
为了实现我们的技术方案，我们针对OkHttp的DNS做了如下几件事:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建OkHttpClient时自定义DNS&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;OkHttpClient.Builder builder = new OkHttpClient.Builder()
    // 实现OKHttp DNS接口, 改变默认的DNS行为
    .dns(OkHttpDns.getInstance())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的OkHttpDns须实现Dns接口&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现自定义DNS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前我们的设计是使用责任链模式实现四层DNS的lookup: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第一层是本地DNS缓存(Local Cache)，整个缓存只是内存缓存，DNS过程开始时，先去本地缓存找，如果在缓存中没有命中，就走系统DNS， 系统DNS如果也失败，整个链条就继续往下，到GA，到Google DNS，如果到Google DNS还没有解析成功，仍旧抛出&lt;code&gt;UnknownHostException&lt;/code&gt;，DNS过程失败。基本的代码逻辑如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;private OkHttpDns() {

  //使用责任链模式实现四层DNS的lookup: Local Cache --&amp;gt; System DNS --&amp;gt; GA --&amp;gt; Google DNS
  mDnsChain = new CacheDnsHandler();

  SystemDnsHandler okhttp = new SystemDnsHandler();
  GADnsHandler ga = new GADnsHandler();
  GoogleHttpDnsHandler google = new GoogleHttpDnsHandler();

  mDnsChain.setTarget(okhttp);
  okhttp.setTarget(ga);
  ga.setTarget(google);
}

@Override
public List&amp;lt;InetAddress&amp;gt; lookup(String hostname) throws UnknownHostException {
  // IP直连的情况,直接返回
  if (InetAddressValidator.isIPAddress(hostname)) {
      return Arrays.asList(InetAddress.getAllByName(hostname));
  }

  List&amp;lt;InetAddress&amp;gt; allDNSResult = new ArrayList&amp;lt;&amp;gt;();
  List&amp;lt;InetAddress&amp;gt; list = mDnsChain.lookup(hostname, allDNSResult);

  if (list == null) {

      // DNS完全失败后,清空黑名单,删除local cache相应的条目
      IPStatusCache.getInstance().clear();

      if (allDNSResult.isEmpty()) {
          throw new UnknownHostException(&amp;quot;Broken system behaviour for dns lookup of &amp;quot; + hostname);
      } else {
          return allDNSResult;
      }
  }
  return list;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加黑名单机制，进一步优化DNS
一次连接成功后缓存DNS结果，host+ip为key，IPStatus为value，连接失败后会更新DNS缓存的失败次数，超过5次则认为进入了黑名单，在每次DNS完全失败后清空本地DNS缓存，防止所有的缓存都进入黑名单，缓存失效。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理IP直连的情况
这种情况的处理很简单，检查传入的host是不是ip，如果是就直接返回。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;经过这样的优化以后，&lt;code&gt;UnknownHostException&lt;/code&gt;在请求失败中的比重和请求的总失败率大幅下降，验证了我们这个技术方案的合理性，可以说网络连通性大大提高，再次回顾这个方案，突然发现它其实一个通用的解决方案，虽然我们这次解决的是海外，如中东地区的连通性问题，其实这个方案完全可以移植到国内，只要将Google HttpDNS换成国内的HttpDNS即可，整体的DNS流程可以不做任何改动即可成为一个完整的App DNS解决方案。&lt;/p&gt;
</description>
        <pubDate>Wed, 29 May 2019 04:20:12 +0800</pubDate>
        <link>http://longlinht.github.io//connectivity-in-android</link>
        <guid isPermaLink="true">http://longlinht.github.io//connectivity-in-android</guid>
      </item>
    
  </channel>
</rss>